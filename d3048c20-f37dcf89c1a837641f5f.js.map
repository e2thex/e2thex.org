{"version":3,"sources":["webpack:///./node_modules/slate/dist/index.es.js"],"names":["_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","from","test","_unsupportedIterableToArray","length","i","F","s","done","value","e","_e","f","TypeError","err","normalCompletion","didErr","step","next","_e2","return","arr","len","arr2","_defineProperty","obj","key","defineProperty","enumerable","configurable","writable","_objectWithoutProperties","source","excluded","target","sourceKeys","keys","indexOf","_objectWithoutPropertiesLoose","getOwnPropertySymbols","sourceSymbolKeys","propertyIsEnumerable","DIRTY_PATHS","WeakMap","FLUSHING","NORMALIZING","PATH_REFS","POINT_REFS","RANGE_REFS","SPACE","PUNCTUATION","CHAMELEON","getCharacterDistance","text","offset","prev","charCode","charCodeAt","isSurrogate","modifier","isModifier","isBMPEmoji","isVariationSelector","getWordDistance","char","started","charAt","l","rest","isWordCharacter","remaining","code","ownKeys","object","enumerableOnly","symbols","filter","sym","getOwnPropertyDescriptor","push","apply","_objectSpread","arguments","forEach","getOwnPropertyDescriptors","defineProperties","Editor","above","editor","options","undefined","_options$voids","voids","_options$mode","mode","_options$at","at","selection","match","_step","path","reverse","_iterator","levels","_step$value","p","Text","isText","Path","equals","addMark","after","_step2","anchor","point","edge","focus","end","range","_options$distance","distance","d","_iterator2","positions","before","_step3","start","_options$distance2","_iterator3","deleteBackward","_options$unit","unit","deleteForward","_options$unit2","deleteFragment","edges","first","node","fragment","Node","hasBlocks","element","children","some","isBlock","hasInlines","isInline","hasTexts","every","insertBreak","insertFragment","insertNode","insertText","Element","isElement","isEditor","isVoid","normalizeNode","onChange","removeMark","marks","Range","isRange","isNodeList","Operation","isOperationList","operations","isEnd","Point","isEdge","isStart","isEmpty","isNormalizing","get","last","leaf","mark","_options$at2","_options$reverse","_options$voids2","_iterator4","_step4","_step4$value","_args","wrap","_context","abrupt","t0","finish","delegateYield","stop","isExpanded","_Editor$nodes","nodes","_Editor$leaf","previous","block","_prev2","prevNode","prevPath","blockPath","isAncestor","_options$mode2","_options$voids3","_options$at3","_Editor$last","_Editor$last2","_Editor$last3","_Editor$last4","to","span","isPath","Error","_Editor$parent","parent","_Editor$parent2","includes","_Editor$nodes3","_Editor$nodes4","_options$at4","_options$mode3","_options$universal","universal","_options$reverse2","_options$voids4","nodeEntries","matches","hit","_iterator5","_step5","_step5$value","isLower","emit","_args2","_context2","Span","isSpan","pass","_ref","compare","normalize","_options$force","force","getDirtyPaths","allPaths","_ref2","set","withoutNormalizing","max","m","concat","pop","entry","parentPath","depth","_Node$first","_Node$first2","firstPath","_Node$last","_Node$last2","lastPath","common","isPoint","pathRef","_options$affinity","affinity","ref","current","unref","pathRefs","delete","refs","add","Set","_options$edge","_Node$last3","_Node$last4","_Node$first3","_Node$first4","_Range$edges","_Range$edges2","pointRef","_options$affinity2","pointRefs","_options$at5","_options$unit3","_options$reverse3","reverse$1","_Range$edges3","_Range$edges4","string","available","isNewBlock","advance","_iterator6","_step6","_step6$value","isFirst","_args3","_context3","_options$mode4","_options$voids5","_options$at6","_Editor$first","_Editor$first2","_Editor$first3","_Editor$first4","_Editor$parent3","_Editor$parent4","_Editor$nodes5","_Editor$nodes6","rangeRef","_options$affinity3","rangeRefs","_step7","_Range$edges5","_Range$edges6","_iterator7","_step7$value","t","unhangRange","_options$voids6","_Range$edges7","_Range$edges8","isCollapsed","_step8","endBlock","skip","_iterator8","_step8$value","isBefore","void","fn","isElementList","props","Location","isLocation","ancestor","root","ancestors","_iterator9","_step9","_args4","_context4","child","index","JSON","stringify","c","_options$reverse4","childPath","_args5","_context5","another","descendant","descendants","_iterator10","_step10","_step10$value","_args6","_context6","elements","_iterator11","_step11","_step11$value","_args7","_context7","r","_step12","_Range$edges9","_Range$edges10","_iterator12","splice","_leaf","has","isNode","_iterator13","_step13","_args8","_context8","_options$reverse5","_options$from","visited","nextIndex","newPath","_newPath","_args9","_context9","isAfter","map","join","texts","_iterator14","_step14","_step14$value","_args10","_context10","ownKeys$1","_objectSpread$1","isNodeOperation","isOperation","type","endsWith","position","properties","newProperties","isSelectionOperation","isTextOperation","inverse","op","isSibling","transform","_properties","_newProperties","_options$reverse6","paths","av","min","Math","endsAfter","as","bs","bv","endsAt","endsBefore","isChild","isCommon","isDescendant","isParent","_options$reverse7","list","relative","operation","_options$affinity4","_op","_op2","_op3","_position","_op4","onp","copy","PathRef","ownKeys$2","_objectSpread$2","result","_options$affinity5","PointRef","ownKeys$3","_options$reverse8","isBackward","_Range$edges11","_Range$edges13","_Range$edges14","rs","re","_Range$edges15","_Range$edges16","ts","te","_Range$edges17","_Range$edges18","isAfterStart","isBeforeEnd","intersection","_Range$edges19","_Range$edges20","s1","e1","_Range$edges21","_Range$edges22","s2","e2","_objectSpread$3","isForward","points","_context11","_Range$edges23","affinityAnchor","affinityFocus","_options$affinity6","RangeRef","ownKeys$4","_objectSpread$4","_options$loose","loose","_key","isTextList","decorations","_decorations","_step15","leaves","_iterator15","_step16","dec","_Range$edges25","_Range$edges26","_iterator16","assign","middle","off","_off","ownKeys$5","_objectSpread$5","ownKeys$6","_objectSpread$6","NodeTransforms","insertNodes","_options$hanging","hanging","_options$voids7","_options$mode5","select","_nodes","_Range$edges27","Transforms","_Editor$nodes7","_matchPath","isAtEnd","splitNodes","_step25","_iterator25","_node","_path","liftNodes","_options$at7","_options$mode6","_options$voids8","matchPath","_i","_pathRefs","parentNodeEntry","_parentNodeEntry","toPath","moveNodes","removeNodes","_toPath","splitPath","_toPath2","mergeNodes","_options$at8","_options$hanging2","_options$voids9","_options$mode7","_Editor$parent5","_Range$edges29","_Editor$nodes9","_current","_prev3","commonPath","isPreviousSibling","emptyAncestor","emptyRef","_options$at9","_options$mode8","_options$voids10","toRef","targets","_i2","_pathRefs2","_ref3","_options$hanging3","_options$voids11","_options$mode9","_options$at10","depths","_i3","_pathRefs3","_ref4","_Editor$node","setNodes","_options$at11","_options$hanging4","_options$mode10","_options$split","split","_options$voids12","_Range$edges31","_Range$edges32","splitMode","_step26","_iterator26","_step26$value","k","_options$mode11","_options$voids13","_options$at12","_options$height","height","_options$always","always","deleteRange","_Editor$parent7","beforeRef","_Editor$nodes11","highest","voidMatch","_voidMatch","voidNode","voidPath","afterPath","_step27","afterRef","highestPath","lowestPath","_iterator27","_step27$value","_path2","_point","_point2","unsetNodes","_step28","_iterator28","unwrapNodes","_options$mode12","_options$split2","_options$voids14","_options$at13","_loop","_Editor$node3","_i4","_pathRefs4","_ref5","wrapNodes","_options$mode13","_options$split3","_options$voids15","_options$at14","_Range$edges33","_Range$edges34","_i5","_roots","rootPath","a","commonNodeEntry","commonNode","wrapperPath","wrapper","_Range$edges35","_Editor$node5","ownKeys$7","ownKeys$8","_objectSpread$8","_step17","_iterator17","_step17$value","_step18","_iterator18","_step18$value","_node2","_parent","_index","_prev$children","_step19","_iterator19","_step19$value","_path3","_node3","_parent2","_index2","truePath","newParent","newIndex","_step20","_iterator20","_step20$value","_point3","_path4","_index3","_step21","_iterator21","_step21$value","_point4","_key4","_step22","_prev","_iterator22","_step22$value","_path5","_offset","_text","_node4","_before","_after","_step23","_iterator23","_step23$value","_point5","_path6","_node5","_key6","_path7","newNode","_node6","_parent4","_index4","_before2","_after2","_before3","_after3","_step24","_iterator24","_step24$value","_point6","collapse","_options$edge2","_Range$edges37","_Range$edges38","_Range$edges39","_Range$edges40","deselect","move","_options$distance3","_options$unit4","_options$reverse9","_options$edge3","opts","setSelection","setPoint","_options$edge4","_objectSpread$7","oldProps","newProps","_options$reverse10","_options$unit5","_options$distance4","_options$voids16","_options$at15","_options$hanging5","furthestVoid","_Range$edges41","_Range$edges42","startBlock","isAcrossBlocks","isSingleText","startVoid","endVoid","_step29","_iterator29","_entry2","startRef","endRef","_Editor$leaf3","_i6","_pathRefs5","_Editor$leaf5","_options$hanging6","_options$voids17","_options$at16","_Range$edges43","inlineElementMatch","_inlinePath","_step30","blockMatch","isBlockStart","isBlockEnd","mergeStart","mergeEnd","_Node$first5","_Node$last5","matcher","_ref15","_iterator30","starts","middles","ends","starting","_i7","_matches2","_Editor$nodes13","inlineMatch","inlinePath","isInlineStart","isInlineEnd","middleRef","_end","_options$voids18","_options$at17","_at","ownKeys$9","_objectSpread$9","createEditor","_step31","_iterator31","_step32","_iterator32","_step33","_iterator33","_step34","dirtyPaths","oldDirtyPaths","newDirtyPaths","_iterator34","_step35","_iterator35","Promise","resolve","then","getFragment","inline","_entry3","shouldHaveInlines","_child","isLast","previousPath","_step36","oldAncestors","newAncestors","_iterator36","_step37","_iterator37","_ancestor","_p","_ancestors","_levels","nextPath"],"mappings":"6FAAA,0sBAMA,SAASA,EAA2BC,EAAGC,GAAkB,IAAIC,EAAI,GAAsB,oBAAXC,QAAgD,MAAtBH,EAAEG,OAAOC,UAAmB,CAAE,GAAIC,MAAMC,QAAQN,KAAOE,EAE7J,SAAqCF,EAAGO,GAAU,IAAKP,EAAG,OAAQ,GAAiB,iBAANA,EAAgB,OAAOQ,EAAkBR,EAAGO,GAAS,IAAIE,EAAIC,OAAOC,UAAUC,SAASC,KAAKb,GAAGc,MAAM,GAAI,GAAc,WAANL,GAAkBT,EAAEe,cAAaN,EAAIT,EAAEe,YAAYC,MAAM,GAAU,QAANP,GAAqB,QAANA,EAAa,OAAOJ,MAAMY,KAAKjB,GAAI,GAAU,cAANS,GAAqB,2CAA2CS,KAAKT,GAAI,OAAOD,EAAkBR,EAAGO,GAFpPY,CAA4BnB,KAAOC,GAAkBD,GAAyB,iBAAbA,EAAEoB,OAAqB,CAAMlB,IAAIF,EAAIE,GAAI,IAAImB,EAAI,EAAOC,EAAI,aAAiB,MAAO,CAAEC,EAAGD,EAAGb,EAAG,WAAe,OAAIY,GAAKrB,EAAEoB,OAAe,CAAEI,MAAM,GAAe,CAAEA,MAAM,EAAOC,MAAOzB,EAAEqB,OAAWK,EAAG,SAAWC,GAAM,MAAMA,GAAOC,EAAGN,GAAO,MAAM,IAAIO,UAAU,yIAA4I,IAA6CC,EAAzCC,GAAmB,EAAMC,GAAS,EAAY,MAAO,CAAET,EAAG,WAAerB,EAAKF,EAAEG,OAAOC,aAAgBK,EAAG,WAAe,IAAIwB,EAAO/B,EAAGgC,OAAsC,OAA9BH,EAAmBE,EAAKT,KAAaS,GAASP,EAAG,SAAWS,GAAOH,GAAS,EAAMF,EAAMK,GAAQP,EAAG,WAAe,IAAWG,GAAiC,MAAb7B,EAAGkC,QAAgBlC,EAAGkC,SAAY,QAAU,GAAIJ,EAAQ,MAAMF,KAIl9B,SAAStB,EAAkB6B,EAAKC,IAAkB,MAAPA,GAAeA,EAAMD,EAAIjB,UAAQkB,EAAMD,EAAIjB,QAAQ,IAAK,IAAIC,EAAI,EAAGkB,EAAO,IAAIlC,MAAMiC,GAAMjB,EAAIiB,EAAKjB,IAAOkB,EAAKlB,GAAKgB,EAAIhB,GAAM,OAAOkB,EAMhL,SAASC,EAAgBC,EAAKC,EAAKjB,GAYjC,OAXIiB,KAAOD,EACT/B,OAAOiC,eAAeF,EAAKC,EAAK,CAC9BjB,MAAOA,EACPmB,YAAY,EACZC,cAAc,EACdC,UAAU,IAGZL,EAAIC,GAAOjB,EAGNgB,EAkBT,SAASM,EAAyBC,EAAQC,GACxC,GAAc,MAAVD,EAAgB,MAAO,GAE3B,IAEIN,EAAKrB,EAFL6B,EAlBN,SAAuCF,EAAQC,GAC7C,GAAc,MAAVD,EAAgB,MAAO,GAC3B,IAEIN,EAAKrB,EAFL6B,EAAS,GACTC,EAAazC,OAAO0C,KAAKJ,GAG7B,IAAK3B,EAAI,EAAGA,EAAI8B,EAAW/B,OAAQC,IACjCqB,EAAMS,EAAW9B,GACb4B,EAASI,QAAQX,IAAQ,IAC7BQ,EAAOR,GAAOM,EAAON,IAGvB,OAAOQ,EAMMI,CAA8BN,EAAQC,GAInD,GAAIvC,OAAO6C,sBAAuB,CAChC,IAAIC,EAAmB9C,OAAO6C,sBAAsBP,GAEpD,IAAK3B,EAAI,EAAGA,EAAImC,EAAiBpC,OAAQC,IACvCqB,EAAMc,EAAiBnC,GACnB4B,EAASI,QAAQX,IAAQ,GACxBhC,OAAOC,UAAU8C,qBAAqB5C,KAAKmC,EAAQN,KACxDQ,EAAOR,GAAOM,EAAON,IAIzB,OAAOQ,EAGT,IAAIQ,EAAc,IAAIC,QAClBC,EAAW,IAAID,QACfE,EAAc,IAAIF,QAClBG,EAAY,IAAIH,QAChBI,EAAa,IAAIJ,QACjBK,EAAa,IAAIL,QAKjBM,EAAQ,KACRC,EAAc,qyCACdC,EAAY,kBAQZC,EAAuB,SAA8BC,GAWvD,IAVA,IAAIC,EAAS,EAOTC,EAAO,KACPC,EAAWH,EAAKI,WAAW,GAExBD,GACL,GAAIE,EAAYF,GAAhB,CACE,IAAIG,EAAWC,EAAWJ,EAAUH,EAAMC,GAI1C,GAAa,SAATC,GAA4B,QAATA,EACrB,MAGFD,GAAU,EACVC,EAAOI,EAAW,MAAQ,OAC1BH,EAAWH,EAAKI,WAAWH,QAM7B,GAlCoB,OAkChBE,EAOJ,GAAIK,EAAWL,GAAf,CACE,GAAID,GAAiB,QAATA,GAA2B,QAATA,EAC5B,MAGFD,GAAU,EACVC,EAAO,MACPC,EAAWH,EAAKI,WAAWH,OAP7B,CAWA,IAAIQ,EAAoBN,GAAxB,CAaA,GAAa,QAATD,EAAgB,CAClBD,GAAU,EACV,MAIF,MAlBE,GAAIC,GAAiB,QAATA,EACV,MAGFD,GAAU,EACVC,EAAO,MACPC,EAAWH,EAAKI,WAAWH,QAxB3BA,GAAU,EACVC,EAAO,MACPC,EAAWH,EAAKI,WAAWH,GAqC/B,OAAOA,GAAU,GAOfS,EAAkB,SAAyBV,GAM7C,IALA,IAGIW,EAHA5D,EAAS,EACTC,EAAI,EACJ4D,GAAU,EAGPD,EAAOX,EAAKa,OAAO7D,IAAI,CAC5B,IAAI8D,EAAIf,EAAqBY,GAC7BA,EAAOX,EAAKvD,MAAMO,EAAGA,EAAI8D,GACzB,IAAIC,EAAOf,EAAKvD,MAAMO,EAAI8D,GAE1B,GAAIE,EAAgBL,EAAMI,GACxBH,GAAU,EACV7D,GAAU+D,MACL,IAAKF,EAGV,MAFA7D,GAAU+D,EAKZ9D,GAAK8D,EAGP,OAAO/D,GAQLiE,EAAkB,SAASA,EAAgBL,EAAMM,GACnD,GAAIrB,EAAM/C,KAAK8D,GACb,OAAO,EAKT,GAAIb,EAAUjD,KAAK8D,GAAO,CACxB,IAAI9C,EAAOoD,EAAUJ,OAAO,GACxB9D,EAASgD,EAAqBlC,GAIlC,GAAImD,EAHJnD,EAAOoD,EAAUxE,MAAM,EAAGM,GACfkE,EAAUxE,MAAMM,IAGzB,OAAO,EAIX,OAAI8C,EAAYhD,KAAK8D,IAWnBN,EAAc,SAAqBa,GACrC,OAhJoB,OAgJMA,GAAQA,GA/IhB,OAwJhBX,EAAa,SAAoBW,EAAMlB,EAAMC,GAC/C,GAAa,QAATiB,EAAiB,CACnB,IAAIrD,EAAOmC,EAAKI,WAAWH,EAAS,GACpC,OAAOpC,GAAQ,OAAUA,GAAQ,MAGnC,OAAO,GASL4C,EAAsB,SAA6BS,GACrD,OAAOA,GAAQ,OAAUA,GAAQ,OAS/BV,EAAa,SAAoBU,GAKnC,OAAgB,QAATA,GACE,OAATA,GACS,OAATA,GACS,OAATA,GACS,OAATA,GACS,OAATA,GACS,OAATA,GAIF,SAASC,EAAQC,EAAQC,GACvB,IAAItC,EAAO1C,OAAO0C,KAAKqC,GAEvB,GAAI/E,OAAO6C,sBAAuB,CAChC,IAAIoC,EAAUjF,OAAO6C,sBAAsBkC,GACvCC,IAAgBC,EAAUA,EAAQC,QAAO,SAAUC,GACrD,OAAOnF,OAAOoF,yBAAyBL,EAAQI,GAAKjD,eAEtDQ,EAAK2C,KAAKC,MAAM5C,EAAMuC,GAGxB,OAAOvC,EAGT,SAAS6C,EAAc/C,GACrB,IAAK,IAAI7B,EAAI,EAAGA,EAAI6E,UAAU9E,OAAQC,IAAK,CACzC,IAAI2B,EAAyB,MAAhBkD,UAAU7E,GAAa6E,UAAU7E,GAAK,GAE/CA,EAAI,EACNmE,EAAQ9E,OAAOsC,IAAS,GAAMmD,SAAQ,SAAUzD,GAC9CF,EAAgBU,EAAQR,EAAKM,EAAON,OAE7BhC,OAAO0F,0BAChB1F,OAAO2F,iBAAiBnD,EAAQxC,OAAO0F,0BAA0BpD,IAEjEwC,EAAQ9E,OAAOsC,IAASmD,SAAQ,SAAUzD,GACxChC,OAAOiC,eAAeO,EAAQR,EAAKhC,OAAOoF,yBAAyB9C,EAAQN,OAKjF,OAAOQ,EAGT,IAAIoD,EAAS,CAIXC,MAAO,SAAeC,GACpB,IAAIC,EAAUP,UAAU9E,OAAS,QAAsBsF,IAAjBR,UAAU,GAAmBA,UAAU,GAAK,GAC9ES,EAAiBF,EAAQG,MACzBA,OAA2B,IAAnBD,GAAoCA,EAC5CE,EAAgBJ,EAAQK,KACxBA,OAAyB,IAAlBD,EAA2B,SAAWA,EAC7CE,EAAcN,EAAQO,GACtBA,OAAqB,IAAhBD,EAAyBP,EAAOS,UAAYF,EACjDG,EAAQT,EAAQS,MAEpB,GAAKF,EAAL,CAIA,IASIG,EATAC,EAAOd,EAAOc,KAAKZ,EAAQQ,GAC3BK,EAAmB,WAATP,EAEVQ,EAAYvH,EAA2BuG,EAAOiB,OAAOf,EAAQ,CAC/DQ,GAAII,EACJR,MAAOA,EACPM,MAAOA,EACPG,QAASA,KAIX,IACE,IAAKC,EAAU/F,MAAO4F,EAAQG,EAAU7G,KAAKe,MAAO,CAClD,IAAIgG,EAAc,YAAeL,EAAM1F,MAAO,GAC1ChB,EAAI+G,EAAY,GAChBC,EAAID,EAAY,GAEpB,IAAKE,EAAKC,OAAOlH,KAAOmH,EAAKC,OAAOT,EAAMK,GACxC,MAAO,CAAChH,EAAGgH,IAGf,MAAO3F,GACPwF,EAAU5F,EAAEI,GACZ,QACAwF,EAAU1F,OAUdkG,QAAS,SAAiBtB,EAAQ9D,EAAKjB,GACrC+E,EAAOsB,QAAQpF,EAAKjB,IAMtBsG,MAAO,SAAevB,EAAQQ,GAC5B,IAYI9D,EAKA8E,EAjBAvB,EAAUP,UAAU9E,OAAS,QAAsBsF,IAAjBR,UAAU,GAAmBA,UAAU,GAAK,GAC9E+B,EAAS3B,EAAO4B,MAAM1B,EAAQQ,EAAI,CACpCmB,KAAM,QAEJC,EAAQ9B,EAAO+B,IAAI7B,EAAQ,IAC3B8B,EAAQ,CACVL,OAAQA,EACRG,MAAOA,GAELG,EAAoB9B,EAAQ+B,SAC5BA,OAAiC,IAAtBD,EAA+B,EAAIA,EAC9CE,EAAI,EAGJC,EAAa3I,EAA2BuG,EAAOqC,UAAUnC,EAAQP,EAAc,GAAIQ,EAAS,CAC9FO,GAAIsB,MAIN,IACE,IAAKI,EAAWnH,MAAOyG,EAASU,EAAWjI,KAAKe,MAAO,CACrD,IAAIiG,EAAIO,EAAOvG,MAEf,GAAIgH,EAAID,EACN,MAGQ,IAANC,IACFvF,EAASuE,GAGXgB,KAEF,MAAO3G,GACP4G,EAAWhH,EAAEI,GACb,QACA4G,EAAW9G,IAGb,OAAOsB,GAMT0F,OAAQ,SAAgBpC,EAAQQ,GAC9B,IAYI9D,EAMA2F,EAlBApC,EAAUP,UAAU9E,OAAS,QAAsBsF,IAAjBR,UAAU,GAAmBA,UAAU,GAAK,GAC9E+B,EAAS3B,EAAOwC,MAAMtC,EAAQ,IAC9B4B,EAAQ9B,EAAO4B,MAAM1B,EAAQQ,EAAI,CACnCmB,KAAM,UAEJG,EAAQ,CACVL,OAAQA,EACRG,MAAOA,GAELW,EAAqBtC,EAAQ+B,SAC7BA,OAAkC,IAAvBO,EAAgC,EAAIA,EAC/CN,EAAI,EAGJO,EAAajJ,EAA2BuG,EAAOqC,UAAUnC,EAAQP,EAAc,GAAIQ,EAAS,CAC9FO,GAAIsB,EACJjB,SAAS,MAIX,IACE,IAAK2B,EAAWzH,MAAOsH,EAASG,EAAWvI,KAAKe,MAAO,CACrD,IAAIiG,EAAIoB,EAAOpH,MAEf,GAAIgH,EAAID,EACN,MAGQ,IAANC,IACFvF,EAASuE,GAGXgB,KAEF,MAAO3G,GACPkH,EAAWtH,EAAEI,GACb,QACAkH,EAAWpH,IAGb,OAAOsB,GAMT+F,eAAgB,SAAwBzC,GACtC,IAAIC,EAAUP,UAAU9E,OAAS,QAAsBsF,IAAjBR,UAAU,GAAmBA,UAAU,GAAK,GAC9EgD,EAAgBzC,EAAQ0C,KACxBA,OAAyB,IAAlBD,EAA2B,YAAcA,EACpD1C,EAAOyC,eAAeE,IAMxBC,cAAe,SAAuB5C,GACpC,IAAIC,EAAUP,UAAU9E,OAAS,QAAsBsF,IAAjBR,UAAU,GAAmBA,UAAU,GAAK,GAC9EmD,EAAiB5C,EAAQ0C,KACzBA,OAA0B,IAAnBE,EAA4B,YAAcA,EACrD7C,EAAO4C,cAAcD,IAMvBG,eAAgB,SAAwB9C,GACtCA,EAAO8C,kBAMTC,MAAO,SAAe/C,EAAQQ,GAC5B,MAAO,CAACV,EAAOwC,MAAMtC,EAAQQ,GAAKV,EAAO+B,IAAI7B,EAAQQ,KAMvDqB,IAAK,SAAa7B,EAAQQ,GACxB,OAAOV,EAAO4B,MAAM1B,EAAQQ,EAAI,CAC9BmB,KAAM,SAOVqB,MAAO,SAAehD,EAAQQ,GAC5B,IAAII,EAAOd,EAAOc,KAAKZ,EAAQQ,EAAI,CACjCmB,KAAM,UAER,OAAO7B,EAAOmD,KAAKjD,EAAQY,IAM7BsC,SAAU,SAAkBlD,EAAQQ,GAClC,IAAIsB,EAAQhC,EAAOgC,MAAM9B,EAAQQ,GAC7B0C,EAAWC,EAAKD,SAASlD,EAAQ8B,GACrC,OAAOoB,GAMTE,UAAW,SAAmBpD,EAAQqD,GACpC,OAAOA,EAAQC,SAASC,MAAK,SAAUtJ,GACrC,OAAO6F,EAAO0D,QAAQxD,EAAQ/F,OAOlCwJ,WAAY,SAAoBzD,EAAQqD,GACtC,OAAOA,EAAQC,SAASC,MAAK,SAAUtJ,GACrC,OAAOiH,EAAKC,OAAOlH,IAAM6F,EAAO4D,SAAS1D,EAAQ/F,OAOrD0J,SAAU,SAAkB3D,EAAQqD,GAClC,OAAOA,EAAQC,SAASM,OAAM,SAAU3J,GACtC,OAAOiH,EAAKC,OAAOlH,OASvB4J,YAAa,SAAqB7D,GAChCA,EAAO6D,eAQTC,eAAgB,SAAwB9D,EAAQkD,GAC9ClD,EAAO8D,eAAeZ,IAQxBa,WAAY,SAAoB/D,EAAQiD,GACtCjD,EAAO+D,WAAWd,IAQpBe,WAAY,SAAoBhE,EAAQnC,GACtCmC,EAAOgE,WAAWnG,IAMpB2F,QAAS,SAAiBxD,EAAQ/E,GAChC,OAAOgJ,EAAQC,UAAUjJ,KAAW+E,EAAO0D,SAASzI,IAMtDkJ,SAAU,SAAkBlJ,GAC1B,OAAO,YAAcA,IAAmC,mBAAlBA,EAAMqG,SAAiD,mBAAhBrG,EAAMuE,OAAwD,mBAAzBvE,EAAMwH,gBAAgE,mBAAxBxH,EAAM2H,eAAgE,mBAAzB3H,EAAM6H,gBAA8D,mBAAtB7H,EAAM4I,aAA8D,mBAAzB5I,EAAM6I,gBAA6D,mBAArB7I,EAAM8I,YAAyD,mBAArB9I,EAAM+I,YAAuD,mBAAnB/I,EAAMyI,UAAmD,mBAAjBzI,EAAMmJ,QAAwD,mBAAxBnJ,EAAMoJ,eAA0D,mBAAnBpJ,EAAMqJ,UAAuD,mBAArBrJ,EAAMsJ,aAA8C,OAAhBtJ,EAAMuJ,OAAkB,YAAcvJ,EAAMuJ,UAAgC,OAApBvJ,EAAMwF,WAAsBgE,EAAMC,QAAQzJ,EAAMwF,aAAe0C,EAAKwB,WAAW1J,EAAMqI,WAAasB,EAAUC,gBAAgB5J,EAAM6J,aAM3yBC,MAAO,SAAe/E,EAAQ0B,EAAOlB,GACnC,IAAIqB,EAAM/B,EAAO+B,IAAI7B,EAAQQ,GAC7B,OAAOwE,EAAM3D,OAAOK,EAAOG,IAM7BoD,OAAQ,SAAgBjF,EAAQ0B,EAAOlB,GACrC,OAAOV,EAAOoF,QAAQlF,EAAQ0B,EAAOlB,IAAOV,EAAOiF,MAAM/E,EAAQ0B,EAAOlB,IAM1E2E,QAAS,SAAiBnF,EAAQqD,GAChC,IAAIC,EAAWD,EAAQC,SAGnBN,EADY,YAAeM,EAAU,GACnB,GAEtB,OAA2B,IAApBA,EAAS1I,QAAoC,IAApB0I,EAAS1I,QAAgBsG,EAAKC,OAAO6B,IAAyB,KAAfA,EAAMnF,OAAgBmC,EAAOoE,OAAOf,IAMrHK,SAAU,SAAkB1D,EAAQ/E,GAClC,OAAOgJ,EAAQC,UAAUjJ,IAAU+E,EAAO0D,SAASzI,IAMrDmK,cAAe,SAAuBpF,GACpC,IAAIoF,EAAgB/H,EAAYgI,IAAIrF,GACpC,YAAyBE,IAAlBkF,GAAqCA,GAM9CF,QAAS,SAAiBlF,EAAQ0B,EAAOlB,GAEvC,GAAqB,IAAjBkB,EAAM5D,OACR,OAAO,EAGT,IAAIwE,EAAQxC,EAAOwC,MAAMtC,EAAQQ,GACjC,OAAOwE,EAAM3D,OAAOK,EAAOY,IAM7B8B,OAAQ,SAAgBpE,EAAQ/E,GAC9B,OAAOgJ,EAAQC,UAAUjJ,IAAU+E,EAAOoE,OAAOnJ,IAMnDqK,KAAM,SAActF,EAAQQ,GAC1B,IAAII,EAAOd,EAAOc,KAAKZ,EAAQQ,EAAI,CACjCmB,KAAM,QAER,OAAO7B,EAAOmD,KAAKjD,EAAQY,IAM7B2E,KAAM,SAAcvF,EAAQQ,GAC1B,IAAIP,EAAUP,UAAU9E,OAAS,QAAsBsF,IAAjBR,UAAU,GAAmBA,UAAU,GAAK,GAC9EkB,EAAOd,EAAOc,KAAKZ,EAAQQ,EAAIP,GAC/BgD,EAAOE,EAAKoC,KAAKvF,EAAQY,GAC7B,MAAO,CAACqC,EAAMrC,IAMhBG,OAAqB,IAAoByE,MAAK,SAAgBxF,GAC5D,IAAIC,EACAwF,EACAjF,EACAkF,EACA7E,EACA8E,EACAvF,EACAM,EACAK,EACAH,EACAgF,EACAC,EACAC,EACA7L,EACAgH,EACA8E,EAAQrG,UAEZ,OAAO,IAAoBsG,MAAK,SAAiBC,GAC/C,OACE,OAAQA,EAASlI,KAAOkI,EAASvK,MAC/B,KAAK,EAWH,GAVAuE,EAAU8F,EAAMnL,OAAS,QAAkBsF,IAAb6F,EAAM,GAAmBA,EAAM,GAAK,GAClEN,EAAexF,EAAQO,GAAIA,OAAsB,IAAjBiF,EAA0BzF,EAAOS,UAAYgF,EAAcC,EAAmBzF,EAAQY,QAASA,OAA+B,IAArB6E,GAAsCA,EAAkBC,EAAkB1F,EAAQG,MAAOA,OAA4B,IAApBuF,GAAqCA,EAGlQ,OAFbjF,EAAQT,EAAQS,SAGdA,EAAQ,WACN,OAAO,IAIPF,EAAI,CACNyF,EAASvK,KAAO,EAChB,MAGF,OAAOuK,EAASC,OAAO,UAEzB,KAAK,EACHnF,EAAS,GACTH,EAAOd,EAAOc,KAAKZ,EAAQQ,GAC3BoF,EAAarM,EAA2B4J,EAAKpC,OAAOf,EAAQY,IAC5DqF,EAASlI,KAAO,EAEhB6H,EAAW7K,IAEb,KAAK,GACH,IAAK8K,EAASD,EAAW3L,KAAKe,KAAM,CAClCiL,EAASvK,KAAO,GAChB,MAKF,GAFAoK,EAAe,YAAeD,EAAO5K,MAAO,GAAIhB,EAAI6L,EAAa,GAAI7E,EAAI6E,EAAa,GAElFpF,EAAMzG,GAAI,CACZgM,EAASvK,KAAO,GAChB,MAGF,OAAOuK,EAASC,OAAO,WAAY,IAErC,KAAK,GAGH,GAFAnF,EAAOxB,KAAK,CAACtF,EAAGgH,IAETb,IAASN,EAAOsE,OAAOpE,EAAQ/F,GAAK,CACzCgM,EAASvK,KAAO,GAChB,MAGF,OAAOuK,EAASC,OAAO,QAAS,IAElC,KAAK,GACHD,EAASvK,KAAO,GAChB,MAEF,KAAK,GACHuK,EAASvK,KAAO,GAChB,MAEF,KAAK,GACHuK,EAASlI,KAAO,GAChBkI,EAASE,GAAKF,EAAgB,MAAE,GAEhCL,EAAW1K,EAAE+K,EAASE,IAExB,KAAK,GAKH,OAJAF,EAASlI,KAAO,GAEhB6H,EAAWxK,IAEJ6K,EAASG,OAAO,IAEzB,KAAK,GAKH,OAJIvF,GACFE,EAAOF,UAGFoF,EAASI,cAActF,EAAQ,KAAM,IAE9C,KAAK,GACL,IAAK,MACH,OAAOkF,EAASK,UAGrBvF,EAAQ,KAAM,CAAC,CAAC,EAAG,GAAI,GAAI,SAMhCyD,MAAO,SAAexE,GACpB,IAAIwE,EAAQxE,EAAOwE,MACf/D,EAAYT,EAAOS,UAEvB,IAAKA,EACH,OAAO,KAGT,GAAI+D,EACF,OAAOA,EAGT,GAAIC,EAAM8B,WAAW9F,GAAY,CAC/B,IAAI+F,EAAgB1G,EAAO2G,MAAMzG,EAAQ,CACvCU,MAAOQ,EAAKC,SAGVT,EADiB,YAAe8F,EAAe,GACxB,GAE3B,OAAI9F,EAIUnE,EAHC,YAAemE,EAAO,GAChB,GAEyB,CAAC,SAItC,GAIX,IAAIe,EAAShB,EAAUgB,OACnBb,EAAOa,EAAOb,KAEd8F,EAAe5G,EAAOyF,KAAKvF,EAAQY,GAEnCqC,EADgB,YAAeyD,EAAc,GACxB,GAEzB,GAAsB,IAAlBjF,EAAO3D,OAAc,CACvB,IAAIC,EAAO+B,EAAO6G,SAAS3G,EAAQ,CACjCQ,GAAII,EACJF,MAAOQ,EAAKC,SAEVyF,EAAQ9G,EAAOC,MAAMC,EAAQ,CAC/BU,MAAO,SAAezG,GACpB,OAAO6F,EAAO0D,QAAQxD,EAAQ/F,MAIlC,GAAI8D,GAAQ6I,EAAO,CACjB,IAAIC,EAAS,YAAe9I,EAAM,GAC9B+I,EAAWD,EAAO,GAClBE,EAAWF,EAAO,GAGlBG,EADS,YAAeJ,EAAO,GACZ,GAEnBxF,EAAK6F,WAAWD,EAAWD,KAC7B9D,EAAO6D,IAOb,OAFWvK,EAAyB0G,EAAM,CAAC,UAQ7CvH,KAAM,SAAcsE,GAClB,IAAIC,EAAUP,UAAU9E,OAAS,QAAsBsF,IAAjBR,UAAU,GAAmBA,UAAU,GAAK,GAC9EwH,EAAiBjH,EAAQK,KACzBA,OAA0B,IAAnB4G,EAA4B,SAAWA,EAC9CC,EAAkBlH,EAAQG,MAC1BA,OAA4B,IAApB+G,GAAqCA,EAC7CzG,EAAQT,EAAQS,MAChB0G,EAAenH,EAAQO,GACvBA,OAAsB,IAAjB4G,EAA0BpH,EAAOS,UAAY2G,EAEtD,GAAK5G,EAAL,CAIA,IAAI6G,EAAevH,EAAOwF,KAAKtF,EAAQQ,GACnC8G,EAAgB,YAAeD,EAAc,GAC7C5M,EAAO6M,EAAc,GAErBC,EAAgBzH,EAAOwF,KAAKtF,EAAQ,IACpCwH,EAAgB,YAAeD,EAAe,GAC9CE,EAAKD,EAAc,GAEnBE,EAAO,CAACjN,EAAMgN,GAElB,GAAIrG,EAAKuG,OAAOnH,IAAqB,IAAdA,EAAG5F,OACxB,MAAM,IAAIgN,MAAM,gDAGlB,GAAa,MAATlH,EACF,GAAIU,EAAKuG,OAAOnH,GAAK,CACnB,IAAIqH,EAAiB/H,EAAOgI,OAAO9H,EAAQQ,GACvCuH,EAAkB,YAAeF,EAAgB,GACjDC,EAASC,EAAgB,GAE7BrH,EAAQ,SAAezG,GACrB,OAAO6N,EAAOxE,SAAS0E,SAAS/N,SAGlCyG,EAAQ,WACN,OAAO,GAKb,IAAIuH,EAAiBnI,EAAO2G,MAAMzG,EAAQ,CACxCQ,GAAIkH,EACJhH,MAAOA,EACPJ,KAAMA,EACNF,MAAOA,IAEL8H,EAAiB,YAAeD,EAAgB,GAChDvM,EAAOwM,EAAe,GAE1B,OAAOxM,IAMTuH,KAAM,SAAcjD,EAAQQ,GAC1B,IAAIP,EAAUP,UAAU9E,OAAS,QAAsBsF,IAAjBR,UAAU,GAAmBA,UAAU,GAAK,GAC9EkB,EAAOd,EAAOc,KAAKZ,EAAQQ,EAAIP,GAC/BgD,EAAOE,EAAKkC,IAAIrF,EAAQY,GAC5B,MAAO,CAACqC,EAAMrC,IAMhB6F,MAAoB,IAAoBjB,MAAK,SAASiB,EAAMzG,GAC1D,IAAIC,EACAkI,EACA3H,EACA4H,EACA9H,EACA+H,EACAC,EACAC,EACA1H,EACA2H,EACApI,EACAM,EACAjG,EACAgN,EACAzE,EACAsC,EACAmD,EACAC,EACAC,EACAC,EACAC,EACAC,EACA7F,EACArC,EACAmI,EACAC,EACAC,EAASvJ,UAEb,OAAO,IAAoBsG,MAAK,SAAgBkD,GAC9C,OACE,OAAQA,EAAUnL,KAAOmL,EAAUxN,MACjC,KAAK,EAWH,GAVAuE,EAAUgJ,EAAOrO,OAAS,QAAmBsF,IAAd+I,EAAO,GAAmBA,EAAO,GAAK,GACrEd,EAAelI,EAAQO,GAAIA,OAAsB,IAAjB2H,EAA0BnI,EAAOS,UAAY0H,EAAcC,EAAiBnI,EAAQK,KAAMA,OAA0B,IAAnB8H,EAA4B,MAAQA,EAAgBC,EAAqBpI,EAAQqI,UAAWA,OAAmC,IAAvBD,GAAwCA,EAAoBE,EAAoBtI,EAAQY,QAASA,OAAgC,IAAtB0H,GAAuCA,EAAmBC,EAAkBvI,EAAQG,MAAOA,OAA4B,IAApBoI,GAAqCA,GAC5d9H,EAAQT,EAAQS,SAGdA,EAAQ,WACN,OAAO,IAIPF,EAAI,CACN0I,EAAUxN,KAAO,EACjB,MAGF,OAAOwN,EAAUhD,OAAO,UAE1B,KAAK,EACCiD,EAAKC,OAAO5I,IACd/F,EAAO+F,EAAG,GACViH,EAAKjH,EAAG,KAERwC,EAAQlD,EAAOc,KAAKZ,EAAQQ,EAAI,CAC9BmB,KAAM,UAER2D,EAAOxF,EAAOc,KAAKZ,EAAQQ,EAAI,CAC7BmB,KAAM,QAERlH,EAAOoG,EAAUyE,EAAOtC,EACxByE,EAAK5G,EAAUmC,EAAQsC,GAGzBmD,EAActF,EAAKsD,MAAMzG,EAAQ,CAC/Ba,QAASA,EACTpG,KAAMA,EACNgN,GAAIA,EACJ4B,KAAM,SAAcC,GAClB,IACIrP,EADQ,YAAeqP,EAAM,GACnB,GAEd,OAAOlJ,GAAgBN,EAAOsE,OAAOpE,EAAQ/F,MAGjDyO,EAAU,GACVE,EAAarP,EAA2BkP,GACxCS,EAAUnL,KAAO,GAEjB6K,EAAW7N,IAEb,KAAK,GACH,IAAK8N,EAASD,EAAW3O,KAAKe,KAAM,CAClCkO,EAAUxN,KAAO,GACjB,MAMF,GAHAoN,EAAe,YAAeD,EAAO5N,MAAO,GAAIgI,EAAO6F,EAAa,GAAIlI,EAAOkI,EAAa,GAC5FC,EAAUJ,GAAsC,IAA/BvH,EAAKmI,QAAQ3I,EAAM+H,EAAI,IAEzB,YAATrI,IAAsByI,EAAU,CACpCG,EAAUxN,KAAO,GACjB,MAGF,OAAOwN,EAAUhD,OAAO,WAAY,IAEtC,KAAK,GACH,GAAIxF,EAAMuC,GAAO,CACfiG,EAAUxN,KAAO,GACjB,MAGF,IAAM4M,GAAcS,IAAW7H,EAAKC,OAAO8B,GAAQ,CACjDiG,EAAUxN,KAAO,GACjB,MAGF,OAAOwN,EAAUhD,OAAO,UAE1B,KAAK,GACH,OAAOgD,EAAUhD,OAAO,WAAY,IAEtC,KAAK,GACH,GAAe,WAAT5F,IAAqByI,EAAU,CACnCG,EAAUxN,KAAO,GACjB,MAIF,OADAiN,EAAM,CAAC1F,EAAMrC,GACNsI,EAAUhD,OAAO,WAAY,IAEtC,KAAK,GAIH,KAFA8C,EAAgB,WAAT1I,EAAoBqI,EAAM,CAAC1F,EAAMrC,IAE7B,CACTsI,EAAUxN,KAAO,GACjB,MAGF,IAAK4M,EAAW,CACdY,EAAUxN,KAAO,GACjB,MAGFgN,EAAQnJ,KAAKyJ,GACbE,EAAUxN,KAAO,GACjB,MAEF,KAAK,GAEH,OADAwN,EAAUxN,KAAO,GACVsN,EAET,KAAK,GACHL,EAAM,CAAC1F,EAAMrC,GAEf,KAAK,GACHsI,EAAUxN,KAAO,GACjB,MAEF,KAAK,GACHwN,EAAUxN,KAAO,GACjB,MAEF,KAAK,GACHwN,EAAUnL,KAAO,GACjBmL,EAAU/C,GAAK+C,EAAiB,MAAE,IAElCN,EAAW1N,EAAEgO,EAAU/C,IAEzB,KAAK,GAKH,OAJA+C,EAAUnL,KAAO,GAEjB6K,EAAWxN,IAEJ8N,EAAU9C,OAAO,IAE1B,KAAK,GACH,GAAe,WAAT9F,IAAqBqI,EAAM,CAC/BO,EAAUxN,KAAO,GACjB,MAGF,IAAK4M,EAAW,CACdY,EAAUxN,KAAO,GACjB,MAGFgN,EAAQnJ,KAAKoJ,GACbO,EAAUxN,KAAO,GACjB,MAEF,KAAK,GAEH,OADAwN,EAAUxN,KAAO,GACViN,EAET,KAAK,GACH,IAAKL,EAAW,CACdY,EAAUxN,KAAO,GACjB,MAGF,OAAOwN,EAAU7C,cAAcqC,EAAS,KAAM,IAEhD,KAAK,GACL,IAAK,MACH,OAAOQ,EAAU5C,UAGtBG,EAAO,KAAM,CAAC,CAAC,GAAI,GAAI,GAAI,SAMhC+C,UAAW,SAAmBxJ,GAC5B,IAAIC,EAAUP,UAAU9E,OAAS,QAAsBsF,IAAjBR,UAAU,GAAmBA,UAAU,GAAK,GAC9E+J,EAAiBxJ,EAAQyJ,MACzBA,OAA2B,IAAnBD,GAAoCA,EAE5CE,EAAgB,SAAuB3J,GACzC,OAAO9C,EAAYmI,IAAIrF,IAAW,IAGpC,GAAKF,EAAOsF,cAAcpF,GAA1B,CAIA,GAAI0J,EAAO,CACT,IAAIE,EAAW/P,MAAMY,KAAK0I,EAAKsD,MAAMzG,IAAS,SAAU6J,GAItD,OAHY,YAAeA,EAAO,GACpB,MAIhB3M,EAAY4M,IAAI9J,EAAQ4J,GAGW,IAAjCD,EAAc3J,GAAQpF,QAI1BkF,EAAOiK,mBAAmB/J,GAAQ,WAKhC,IAJA,IAAIgK,EAAqC,GAA/BL,EAAc3J,GAAQpF,OAE5BqP,EAAI,EAEgC,IAAjCN,EAAc3J,GAAQpF,QAAc,CACzC,GAAIqP,EAAID,EACN,MAAM,IAAIpC,MAAM,iEAAiEsC,OAAOF,EAAK,0HAG/F,IAAIpJ,EAAO+I,EAAc3J,GAAQmK,MAC7BC,EAAQtK,EAAOmD,KAAKjD,EAAQY,GAChCZ,EAAOqE,cAAc+F,GACrBH,UAQNnC,OAAQ,SAAgB9H,EAAQQ,GAC9B,IAAIP,EAAUP,UAAU9E,OAAS,QAAsBsF,IAAjBR,UAAU,GAAmBA,UAAU,GAAK,GAC9EkB,EAAOd,EAAOc,KAAKZ,EAAQQ,EAAIP,GAC/BoK,EAAajJ,EAAK0G,OAAOlH,GACzBwJ,EAAQtK,EAAOmD,KAAKjD,EAAQqK,GAChC,OAAOD,GAMTxJ,KAAM,SAAcZ,EAAQQ,GAC1B,IAAIP,EAAUP,UAAU9E,OAAS,QAAsBsF,IAAjBR,UAAU,GAAmBA,UAAU,GAAK,GAC9E4K,EAAQrK,EAAQqK,MAChB3I,EAAO1B,EAAQ0B,KAEnB,GAAIP,EAAKuG,OAAOnH,GACd,GAAa,UAATmB,EAAkB,CACpB,IAAI4I,EAAcpH,EAAKH,MAAMhD,EAAQQ,GACjCgK,EAAe,YAAeD,EAAa,GAC3CE,EAAYD,EAAa,GAE7BhK,EAAKiK,OACA,GAAa,QAAT9I,EAAgB,CACzB,IAAI+I,EAAavH,EAAKmC,KAAKtF,EAAQQ,GAC/BmK,EAAc,YAAeD,EAAY,GACzCE,EAAWD,EAAY,GAE3BnK,EAAKoK,EAsBT,OAlBInG,EAAMC,QAAQlE,KAEdA,EADW,UAATmB,EACG8C,EAAMnC,MAAM9B,GACC,QAATmB,EACJ8C,EAAM5C,IAAIrB,GAEVY,EAAKyJ,OAAOrK,EAAGiB,OAAOb,KAAMJ,EAAGoB,MAAMhB,OAI1CoE,EAAM8F,QAAQtK,KAChBA,EAAKA,EAAGI,MAGG,MAAT0J,IACF9J,EAAKA,EAAGlG,MAAM,EAAGgQ,IAGZ9J,GAOTuK,QAAS,SAAiB/K,EAAQY,GAChC,IAAIX,EAAUP,UAAU9E,OAAS,QAAsBsF,IAAjBR,UAAU,GAAmBA,UAAU,GAAK,GAC9EsL,EAAoB/K,EAAQgL,SAC5BA,OAAiC,IAAtBD,EAA+B,UAAYA,EACtDE,EAAM,CACRC,QAASvK,EACTqK,SAAUA,EACVG,MAAO,WACL,IAAID,EAAUD,EAAIC,QAIlB,OAHerL,EAAOuL,SAASrL,GACtBsL,OAAOJ,GAChBA,EAAIC,QAAU,KACPA,IAGPI,EAAOzL,EAAOuL,SAASrL,GAE3B,OADAuL,EAAKC,IAAIN,GACFA,GAMTG,SAAU,SAAkBrL,GAC1B,IAAIuL,EAAOjO,EAAU+H,IAAIrF,GAOzB,OALKuL,IACHA,EAAO,IAAIE,IACXnO,EAAUwM,IAAI9J,EAAQuL,IAGjBA,GAMT7J,MAAO,SAAe1B,EAAQQ,GAC5B,IAAIP,EAAUP,UAAU9E,OAAS,QAAsBsF,IAAjBR,UAAU,GAAmBA,UAAU,GAAK,GAC9EgM,EAAgBzL,EAAQ0B,KACxBA,OAAyB,IAAlB+J,EAA2B,QAAUA,EAEhD,GAAItK,EAAKuG,OAAOnH,GAAK,CACnB,IAAII,EAEJ,GAAa,QAATe,EAAgB,CAClB,IAAIgK,EAAcxI,EAAKmC,KAAKtF,EAAQQ,GAChCoL,EAAc,YAAeD,EAAa,GAC1Cf,EAAWgB,EAAY,GAE3BhL,EAAOgK,MACF,CACL,IAAIiB,EAAe1I,EAAKH,MAAMhD,EAAQQ,GAClCsL,EAAe,YAAeD,EAAc,GAC5CpB,EAAYqB,EAAa,GAE7BlL,EAAO6J,EAGT,IAAIxH,EAAOE,EAAKkC,IAAIrF,EAAQY,GAE5B,IAAKM,EAAKC,OAAO8B,GACf,MAAM,IAAI2E,MAAM,kBAAkBsC,OAAOvI,EAAM,gCAAgCuI,OAAO1J,EAAI,wBAAwB0J,OAAOvI,EAAM,gBAGjI,MAAO,CACLf,KAAMA,EACN9C,OAAiB,QAAT6D,EAAiBsB,EAAKpF,KAAKjD,OAAS,GAIhD,GAAI6J,EAAMC,QAAQlE,GAAK,CACrB,IAAIuL,EAAetH,EAAM1B,MAAMvC,GAC3BwL,EAAgB,YAAeD,EAAc,GAC7CzJ,EAAQ0J,EAAc,GACtBnK,EAAMmK,EAAc,GAExB,MAAgB,UAATrK,EAAmBW,EAAQT,EAGpC,OAAOrB,GAOTyL,SAAU,SAAkBjM,EAAQ0B,GAClC,IAAIzB,EAAUP,UAAU9E,OAAS,QAAsBsF,IAAjBR,UAAU,GAAmBA,UAAU,GAAK,GAC9EwM,EAAqBjM,EAAQgL,SAC7BA,OAAkC,IAAvBiB,EAAgC,UAAYA,EACvDhB,EAAM,CACRC,QAASzJ,EACTuJ,SAAUA,EACVG,MAAO,WACL,IAAID,EAAUD,EAAIC,QAIlB,OAHgBrL,EAAOqM,UAAUnM,GACvBsL,OAAOJ,GACjBA,EAAIC,QAAU,KACPA,IAGPI,EAAOzL,EAAOqM,UAAUnM,GAE5B,OADAuL,EAAKC,IAAIN,GACFA,GAMTiB,UAAW,SAAmBnM,GAC5B,IAAIuL,EAAOhO,EAAW8H,IAAIrF,GAO1B,OALKuL,IACHA,EAAO,IAAIE,IACXlO,EAAWuM,IAAI9J,EAAQuL,IAGlBA,GAcTpJ,UAAwB,IAAoBqD,MAAK,SAASrD,EAAUnC,GAClE,IAAIC,EACAmM,EACA5L,EACA6L,EACA1J,EACA2J,EACAC,EACAzK,EACA0K,EACAC,EACAnK,EACAT,EACAmB,EACA0J,EACAC,EACA7O,EACAkE,EACA4K,EACAC,EACAC,EACAC,EACAC,EACA/J,EACArC,EACA1F,EACAH,EACA8C,EACAoP,EACAC,EAASxN,UAEb,OAAO,IAAoBsG,MAAK,SAAoBmH,GAClD,OACE,OAAQA,EAAUpP,KAAOoP,EAAUzR,MACjC,KAAK,EAIH,GAHAuE,EAAUiN,EAAOtS,OAAS,QAAmBsF,IAAdgN,EAAO,GAAmBA,EAAO,GAAK,GACrEd,EAAenM,EAAQO,GAAIA,OAAsB,IAAjB4L,EAA0BpM,EAAOS,UAAY2L,EAAcC,EAAiBpM,EAAQ0C,KAAMA,OAA0B,IAAnB0J,EAA4B,SAAWA,EAAgBC,EAAoBrM,EAAQY,QAAS0L,OAAkC,IAAtBD,GAAuCA,EAE5Q9L,EAAI,CACN2M,EAAUzR,KAAO,EACjB,MAGF,OAAOyR,EAAUjH,OAAO,UAE1B,KAAK,EACHpE,EAAQhC,EAAOgC,MAAM9B,EAAQQ,GAC7BgM,EAAgB/H,EAAM1B,MAAMjB,GAAQ2K,EAAgB,YAAeD,EAAe,GAAIlK,EAAQmK,EAAc,GAAI5K,EAAM4K,EAAc,GACpIzJ,EAAQuJ,EAAY1K,EAAMS,EAC1BoK,EAAS,GACTC,EAAY,EACZ7O,EAAS,EACTkE,EAAW,KACX4K,GAAa,EAEbC,EAAU,WACQ,MAAZ7K,IAEAA,EADW,cAATW,EACS/E,EAAqB8O,GACd,SAAT/J,EACEpE,EAAgBmO,GACT,SAAT/J,GAA4B,UAATA,EACjB+J,EAAO9R,OAEP,EAGb8R,EAASA,EAAOpS,MAAM0H,IAIxBlE,EAASyO,EAAYzO,EAASkE,EAAWlE,EAASkE,EAKlDA,GAHA2K,GAAwB3K,IAGA,EAAI,KAAO,EAAI2K,GAGzCG,EAAavT,EAA2BuG,EAAO2G,MAAMzG,EAAQ,CAC3DQ,GAAIA,EACJK,QAAS0L,KAEXY,EAAUpP,KAAO,GAEjB+O,EAAW/R,IAEb,KAAK,GACH,IAAKgS,EAASD,EAAW7S,KAAKe,KAAM,CAClCmS,EAAUzR,KAAO,GACjB,MAKF,GAFAsR,EAAe,YAAeD,EAAO9R,MAAO,GAAIgI,EAAO+J,EAAa,GAAIpM,EAAOoM,EAAa,IAEvF/I,EAAQC,UAAUjB,GAAO,CAC5BkK,EAAUzR,KAAO,GACjB,MAGF,IAAKsE,EAAOoE,OAAOnB,GAAO,CACxBkK,EAAUzR,KAAO,GACjB,MAIF,OADAyR,EAAUzR,KAAO,GACVoE,EAAOwC,MAAMtC,EAAQY,GAE9B,KAAK,GACH,OAAOuM,EAAUjH,OAAO,WAAY,IAEtC,KAAK,GACH,IAAKlG,EAAO0D,SAAST,GAAO,CAC1BkK,EAAUzR,KAAO,GACjB,MAGF,OAAOyR,EAAUjH,OAAO,WAAY,IAEtC,KAAK,GACCpG,EAAO2D,WAAWzD,EAAQiD,KAC5B/H,EAAIkG,EAAK6F,WAAWrG,EAAMiB,EAAIjB,MAAQiB,EAAM/B,EAAO+B,IAAI7B,EAAQY,GAC/D7F,EAAIqG,EAAK6F,WAAWrG,EAAM0B,EAAM1B,MAAQ0B,EAAQxC,EAAOwC,MAAMtC,EAAQY,GACrE/C,EAAOiC,EAAO4M,OAAO1M,EAAQ,CAC3ByB,OAAQ1G,EACR6G,MAAO1G,IAETwR,EAASH,EAAY,kBAAQ1O,GAAQA,EACrC+O,GAAa,GAGjB,KAAK,GACH,IAAK1L,EAAKC,OAAO8B,GAAO,CACtBkK,EAAUzR,KAAO,GACjB,MAYF,GATAuR,EAAU7L,EAAKC,OAAOT,EAAMoC,EAAMpC,MAClC+L,EAAY1J,EAAKpF,KAAKjD,OACtBkD,EAASyO,EAAYI,EAAY,EAE7BM,IACFN,EAAYJ,EAAYvJ,EAAMlF,OAAS6O,EAAY3J,EAAMlF,OACzDA,EAASkF,EAAMlF,SAGXmP,IAAWL,GAAuB,WAATjK,EAAoB,CACjDwK,EAAUzR,KAAO,GACjB,MAIF,OADAyR,EAAUzR,KAAO,GACV,CACLkF,KAAMA,EACN9C,OAAQA,GAGZ,KAAK,GAMH,GAAiB,KAAX4O,EAAgB,CACpBS,EAAUzR,KAAO,GACjB,MAGF,OAAOyR,EAAUjH,OAAO,QAAS,IAEnC,KAAK,GACH2G,IAEF,KAAK,GACH,KAAMF,GAAa,GAAI,CACrBQ,EAAUzR,KAAO,GACjB,MAIF,OADAyR,EAAUzR,KAAO,GACV,CACLkF,KAAMA,EACN9C,OAAQA,GAGZ,KAAK,GACHqP,EAAUzR,KAAO,GACjB,MAEF,KAAK,GACH,OAAOyR,EAAUjH,OAAO,QAAS,IAEnC,KAAK,GACHiH,EAAUzR,KAAO,GACjB,MAEF,KAAK,GACHkR,GAAa,EAEf,KAAK,GACHO,EAAUzR,KAAO,GACjB,MAEF,KAAK,GACHyR,EAAUzR,KAAO,GACjB,MAEF,KAAK,GACHyR,EAAUpP,KAAO,GACjBoP,EAAUhH,GAAKgH,EAAiB,MAAE,IAElCL,EAAW5R,EAAEiS,EAAUhH,IAEzB,KAAK,GAKH,OAJAgH,EAAUpP,KAAO,GAEjB+O,EAAW1R,IAEJ+R,EAAU/G,OAAO,IAE1B,KAAK,GACL,IAAK,MACH,OAAO+G,EAAU7G,UAGtBnE,EAAW,KAAM,CAAC,CAAC,GAAI,GAAI,GAAI,SAMpCwE,SAAU,SAAkB3G,GAC1B,IAAIC,EAAUP,UAAU9E,OAAS,QAAsBsF,IAAjBR,UAAU,GAAmBA,UAAU,GAAK,GAC9E0N,EAAiBnN,EAAQK,KACzBA,OAA0B,IAAnB8M,EAA4B,SAAWA,EAC9CC,EAAkBpN,EAAQG,MAC1BA,OAA4B,IAApBiN,GAAqCA,EAC7C3M,EAAQT,EAAQS,MAChB4M,EAAerN,EAAQO,GACvBA,OAAsB,IAAjB8M,EAA0BtN,EAAOS,UAAY6M,EAEtD,GAAK9M,EAAL,CAIA,IAAI+M,EAAgBzN,EAAOkD,MAAMhD,EAAQQ,GACrCgN,EAAiB,YAAeD,EAAe,GAC/C9S,EAAO+S,EAAe,GAEtBC,EAAiB3N,EAAOkD,MAAMhD,EAAQ,IACtC0N,EAAiB,YAAeD,EAAgB,GAChDhG,EAAKiG,EAAe,GAEpBhG,EAAO,CAACjN,EAAMgN,GAElB,GAAIrG,EAAKuG,OAAOnH,IAAqB,IAAdA,EAAG5F,OACxB,MAAM,IAAIgN,MAAM,oDAGlB,GAAa,MAATlH,EACF,GAAIU,EAAKuG,OAAOnH,GAAK,CACnB,IAAImN,EAAkB7N,EAAOgI,OAAO9H,EAAQQ,GACxCoN,EAAkB,YAAeD,EAAiB,GAClD7F,EAAS8F,EAAgB,GAE7BlN,EAAQ,SAAezG,GACrB,OAAO6N,EAAOxE,SAAS0E,SAAS/N,SAGlCyG,EAAQ,WACN,OAAO,GAKb,IAAImN,EAAiB/N,EAAO2G,MAAMzG,EAAQ,CACxCa,SAAS,EACTL,GAAIkH,EACJhH,MAAOA,EACPJ,KAAMA,EACNF,MAAOA,IAEL0N,EAAiB,YAAeD,EAAgB,GAChDlH,EAAWmH,EAAe,GAE9B,OAAOnH,IAMT7E,MAAO,SAAe9B,EAAQQ,EAAIiH,GAChC,OAAIhD,EAAMC,QAAQlE,KAAQiH,EACjBjH,EAKF,CACLiB,OAHU3B,EAAOwC,MAAMtC,EAAQQ,GAI/BoB,MAHQ9B,EAAO+B,IAAI7B,EAAQyH,GAAMjH,KAWrCuN,SAAU,SAAkB/N,EAAQ8B,GAClC,IAAI7B,EAAUP,UAAU9E,OAAS,QAAsBsF,IAAjBR,UAAU,GAAmBA,UAAU,GAAK,GAC9EsO,EAAqB/N,EAAQgL,SAC7BA,OAAkC,IAAvB+C,EAAgC,UAAYA,EACvD9C,EAAM,CACRC,QAASrJ,EACTmJ,SAAUA,EACVG,MAAO,WACL,IAAID,EAAUD,EAAIC,QAIlB,OAHgBrL,EAAOmO,UAAUjO,GACvBsL,OAAOJ,GACjBA,EAAIC,QAAU,KACPA,IAGPI,EAAOzL,EAAOmO,UAAUjO,GAE5B,OADAuL,EAAKC,IAAIN,GACFA,GAMT+C,UAAW,SAAmBjO,GAC5B,IAAIuL,EAAO/N,EAAW6H,IAAIrF,GAO1B,OALKuL,IACHA,EAAO,IAAIE,IACXjO,EAAWsM,IAAI9J,EAAQuL,IAGlBA,GAUThH,WAAY,SAAoBvE,EAAQ9D,GACtC8D,EAAOuE,WAAWrI,IAMpBoG,MAAO,SAAetC,EAAQQ,GAC5B,OAAOV,EAAO4B,MAAM1B,EAAQQ,EAAI,CAC9BmB,KAAM,WAUV+K,OAAQ,SAAgB1M,EAAQQ,GAC9B,IAaI0N,EAbApM,EAAQhC,EAAOgC,MAAM9B,EAAQQ,GAE7B2N,EAAgB1J,EAAM1B,MAAMjB,GAC5BsM,EAAgB,YAAeD,EAAe,GAC9C7L,EAAQ8L,EAAc,GACtBvM,EAAMuM,EAAc,GAEpBvQ,EAAO,GAEPwQ,EAAa9U,EAA2BuG,EAAO2G,MAAMzG,EAAQ,CAC/DQ,GAAIsB,EACJpB,MAAOQ,EAAKC,UAId,IACE,IAAKkN,EAAWtT,MAAOmT,EAASG,EAAWpU,KAAKe,MAAO,CACrD,IAAIsT,EAAe,YAAeJ,EAAOjT,MAAO,GAC5CgI,EAAOqL,EAAa,GACpB1N,EAAO0N,EAAa,GAEpBC,EAAItL,EAAKpF,KAETuD,EAAKC,OAAOT,EAAMiB,EAAIjB,QACxB2N,EAAIA,EAAEjU,MAAM,EAAGuH,EAAI/D,SAGjBsD,EAAKC,OAAOT,EAAM0B,EAAM1B,QAC1B2N,EAAIA,EAAEjU,MAAMgI,EAAMxE,SAGpBD,GAAQ0Q,GAEV,MAAOjT,GACP+S,EAAWnT,EAAEI,GACb,QACA+S,EAAWjT,IAGb,OAAOyC,GAMT2Q,YAAa,SAAqBxO,EAAQ8B,GACxC,IAAI7B,EAAUP,UAAU9E,OAAS,QAAsBsF,IAAjBR,UAAU,GAAmBA,UAAU,GAAK,GAC9E+O,EAAkBxO,EAAQG,MAC1BA,OAA4B,IAApBqO,GAAqCA,EAE7CC,EAAgBjK,EAAM1B,MAAMjB,GAC5B6M,EAAgB,YAAeD,EAAe,GAC9CpM,EAAQqM,EAAc,GACtB9M,EAAM8M,EAAc,GAGxB,GAAqB,IAAjBrM,EAAMxE,QAA+B,IAAf+D,EAAI/D,QAAgB2G,EAAMmK,YAAY9M,GAC9D,OAAOA,EAGT,IAoBI+M,EApBAC,EAAWhP,EAAOC,MAAMC,EAAQ,CAClCQ,GAAIqB,EACJnB,MAAO,SAAezG,GACpB,OAAO6F,EAAO0D,QAAQxD,EAAQ/F,MAG9B+M,EAAY8H,EAAWA,EAAS,GAAK,GACrC9L,EAAQlD,EAAOwC,MAAMtC,EAAQ,IAC7BoC,EAAS,CACXX,OAAQuB,EACRpB,MAAOC,GAELkN,GAAO,EAEPC,EAAazV,EAA2BuG,EAAO2G,MAAMzG,EAAQ,CAC/DQ,GAAI4B,EACJ1B,MAAOQ,EAAKC,OACZN,SAAS,EACTT,MAAOA,KAIT,IACE,IAAK4O,EAAWjU,MAAO8T,EAASG,EAAW/U,KAAKe,MAAO,CACrD,IAAIiU,EAAe,YAAeJ,EAAO5T,MAAO,GAC5CgI,EAAOgM,EAAa,GACpBrO,EAAOqO,EAAa,GAExB,GAAIF,EACFA,GAAO,OAIT,GAAkB,KAAd9L,EAAKpF,MAAeuD,EAAK8N,SAAStO,EAAMoG,GAAY,CACtDnF,EAAM,CACJjB,KAAMA,EACN9C,OAAQmF,EAAKpF,KAAKjD,QAEpB,QAGJ,MAAOU,GACP0T,EAAW9T,EAAEI,GACb,QACA0T,EAAW5T,IAGb,MAAO,CACLqG,OAAQa,EACRV,MAAOC,IAOXsN,KAAM,SAAenP,GACnB,IAAIC,EAAUP,UAAU9E,OAAS,QAAsBsF,IAAjBR,UAAU,GAAmBA,UAAU,GAAK,GAClF,OAAOI,EAAOC,MAAMC,EAAQP,EAAc,GAAIQ,EAAS,CACrDS,MAAO,SAAezG,GACpB,OAAO6F,EAAOsE,OAAOpE,EAAQ/F,QAQnC8P,mBAAoB,SAA4B/J,EAAQoP,GACtD,IAAInU,EAAQ6E,EAAOsF,cAAcpF,GACjC3C,EAAYyM,IAAI9J,GAAQ,GACxBoP,IACA/R,EAAYyM,IAAI9J,EAAQ/E,GACxB6E,EAAO0J,UAAUxJ,KAGjBiE,EAAU,CAIZC,UAAW,SAAmBjJ,GAC5B,OAAO,YAAcA,IAAUkI,EAAKwB,WAAW1J,EAAMqI,YAAcxD,EAAOqE,SAASlJ,IAMrFoU,cAAe,SAAuBpU,GACpC,OAAOpB,MAAMC,QAAQmB,KAA4B,IAAjBA,EAAML,QAAgBqJ,EAAQC,UAAUjJ,EAAM,MAShFyN,QAAS,SAAiBrF,EAASiM,GACjC,IAAK,IAAIpT,KAAOoT,EACd,GAAY,aAARpT,GAIAmH,EAAQnH,KAASoT,EAAMpT,GACzB,OAAO,EAIX,OAAO,IAGPqT,EAAW,CAIbC,WAAY,SAAoBvU,GAC9B,OAAOmG,EAAKuG,OAAO1M,IAAU+J,EAAM8F,QAAQ7P,IAAUwJ,EAAMC,QAAQzJ,KAGnEkO,EAAO,CAITC,OAAQ,SAAgBnO,GACtB,OAAOpB,MAAMC,QAAQmB,IAA2B,IAAjBA,EAAML,QAAgBK,EAAM2I,MAAMxC,EAAKuG,UAGtExE,EAAO,CAITsM,SAAU,SAAkBC,EAAM9O,GAChC,IAAIqC,EAAOE,EAAKkC,IAAIqK,EAAM9O,GAE1B,GAAIM,EAAKC,OAAO8B,GACd,MAAM,IAAI2E,MAAM,yCAAyCsC,OAAOtJ,EAAM,gDAAgDsJ,OAAOjH,IAG/H,OAAOA,GAST0M,UAAwB,IAAoBnK,MAAK,SAASmK,EAAUD,EAAM9O,GACxE,IAAIX,EACA2P,EACAC,EACA5O,EACAhH,EACAmQ,EACA0F,EAASpQ,UAEb,OAAO,IAAoBsG,MAAK,SAAoB+J,GAClD,OACE,OAAQA,EAAUhS,KAAOgS,EAAUrU,MACjC,KAAK,EACHuE,EAAU6P,EAAOlV,OAAS,QAAmBsF,IAAd4P,EAAO,GAAmBA,EAAO,GAAK,GACrEF,EAAarW,EAA2B6H,EAAKuO,UAAU/O,EAAMX,IAC7D8P,EAAUhS,KAAO,EAEjB6R,EAAW7U,IAEb,KAAK,EACH,IAAK8U,EAASD,EAAW3V,KAAKe,KAAM,CAClC+U,EAAUrU,KAAO,GACjB,MAOF,OAJAuF,EAAI4O,EAAO5U,MACXhB,EAAIkJ,EAAKsM,SAASC,EAAMzO,GACxBmJ,EAAQ,CAACnQ,EAAGgH,GACZ8O,EAAUrU,KAAO,GACV0O,EAET,KAAK,GACH2F,EAAUrU,KAAO,EACjB,MAEF,KAAK,GACHqU,EAAUrU,KAAO,GACjB,MAEF,KAAK,GACHqU,EAAUhS,KAAO,GACjBgS,EAAU5J,GAAK4J,EAAiB,MAAE,GAElCH,EAAW1U,EAAE6U,EAAU5J,IAEzB,KAAK,GAKH,OAJA4J,EAAUhS,KAAO,GAEjB6R,EAAWxU,IAEJ2U,EAAU3J,OAAO,IAE1B,KAAK,GACL,IAAK,MACH,OAAO2J,EAAUzJ,UAGtBqJ,EAAW,KAAM,CAAC,CAAC,EAAG,GAAI,GAAI,SAMnCK,MAAO,SAAeN,EAAMO,GAC1B,GAAI/O,EAAKC,OAAOuO,GACd,MAAM,IAAI9H,MAAM,wCAAwCsC,OAAOgG,KAAKC,UAAUT,KAGhF,IAAIU,EAAIV,EAAKpM,SAAS2M,GAEtB,GAAS,MAALG,EACF,MAAM,IAAIxI,MAAM,8BAA8BsC,OAAO+F,EAAO,eAAe/F,OAAOgG,KAAKC,UAAUT,KAGnG,OAAOU,GAMT9M,SAAuB,IAAoBkC,MAAK,SAAkBkK,EAAM9O,GACtE,IAAIX,EACAoQ,EACAxP,EACA4O,EACAnM,EACA2M,EACAD,EACAM,EACAC,EAAS7Q,UAEb,OAAO,IAAoBsG,MAAK,SAAmBwK,GACjD,OACE,OAAQA,EAAUzS,KAAOyS,EAAU9U,MACjC,KAAK,EACHuE,EAAUsQ,EAAO3V,OAAS,QAAmBsF,IAAdqQ,EAAO,GAAmBA,EAAO,GAAK,GACrEF,EAAoBpQ,EAAQY,QAASA,OAAgC,IAAtBwP,GAAuCA,EACtFZ,EAAWtM,EAAKsM,SAASC,EAAM9O,GAC/B0C,EAAWmM,EAASnM,SACpB2M,EAAQpP,EAAUyC,EAAS1I,OAAS,EAAI,EAE1C,KAAK,EACH,KAAMiG,EAAUoP,GAAS,EAAIA,EAAQ3M,EAAS1I,QAAS,CACrD4V,EAAU9U,KAAO,GACjB,MAMF,OAHAsU,EAAQ7M,EAAK6M,MAAMP,EAAUQ,GAC7BK,EAAY1P,EAAKsJ,OAAO+F,GACxBO,EAAU9U,KAAO,GACV,CAACsU,EAAOM,GAEjB,KAAK,GACHL,EAAQpP,EAAUoP,EAAQ,EAAIA,EAAQ,EACtCO,EAAU9U,KAAO,EACjB,MAEF,KAAK,GACL,IAAK,MACH,OAAO8U,EAAUlK,UAGtBhD,MAMLuH,OAAQ,SAAgB6E,EAAM9O,EAAM6P,GAClC,IAAIxP,EAAIG,EAAKyJ,OAAOjK,EAAM6P,GAE1B,MAAO,CADCtN,EAAKkC,IAAIqK,EAAMzO,GACZA,IAMbyP,WAAY,SAAoBhB,EAAM9O,GACpC,IAAIqC,EAAOE,EAAKkC,IAAIqK,EAAM9O,GAE1B,GAAId,EAAOqE,SAASlB,GAClB,MAAM,IAAI2E,MAAM,2CAA2CsC,OAAOtJ,EAAM,yDAAyDsJ,OAAOjH,IAG1I,OAAOA,GAMT0N,YAA0B,IAAoBnL,MAAK,SAASmL,EAAYjB,GACtE,IAAIzP,EACA2Q,EACAC,EACAC,EACA7N,EACArC,EACAmQ,EAASrR,UAEb,OAAO,IAAoBsG,MAAK,SAAsBgL,GACpD,OACE,OAAQA,EAAUjT,KAAOiT,EAAUtV,MACjC,KAAK,EACHuE,EAAU8Q,EAAOnW,OAAS,QAAmBsF,IAAd6Q,EAAO,GAAmBA,EAAO,GAAK,GACrEH,EAAcrX,EAA2B4J,EAAKsD,MAAMiJ,EAAMzP,IAC1D+Q,EAAUjT,KAAO,EAEjB6S,EAAY7V,IAEd,KAAK,EACH,IAAK8V,EAAUD,EAAY3W,KAAKe,KAAM,CACpCgW,EAAUtV,KAAO,GACjB,MAKF,GAFAoV,EAAgB,YAAeD,EAAQ5V,MAAO,GAAIgI,EAAO6N,EAAc,GAEjD,KAFqDlQ,EAAOkQ,EAAc,IAErFlW,OAAe,CACxBoW,EAAUtV,KAAO,EACjB,MAIF,OADAsV,EAAUtV,KAAO,EACV,CAACuH,EAAMrC,GAEhB,KAAK,EACHoQ,EAAUtV,KAAO,EACjB,MAEF,KAAK,GACHsV,EAAUtV,KAAO,GACjB,MAEF,KAAK,GACHsV,EAAUjT,KAAO,GACjBiT,EAAU7K,GAAK6K,EAAiB,MAAE,GAElCJ,EAAY1V,EAAE8V,EAAU7K,IAE1B,KAAK,GAKH,OAJA6K,EAAUjT,KAAO,GAEjB6S,EAAYxV,IAEL4V,EAAU5K,OAAO,IAE1B,KAAK,GACL,IAAK,MACH,OAAO4K,EAAU1K,UAGtBqK,EAAa,KAAM,CAAC,CAAC,EAAG,GAAI,GAAI,SAQrCM,SAAuB,IAAoBzL,MAAK,SAASyL,EAASvB,GAChE,IAAIzP,EACAiR,EACAC,EACAC,EACAnO,EACArC,EACAyQ,EAAS3R,UAEb,OAAO,IAAoBsG,MAAK,SAAmBsL,GACjD,OACE,OAAQA,EAAUvT,KAAOuT,EAAU5V,MACjC,KAAK,EACHuE,EAAUoR,EAAOzW,OAAS,QAAmBsF,IAAdmR,EAAO,GAAmBA,EAAO,GAAK,GACrEH,EAAc3X,EAA2B4J,EAAKsD,MAAMiJ,EAAMzP,IAC1DqR,EAAUvT,KAAO,EAEjBmT,EAAYnW,IAEd,KAAK,EACH,IAAKoW,EAAUD,EAAYjX,KAAKe,KAAM,CACpCsW,EAAU5V,KAAO,GACjB,MAKF,GAFA0V,EAAgB,YAAeD,EAAQlW,MAAO,GAAIgI,EAAOmO,EAAc,GAAIxQ,EAAOwQ,EAAc,IAE3FnN,EAAQC,UAAUjB,GAAO,CAC5BqO,EAAU5V,KAAO,EACjB,MAIF,OADA4V,EAAU5V,KAAO,EACV,CAACuH,EAAMrC,GAEhB,KAAK,EACH0Q,EAAU5V,KAAO,EACjB,MAEF,KAAK,GACH4V,EAAU5V,KAAO,GACjB,MAEF,KAAK,GACH4V,EAAUvT,KAAO,GACjBuT,EAAUnL,GAAKmL,EAAiB,MAAE,GAElCJ,EAAYhW,EAAEoW,EAAUnL,IAE1B,KAAK,GAKH,OAJAmL,EAAUvT,KAAO,GAEjBmT,EAAY9V,IAELkW,EAAUlL,OAAO,IAE1B,KAAK,GACL,IAAK,MACH,OAAOkL,EAAUhL,UAGtB2K,EAAU,KAAM,CAAC,CAAC,EAAG,GAAI,GAAI,SAMlCjO,MAAO,SAAe0M,EAAM9O,GAI1B,IAHA,IAAIK,EAAIL,EAAKtG,QACTL,EAAIkJ,EAAKkC,IAAIqK,EAAMzO,GAEhBhH,IACDiH,EAAKC,OAAOlH,IAA4B,IAAtBA,EAAEqJ,SAAS1I,QAG/BX,EAAIA,EAAEqJ,SAAS,GACfrC,EAAE1B,KAAK,GAIX,MAAO,CAACtF,EAAGgH,IAMbiC,SAAU,SAAkBwM,EAAM5N,GAChC,GAAIZ,EAAKC,OAAOuO,GACd,MAAM,IAAI9H,MAAM,yDAAyDsC,OAAOgG,KAAKC,UAAUT,KAoDjG,OAjDc,YAAQA,GAAM,SAAU6B,GACpC,IAgBIC,EAhBAC,EAAgBhN,EAAM1B,MAAMjB,GAC5B4P,EAAiB,YAAeD,EAAe,GAC/CnP,EAAQoP,EAAe,GACvB7P,EAAM6P,EAAe,GAYrBC,EAAcpY,EAVA4J,EAAKsD,MAAM8K,EAAG,CAC9B1Q,SAAS,EACTwI,KAAM,SAAcC,GAClB,IACI1I,EADQ,YAAe0I,EAAM,GAChB,GAEjB,OAAQ7E,EAAMuD,SAASlG,EAAOlB,OAOlC,IACE,IAAK+Q,EAAY5W,MAAOyW,EAAUG,EAAY1X,KAAKe,MAAO,CACxD,IACI4F,EADgB,YAAe4Q,EAAQvW,MAAO,GACzB,GAEzB,IAAKwJ,EAAMuD,SAASlG,EAAOlB,GAAO,CAChC,IAAIkH,EAAS3E,EAAK2E,OAAOyJ,EAAG3Q,GACxBqP,EAAQrP,EAAKA,EAAKhG,OAAS,GAC/BkN,EAAOxE,SAASsO,OAAO3B,EAAO,GAGhC,GAAI7O,EAAKC,OAAOT,EAAMiB,EAAIjB,MAAO,CAC/B,IAAI2E,EAAOpC,EAAKoC,KAAKgM,EAAG3Q,GACxB2E,EAAK1H,KAAO0H,EAAK1H,KAAKvD,MAAM,EAAGuH,EAAI/D,QAGrC,GAAIsD,EAAKC,OAAOT,EAAM0B,EAAM1B,MAAO,CACjC,IAAIiR,EAAQ1O,EAAKoC,KAAKgM,EAAG3Q,GAEzBiR,EAAMhU,KAAOgU,EAAMhU,KAAKvD,MAAMgI,EAAMxE,UAGxC,MAAOxC,GACPqW,EAAYzW,EAAEI,GACd,QACAqW,EAAYvW,WAGPmW,EAAE9Q,aAEI6C,UAOjB+B,IAAK,SAAaqK,EAAM9O,GAGtB,IAFA,IAAIqC,EAAOyM,EAEF7U,EAAI,EAAGA,EAAI+F,EAAKhG,OAAQC,IAAK,CACpC,IAAIoG,EAAIL,EAAK/F,GAEb,GAAIqG,EAAKC,OAAO8B,KAAUA,EAAKK,SAASrC,GACtC,MAAM,IAAI2G,MAAM,qCAAqCsC,OAAOtJ,EAAM,eAAesJ,OAAOgG,KAAKC,UAAUT,KAGzGzM,EAAOA,EAAKK,SAASrC,GAGvB,OAAOgC,GAMT6O,IAAK,SAAapC,EAAM9O,GAGtB,IAFA,IAAIqC,EAAOyM,EAEF7U,EAAI,EAAGA,EAAI+F,EAAKhG,OAAQC,IAAK,CACpC,IAAIoG,EAAIL,EAAK/F,GAEb,GAAIqG,EAAKC,OAAO8B,KAAUA,EAAKK,SAASrC,GACtC,OAAO,EAGTgC,EAAOA,EAAKK,SAASrC,GAGvB,OAAO,GAMT8Q,OAAQ,SAAgB9W,GACtB,OAAOiG,EAAKC,OAAOlG,IAAUgJ,EAAQC,UAAUjJ,IAAU6E,EAAOqE,SAASlJ,IAM3E0J,WAAY,SAAoB1J,GAC9B,OAAOpB,MAAMC,QAAQmB,KAA4B,IAAjBA,EAAML,QAAgBuI,EAAK4O,OAAO9W,EAAM,MAM1EqK,KAAM,SAAcoK,EAAM9O,GAIxB,IAHA,IAAIK,EAAIL,EAAKtG,QACTL,EAAIkJ,EAAKkC,IAAIqK,EAAMzO,GAEhBhH,IACDiH,EAAKC,OAAOlH,IAA4B,IAAtBA,EAAEqJ,SAAS1I,QADzB,CAIN,IAAIC,EAAIZ,EAAEqJ,SAAS1I,OAAS,EAC5BX,EAAIA,EAAEqJ,SAASzI,GACfoG,EAAE1B,KAAK1E,GAIX,MAAO,CAACZ,EAAGgH,IAMbsE,KAAM,SAAcmK,EAAM9O,GACxB,IAAIqC,EAAOE,EAAKkC,IAAIqK,EAAM9O,GAE1B,IAAKM,EAAKC,OAAO8B,GACf,MAAM,IAAI2E,MAAM,qCAAqCsC,OAAOtJ,EAAM,4CAA4CsJ,OAAOjH,IAGvH,OAAOA,GASTlC,OAAqB,IAAoByE,MAAK,SAASzE,EAAO2O,EAAM9O,GAClE,IAAIX,EACA+R,EACAC,EACAhR,EACAhH,EACAiY,EAASxS,UAEb,OAAO,IAAoBsG,MAAK,SAAiBmM,GAC/C,OACE,OAAQA,EAAUpU,KAAOoU,EAAUzW,MACjC,KAAK,EACHuE,EAAUiS,EAAOtX,OAAS,QAAmBsF,IAAdgS,EAAO,GAAmBA,EAAO,GAAK,GACrEF,EAAczY,EAA2B6H,EAAKL,OAAOH,EAAMX,IAC3DkS,EAAUpU,KAAO,EAEjBiU,EAAYjX,IAEd,KAAK,EACH,IAAKkX,EAAUD,EAAY/X,KAAKe,KAAM,CACpCmX,EAAUzW,KAAO,GACjB,MAMF,OAHAuF,EAAIgR,EAAQhX,MACZhB,EAAIkJ,EAAKkC,IAAIqK,EAAMzO,GACnBkR,EAAUzW,KAAO,EACV,CAACzB,EAAGgH,GAEb,KAAK,EACHkR,EAAUzW,KAAO,EACjB,MAEF,KAAK,GACHyW,EAAUzW,KAAO,GACjB,MAEF,KAAK,GACHyW,EAAUpU,KAAO,GACjBoU,EAAUhM,GAAKgM,EAAiB,MAAE,GAElCH,EAAY9W,EAAEiX,EAAUhM,IAE1B,KAAK,GAKH,OAJAgM,EAAUpU,KAAO,GAEjBiU,EAAY5W,IAEL+W,EAAU/L,OAAO,IAE1B,KAAK,GACL,IAAK,MACH,OAAO+L,EAAU7L,UAGtBvF,EAAQ,KAAM,CAAC,CAAC,EAAG,GAAI,GAAI,SAMhC2H,QAAS,SAAiBzF,EAAMqM,GAC9B,OAAOrL,EAAQC,UAAUjB,IAASgB,EAAQyE,QAAQzF,EAAMqM,IAAUpO,EAAKC,OAAO8B,IAAS/B,EAAKwH,QAAQzF,EAAMqM,IAQ5G7I,MAAoB,IAAoBjB,MAAK,SAASiB,EAAMiJ,GAC1D,IAAIzP,EACAoJ,EACA+I,EACAvR,EACAwR,EACA5X,EACAgN,EACA6K,EACArR,EACAhH,EACAsY,EACAC,EACAC,EACAC,EAAShT,UAEb,OAAO,IAAoBsG,MAAK,SAAgB2M,GAC9C,OACE,OAAQA,EAAU5U,KAAO4U,EAAUjX,MACjC,KAAK,EACHuE,EAAUyS,EAAO9X,OAAS,QAAmBsF,IAAdwS,EAAO,GAAmBA,EAAO,GAAK,GACrErJ,EAAOpJ,EAAQoJ,KAAM+I,EAAoBnS,EAAQY,QAASA,OAAgC,IAAtBuR,GAAuCA,EAC3GC,EAAgBpS,EAAQxF,KAAMA,OAAyB,IAAlB4X,EAA2B,GAAKA,EAAe5K,EAAKxH,EAAQwH,GACjG6K,EAAU,IAAI7G,IACdxK,EAAI,GACJhH,EAAIyV,EAEN,KAAK,EAMH,IAAMjI,KAAO5G,EAAUO,EAAK8N,SAASjO,EAAGwG,GAAMrG,EAAKwR,QAAQ3R,EAAGwG,IAAO,CACnEkL,EAAUjX,KAAO,EACjB,MAGF,OAAOiX,EAAUzM,OAAO,QAAS,IAEnC,KAAK,EACH,GAAIoM,EAAQR,IAAI7X,GAAI,CAClB0Y,EAAUjX,KAAO,GACjB,MAIF,OADAiX,EAAUjX,KAAO,GACV,CAACzB,EAAGgH,GAEb,KAAK,GACH,GAAOqR,EAAQR,IAAI7X,IAAOiH,EAAKC,OAAOlH,IAA4B,IAAtBA,EAAEqJ,SAAS1I,QAAyB,MAARyO,IAAiC,IAAjBA,EAAK,CAACpP,EAAGgH,IAAiB,CAChH0R,EAAUjX,KAAO,GACjB,MAYF,OATA4W,EAAQ9G,IAAIvR,GACZsY,EAAY1R,EAAU5G,EAAEqJ,SAAS1I,OAAS,EAAI,EAE1CwG,EAAK6F,WAAWhG,EAAGxG,KACrB8X,EAAY9X,EAAKwG,EAAErG,SAGrBqG,EAAIA,EAAEiJ,OAAOqI,GACbtY,EAAIkJ,EAAKkC,IAAIqK,EAAMzO,GACZ0R,EAAUzM,OAAO,WAAY,GAEtC,KAAK,GACH,GAAmB,IAAbjF,EAAErG,OAAe,CACrB+X,EAAUjX,KAAO,GACjB,MAGF,OAAOiX,EAAUzM,OAAO,QAAS,IAEnC,KAAK,GACH,GAAIrF,EAAS,CACX8R,EAAUjX,KAAO,GACjB,MAKF,GAFA8W,EAAUpR,EAAK1F,KAAKuF,IAEfkC,EAAK2O,IAAIpC,EAAM8C,GAAU,CAC5BG,EAAUjX,KAAO,GACjB,MAKF,OAFAuF,EAAIuR,EACJvY,EAAIkJ,EAAKkC,IAAIqK,EAAMzO,GACZ0R,EAAUzM,OAAO,WAAY,GAEtC,KAAK,GACH,IAAMrF,GAA+B,IAApBI,EAAEA,EAAErG,OAAS,GAAW,CACvC+X,EAAUjX,KAAO,GACjB,MAMF,OAHA+W,EAAWrR,EAAKuF,SAAS1F,GACzBA,EAAIwR,EACJxY,EAAIkJ,EAAKkC,IAAIqK,EAAMzO,GACZ0R,EAAUzM,OAAO,WAAY,GAEtC,KAAK,GAEHjF,EAAIG,EAAK0G,OAAO7G,GAChBhH,EAAIkJ,EAAKkC,IAAIqK,EAAMzO,GACnBqR,EAAQ9G,IAAIvR,GACZ0Y,EAAUjX,KAAO,EACjB,MAEF,KAAK,GACL,IAAK,MACH,OAAOiX,EAAUrM,UAGtBG,MAMLqB,OAAQ,SAAgB4H,EAAM9O,GAC5B,IAAIyJ,EAAajJ,EAAK0G,OAAOlH,GACzBK,EAAIkC,EAAKkC,IAAIqK,EAAMrF,GAEvB,GAAInJ,EAAKC,OAAOF,GACd,MAAM,IAAI2G,MAAM,kCAAkCsC,OAAOtJ,EAAM,6CAGjE,OAAOK,GAUTyL,OAAQ,SAAgBzJ,GACtB,OAAI/B,EAAKC,OAAO8B,GACPA,EAAKpF,KAELoF,EAAKK,SAASuP,IAAI1P,EAAKuJ,QAAQoG,KAAK,KAO/CC,MAAoB,IAAoBvN,MAAK,SAASuN,EAAMrD,GAC1D,IAAIzP,EACA+S,EACAC,EACAC,EACAjQ,EACArC,EACAuS,EAAUzT,UAEd,OAAO,IAAoBsG,MAAK,SAAgBoN,GAC9C,OACE,OAAQA,EAAWrV,KAAOqV,EAAW1X,MACnC,KAAK,EACHuE,EAAUkT,EAAQvY,OAAS,QAAoBsF,IAAfiT,EAAQ,GAAmBA,EAAQ,GAAK,GACxEH,EAAczZ,EAA2B4J,EAAKsD,MAAMiJ,EAAMzP,IAC1DmT,EAAWrV,KAAO,EAElBiV,EAAYjY,IAEd,KAAK,EACH,IAAKkY,EAAUD,EAAY/Y,KAAKe,KAAM,CACpCoY,EAAW1X,KAAO,GAClB,MAKF,GAFAwX,EAAgB,YAAeD,EAAQhY,MAAO,GAAIgI,EAAOiQ,EAAc,GAAItS,EAAOsS,EAAc,IAE3FhS,EAAKC,OAAO8B,GAAO,CACtBmQ,EAAW1X,KAAO,EAClB,MAIF,OADA0X,EAAW1X,KAAO,EACX,CAACuH,EAAMrC,GAEhB,KAAK,EACHwS,EAAW1X,KAAO,EAClB,MAEF,KAAK,GACH0X,EAAW1X,KAAO,GAClB,MAEF,KAAK,GACH0X,EAAWrV,KAAO,GAClBqV,EAAWjN,GAAKiN,EAAkB,MAAE,GAEpCJ,EAAY9X,EAAEkY,EAAWjN,IAE3B,KAAK,GAKH,OAJAiN,EAAWrV,KAAO,GAElBiV,EAAY5X,IAELgY,EAAWhN,OAAO,IAE3B,KAAK,GACL,IAAK,MACH,OAAOgN,EAAW9M,UAGvByM,EAAO,KAAM,CAAC,CAAC,EAAG,GAAI,GAAI,UAIjC,SAASM,EAAUpU,EAAQC,GACzB,IAAItC,EAAO1C,OAAO0C,KAAKqC,GAEvB,GAAI/E,OAAO6C,sBAAuB,CAChC,IAAIoC,EAAUjF,OAAO6C,sBAAsBkC,GACvCC,IAAgBC,EAAUA,EAAQC,QAAO,SAAUC,GACrD,OAAOnF,OAAOoF,yBAAyBL,EAAQI,GAAKjD,eAEtDQ,EAAK2C,KAAKC,MAAM5C,EAAMuC,GAGxB,OAAOvC,EAGT,SAAS0W,EAAgB5W,GACvB,IAAK,IAAI7B,EAAI,EAAGA,EAAI6E,UAAU9E,OAAQC,IAAK,CACzC,IAAI2B,EAAyB,MAAhBkD,UAAU7E,GAAa6E,UAAU7E,GAAK,GAE/CA,EAAI,EACNwY,EAAUnZ,OAAOsC,IAAS,GAAMmD,SAAQ,SAAUzD,GAChDF,EAAgBU,EAAQR,EAAKM,EAAON,OAE7BhC,OAAO0F,0BAChB1F,OAAO2F,iBAAiBnD,EAAQxC,OAAO0F,0BAA0BpD,IAEjE6W,EAAUnZ,OAAOsC,IAASmD,SAAQ,SAAUzD,GAC1ChC,OAAOiC,eAAeO,EAAQR,EAAKhC,OAAOoF,yBAAyB9C,EAAQN,OAKjF,OAAOQ,EAGT,IAAIkI,EAAY,CAId2O,gBAAiB,SAAyBtY,GACxC,OAAO2J,EAAU4O,YAAYvY,IAAUA,EAAMwY,KAAKC,SAAS,UAM7DF,YAAa,SAAqBvY,GAChC,IAAK,YAAcA,GACjB,OAAO,EAGT,OAAQA,EAAMwY,MACZ,IAAK,cACH,OAAOrS,EAAKuG,OAAO1M,EAAM2F,OAASuC,EAAK4O,OAAO9W,EAAMgI,MAEtD,IAAK,cACH,MAA+B,iBAAjBhI,EAAM6C,QAA6C,iBAAf7C,EAAM4C,MAAqBuD,EAAKuG,OAAO1M,EAAM2F,MAEjG,IAAK,aACH,MAAiC,iBAAnB3F,EAAM0Y,UAAyBvS,EAAKuG,OAAO1M,EAAM2F,OAAS,YAAc3F,EAAM2Y,YAE9F,IAAK,YACH,OAAOxS,EAAKuG,OAAO1M,EAAM2F,OAASQ,EAAKuG,OAAO1M,EAAMuX,SAEtD,IAAK,cACH,OAAOpR,EAAKuG,OAAO1M,EAAM2F,OAASuC,EAAK4O,OAAO9W,EAAMgI,MAEtD,IAAK,cACH,MAA+B,iBAAjBhI,EAAM6C,QAA6C,iBAAf7C,EAAM4C,MAAqBuD,EAAKuG,OAAO1M,EAAM2F,MAEjG,IAAK,WACH,OAAOQ,EAAKuG,OAAO1M,EAAM2F,OAAS,YAAc3F,EAAM2Y,aAAe,YAAc3Y,EAAM4Y,eAE3F,IAAK,gBACH,OAA4B,OAArB5Y,EAAM2Y,YAAuBnP,EAAMC,QAAQzJ,EAAM4Y,gBAA0C,OAAxB5Y,EAAM4Y,eAA0BpP,EAAMC,QAAQzJ,EAAM2Y,aAAe,YAAc3Y,EAAM2Y,aAAe,YAAc3Y,EAAM4Y,eAEtM,IAAK,aACH,OAAOzS,EAAKuG,OAAO1M,EAAM2F,OAAmC,iBAAnB3F,EAAM0Y,UAAyB,YAAc1Y,EAAM2Y,YAE9F,QACE,OAAO,IAOb/O,gBAAiB,SAAyB5J,GACxC,OAAOpB,MAAMC,QAAQmB,KAA4B,IAAjBA,EAAML,QAAgBgK,EAAU4O,YAAYvY,EAAM,MAMpF6Y,qBAAsB,SAA8B7Y,GAClD,OAAO2J,EAAU4O,YAAYvY,IAAUA,EAAMwY,KAAKC,SAAS,eAM7DK,gBAAiB,SAAyB9Y,GACxC,OAAO2J,EAAU4O,YAAYvY,IAAUA,EAAMwY,KAAKC,SAAS,UAO7DM,QAAS,SAAiBC,GACxB,OAAQA,EAAGR,MACT,IAAK,cAED,OAAOH,EAAgB,GAAIW,EAAI,CAC7BR,KAAM,gBAIZ,IAAK,cAED,OAAOH,EAAgB,GAAIW,EAAI,CAC7BR,KAAM,gBAIZ,IAAK,aAED,OAAOH,EAAgB,GAAIW,EAAI,CAC7BR,KAAM,aACN7S,KAAMQ,EAAKuF,SAASsN,EAAGrT,QAI7B,IAAK,YAED,IAAI4R,EAAUyB,EAAGzB,QACb5R,EAAOqT,EAAGrT,KAEd,OAAIQ,EAAKC,OAAOmR,EAAS5R,GAChBqT,EAKL7S,EAAK8S,UAAUtT,EAAM4R,GAChBc,EAAgB,GAAIW,EAAI,CAC7BrT,KAAM4R,EACNA,QAAS5R,IAYN0S,EAAgB,GAAIW,EAAI,CAC7BrT,KAHgBQ,EAAK+S,UAAUvT,EAAMqT,GAIrCzB,QAHmBpR,EAAK+S,UAAU/S,EAAK1F,KAAKkF,GAAOqT,KAOzD,IAAK,cAED,OAAOX,EAAgB,GAAIW,EAAI,CAC7BR,KAAM,gBAIZ,IAAK,cAED,OAAOH,EAAgB,GAAIW,EAAI,CAC7BR,KAAM,gBAIZ,IAAK,WAED,IAAIG,EAAaK,EAAGL,WAEpB,OAAON,EAAgB,GAAIW,EAAI,CAC7BL,WAFkBK,EAAGJ,cAGrBA,cAAeD,IAIrB,IAAK,gBAED,IAAIQ,EAAcH,EAAGL,WACjBS,EAAiBJ,EAAGJ,cAExB,OACSP,EAAgB,GAAIW,EADV,MAAfG,EAC6B,CAC7BR,WAAYS,EACZR,cAAe,MAEU,MAAlBQ,EACsB,CAC7BT,WAAY,KACZC,cAAeO,GAGc,CAC7BR,WAAYS,EACZR,cAAeO,IAKvB,IAAK,aAED,OAAOd,EAAgB,GAAIW,EAAI,CAC7BR,KAAM,aACN7S,KAAMQ,EAAK1F,KAAKuY,EAAGrT,WAM3BQ,EAAO,CAOTuO,UAAW,SAAmB/O,GAC5B,IAAIX,EAAUP,UAAU9E,OAAS,QAAsBsF,IAAjBR,UAAU,GAAmBA,UAAU,GAAK,GAC9E4U,EAAoBrU,EAAQY,QAC5BA,OAAgC,IAAtByT,GAAuCA,EACjDC,EAAQnT,EAAKL,OAAOH,EAAMX,GAQ9B,OALEsU,EADE1T,EACM0T,EAAMja,MAAM,GAEZia,EAAMja,MAAM,GAAI,IAS5BuQ,OAAQ,SAAgBjK,EAAM6P,GAG5B,IAFA,IAAI5F,EAAS,GAEJhQ,EAAI,EAAGA,EAAI+F,EAAKhG,QAAUC,EAAI4V,EAAQ7V,OAAQC,IAAK,CAC1D,IAAI2Z,EAAK5T,EAAK/F,GAGd,GAAI2Z,IAFK/D,EAAQ5V,GAGf,MAGFgQ,EAAOtL,KAAKiV,GAGd,OAAO3J,GAWTtB,QAAS,SAAiB3I,EAAM6P,GAG9B,IAFA,IAAIgE,EAAMC,KAAKD,IAAI7T,EAAKhG,OAAQ6V,EAAQ7V,QAE/BC,EAAI,EAAGA,EAAI4Z,EAAK5Z,IAAK,CAC5B,GAAI+F,EAAK/F,GAAK4V,EAAQ5V,GAAI,OAAQ,EAClC,GAAI+F,EAAK/F,GAAK4V,EAAQ5V,GAAI,OAAO,EAGnC,OAAO,GAMT8Z,UAAW,SAAmB/T,EAAM6P,GAClC,IAAI5V,EAAI+F,EAAKhG,OAAS,EAClBga,EAAKhU,EAAKtG,MAAM,EAAGO,GACnBga,EAAKpE,EAAQnW,MAAM,EAAGO,GACtB2Z,EAAK5T,EAAK/F,GACVia,EAAKrE,EAAQ5V,GACjB,OAAOuG,EAAKC,OAAOuT,EAAIC,IAAOL,EAAKM,GAMrCC,OAAQ,SAAgBnU,EAAM6P,GAC5B,IAAI5V,EAAI+F,EAAKhG,OACTga,EAAKhU,EAAKtG,MAAM,EAAGO,GACnBga,EAAKpE,EAAQnW,MAAM,EAAGO,GAC1B,OAAOuG,EAAKC,OAAOuT,EAAIC,IAMzBG,WAAY,SAAoBpU,EAAM6P,GACpC,IAAI5V,EAAI+F,EAAKhG,OAAS,EAClBga,EAAKhU,EAAKtG,MAAM,EAAGO,GACnBga,EAAKpE,EAAQnW,MAAM,EAAGO,GACtB2Z,EAAK5T,EAAK/F,GACVia,EAAKrE,EAAQ5V,GACjB,OAAOuG,EAAKC,OAAOuT,EAAIC,IAAOL,EAAKM,GAMrCzT,OAAQ,SAAgBT,EAAM6P,GAC5B,OAAO7P,EAAKhG,SAAW6V,EAAQ7V,QAAUgG,EAAKgD,OAAM,SAAU3J,EAAGY,GAC/D,OAAOZ,IAAMwW,EAAQ5V,OAOzB+X,QAAS,SAAiBhS,EAAM6P,GAC9B,OAAuC,IAAhCrP,EAAKmI,QAAQ3I,EAAM6P,IAM5BxJ,WAAY,SAAoBrG,EAAM6P,GACpC,OAAO7P,EAAKhG,OAAS6V,EAAQ7V,QAA0C,IAAhCwG,EAAKmI,QAAQ3I,EAAM6P,IAM5DvB,SAAU,SAAkBtO,EAAM6P,GAChC,OAAwC,IAAjCrP,EAAKmI,QAAQ3I,EAAM6P,IAM5BwE,QAAS,SAAiBrU,EAAM6P,GAC9B,OAAO7P,EAAKhG,SAAW6V,EAAQ7V,OAAS,GAAqC,IAAhCwG,EAAKmI,QAAQ3I,EAAM6P,IAMlEyE,SAAU,SAAkBtU,EAAM6P,GAChC,OAAO7P,EAAKhG,QAAU6V,EAAQ7V,QAA0C,IAAhCwG,EAAKmI,QAAQ3I,EAAM6P,IAM7D0E,aAAc,SAAsBvU,EAAM6P,GACxC,OAAO7P,EAAKhG,OAAS6V,EAAQ7V,QAA0C,IAAhCwG,EAAKmI,QAAQ3I,EAAM6P,IAM5D2E,SAAU,SAAkBxU,EAAM6P,GAChC,OAAO7P,EAAKhG,OAAS,IAAM6V,EAAQ7V,QAA0C,IAAhCwG,EAAKmI,QAAQ3I,EAAM6P,IAMlE9I,OAAQ,SAAgB1M,GACtB,OAAOpB,MAAMC,QAAQmB,KAA4B,IAAjBA,EAAML,QAAoC,iBAAbK,EAAM,KAMrEiZ,UAAW,SAAmBtT,EAAM6P,GAClC,GAAI7P,EAAKhG,SAAW6V,EAAQ7V,OAC1B,OAAO,EAGT,IAAIga,EAAKhU,EAAKtG,MAAM,GAAI,GACpBua,EAAKpE,EAAQnW,MAAM,GAAI,GAG3B,OAFSsG,EAAKA,EAAKhG,OAAS,KACnB6V,EAAQA,EAAQ7V,OAAS,IACdwG,EAAKC,OAAOuT,EAAIC,IAUtC9T,OAAQ,SAAgBH,GAMtB,IALA,IAAIX,EAAUP,UAAU9E,OAAS,QAAsBsF,IAAjBR,UAAU,GAAmBA,UAAU,GAAK,GAC9E2V,EAAoBpV,EAAQY,QAC5BA,OAAgC,IAAtBwU,GAAuCA,EACjDC,EAAO,GAEFza,EAAI,EAAGA,GAAK+F,EAAKhG,OAAQC,IAChCya,EAAK/V,KAAKqB,EAAKtG,MAAM,EAAGO,IAO1B,OAJIgG,GACFyU,EAAKzU,UAGAyU,GAMT5Z,KAAM,SAAckF,GAClB,GAAoB,IAAhBA,EAAKhG,OACP,MAAM,IAAIgN,MAAM,4CAA4CsC,OAAOtJ,EAAM,qCAG3E,IAAI0E,EAAO1E,EAAKA,EAAKhG,OAAS,GAC9B,OAAOgG,EAAKtG,MAAM,GAAI,GAAG4P,OAAO5E,EAAO,IAMzCwC,OAAQ,SAAgBlH,GACtB,GAAoB,IAAhBA,EAAKhG,OACP,MAAM,IAAIgN,MAAM,gDAAgDsC,OAAOtJ,EAAM,OAG/E,OAAOA,EAAKtG,MAAM,GAAI,IAMxBqM,SAAU,SAAkB/F,GAC1B,GAAoB,IAAhBA,EAAKhG,OACP,MAAM,IAAIgN,MAAM,gDAAgDsC,OAAOtJ,EAAM,yCAG/E,IAAI0E,EAAO1E,EAAKA,EAAKhG,OAAS,GAE9B,GAAI0K,GAAQ,EACV,MAAM,IAAIsC,MAAM,uDAAuDsC,OAAOtJ,EAAM,mDAGtF,OAAOA,EAAKtG,MAAM,GAAI,GAAG4P,OAAO5E,EAAO,IAMzCiQ,SAAU,SAAkB3U,EAAM6O,GAChC,IAAKrO,EAAK6F,WAAWwI,EAAU7O,KAAUQ,EAAKC,OAAOT,EAAM6O,GACzD,MAAM,IAAI7H,MAAM,oCAAoCsC,OAAOtJ,EAAM,uBAAuBsJ,OAAOuF,EAAU,qDAG3G,OAAO7O,EAAKtG,MAAMmV,EAAS7U,SAM7BuZ,UAAW,SAAmBvT,EAAM4U,GAClC,IAAIvV,EAAUP,UAAU9E,OAAS,QAAsBsF,IAAjBR,UAAU,GAAmBA,UAAU,GAAK,GAClF,OAAO,YAAQkB,GAAM,SAAUK,GAC7B,IAAIwU,EAAqBxV,EAAQgL,SAC7BA,OAAkC,IAAvBwK,EAAgC,UAAYA,EAE3D,GAAoB,IAAhB7U,EAAKhG,OAIT,OAAQ4a,EAAU/B,MAChB,IAAK,cAED,IAAIQ,EAAKuB,EAAU5U,MAEfQ,EAAKC,OAAO4S,EAAIhT,IAAMG,EAAK4T,WAAWf,EAAIhT,IAAMG,EAAK6F,WAAWgN,EAAIhT,MACtEA,EAAEgT,EAAGrZ,OAAS,IAAM,GAGtB,MAGJ,IAAK,cAED,IAAI8a,EAAMF,EAAU5U,KAEpB,GAAIQ,EAAKC,OAAOqU,EAAKzU,IAAMG,EAAK6F,WAAWyO,EAAKzU,GAC9C,OAAO,KACEG,EAAK4T,WAAWU,EAAKzU,KAC9BA,EAAEyU,EAAI9a,OAAS,IAAM,GAGvB,MAGJ,IAAK,aAED,IAAI+a,EAAOH,EAAU5U,KACjB+S,EAAW6B,EAAU7B,SAErBvS,EAAKC,OAAOsU,EAAM1U,IAAMG,EAAK4T,WAAWW,EAAM1U,GAChDA,EAAE0U,EAAK/a,OAAS,IAAM,EACbwG,EAAK6F,WAAW0O,EAAM1U,KAC/BA,EAAE0U,EAAK/a,OAAS,IAAM,EACtBqG,EAAE0U,EAAK/a,SAAW+Y,GAGpB,MAGJ,IAAK,aAED,IAAIiC,EAAOJ,EAAU5U,KACjBiV,EAAYL,EAAU7B,SAE1B,GAAIvS,EAAKC,OAAOuU,EAAM3U,IACpB,GAAiB,YAAbgK,EACFhK,EAAEA,EAAErG,OAAS,IAAM,OACd,GAAiB,aAAbqQ,EACT,OAAO,UAEA7J,EAAK4T,WAAWY,EAAM3U,GAC/BA,EAAE2U,EAAKhb,OAAS,IAAM,EACbwG,EAAK6F,WAAW2O,EAAM3U,IAAML,EAAKgV,EAAKhb,SAAWib,IAC1D5U,EAAE2U,EAAKhb,OAAS,IAAM,EACtBqG,EAAE2U,EAAKhb,SAAWib,GAGpB,MAGJ,IAAK,YAED,IAAIC,EAAON,EAAU5U,KACjBmV,EAAMP,EAAUhD,QAEpB,GAAIpR,EAAKC,OAAOyU,EAAMC,GACpB,OAGF,GAAI3U,EAAK6F,WAAW6O,EAAM7U,IAAMG,EAAKC,OAAOyU,EAAM7U,GAAI,CACpD,IAAI+U,EAAOD,EAAIzb,QAMf,OAJI8G,EAAK4T,WAAWc,EAAMC,IAAQD,EAAKlb,OAASmb,EAAInb,SAClDob,EAAKF,EAAKlb,OAAS,IAAM,GAGpBob,EAAK9L,OAAOjJ,EAAE3G,MAAMwb,EAAKlb,SACvBwG,EAAK8S,UAAU4B,EAAMC,KAAS3U,EAAK6F,WAAW8O,EAAK9U,IAAMG,EAAKC,OAAO0U,EAAK9U,IAC/EG,EAAK4T,WAAWc,EAAM7U,GACxBA,EAAE6U,EAAKlb,OAAS,IAAM,EAEtBqG,EAAE6U,EAAKlb,OAAS,IAAM,EAEfwG,EAAK4T,WAAWe,EAAK9U,IAAMG,EAAKC,OAAO0U,EAAK9U,IAAMG,EAAK6F,WAAW8O,EAAK9U,IAC5EG,EAAK4T,WAAWc,EAAM7U,KACxBA,EAAE6U,EAAKlb,OAAS,IAAM,GAGxBqG,EAAE8U,EAAInb,OAAS,IAAM,GACZwG,EAAK4T,WAAWc,EAAM7U,KAC3BG,EAAKC,OAAO0U,EAAK9U,KACnBA,EAAE8U,EAAInb,OAAS,IAAM,GAGvBqG,EAAE6U,EAAKlb,OAAS,IAAM,SAShCqb,EAAU,CAIZ9B,UAAW,SAAmBjJ,EAAK+I,GACjC,IAAI9I,EAAUD,EAAIC,QACdF,EAAWC,EAAID,SAEnB,GAAe,MAAXE,EAAJ,CAIA,IAAIvK,EAAOQ,EAAK+S,UAAUhJ,EAAS8I,EAAI,CACrChJ,SAAUA,IAEZC,EAAIC,QAAUvK,EAEF,MAARA,GACFsK,EAAIE,WAKV,SAAS8K,EAAUjX,EAAQC,GACzB,IAAItC,EAAO1C,OAAO0C,KAAKqC,GAEvB,GAAI/E,OAAO6C,sBAAuB,CAChC,IAAIoC,EAAUjF,OAAO6C,sBAAsBkC,GACvCC,IAAgBC,EAAUA,EAAQC,QAAO,SAAUC,GACrD,OAAOnF,OAAOoF,yBAAyBL,EAAQI,GAAKjD,eAEtDQ,EAAK2C,KAAKC,MAAM5C,EAAMuC,GAGxB,OAAOvC,EAGT,SAASuZ,EAAgBzZ,GACvB,IAAK,IAAI7B,EAAI,EAAGA,EAAI6E,UAAU9E,OAAQC,IAAK,CACzC,IAAI2B,EAAyB,MAAhBkD,UAAU7E,GAAa6E,UAAU7E,GAAK,GAE/CA,EAAI,EACNqb,EAAUhc,OAAOsC,IAAS,GAAMmD,SAAQ,SAAUzD,GAChDF,EAAgBU,EAAQR,EAAKM,EAAON,OAE7BhC,OAAO0F,0BAChB1F,OAAO2F,iBAAiBnD,EAAQxC,OAAO0F,0BAA0BpD,IAEjE0Z,EAAUhc,OAAOsC,IAASmD,SAAQ,SAAUzD,GAC1ChC,OAAOiC,eAAeO,EAAQR,EAAKhC,OAAOoF,yBAAyB9C,EAAQN,OAKjF,OAAOQ,EAGT,IAAIsI,EAAQ,CAKVuE,QAAS,SAAiB7H,EAAO+O,GAC/B,IAAI2F,EAAShV,EAAKmI,QAAQ7H,EAAMd,KAAM6P,EAAQ7P,MAE9C,OAAe,IAAXwV,EACE1U,EAAM5D,OAAS2S,EAAQ3S,QAAgB,EACvC4D,EAAM5D,OAAS2S,EAAQ3S,OAAe,EACnC,EAGFsY,GAMTxD,QAAS,SAAiBlR,EAAO+O,GAC/B,OAAyC,IAAlCzL,EAAMuE,QAAQ7H,EAAO+O,IAM9BvB,SAAU,SAAkBxN,EAAO+O,GACjC,OAA0C,IAAnCzL,EAAMuE,QAAQ7H,EAAO+O,IAM9BpP,OAAQ,SAAgBK,EAAO+O,GAE7B,OAAO/O,EAAM5D,SAAW2S,EAAQ3S,QAAUsD,EAAKC,OAAOK,EAAMd,KAAM6P,EAAQ7P,OAM5EkK,QAAS,SAAiB7P,GACxB,OAAO,YAAcA,IAAkC,iBAAjBA,EAAM6C,QAAuBsD,EAAKuG,OAAO1M,EAAM2F,OAMvFuT,UAAW,SAAmBzS,EAAOuS,GACnC,IAAIhU,EAAUP,UAAU9E,OAAS,QAAsBsF,IAAjBR,UAAU,GAAmBA,UAAU,GAAK,GAClF,OAAO,YAAQgC,GAAO,SAAUT,GAC9B,IAAIoV,EAAqBpW,EAAQgL,SAC7BA,OAAkC,IAAvBoL,EAAgC,UAAYA,EACvDzV,EAAOK,EAAEL,KACT9C,EAASmD,EAAEnD,OAEf,OAAQmW,EAAGR,MACT,IAAK,cACL,IAAK,YAEDxS,EAAEL,KAAOQ,EAAK+S,UAAUvT,EAAMqT,EAAIhU,GAClC,MAGJ,IAAK,cAEGmB,EAAKC,OAAO4S,EAAGrT,KAAMA,IAASqT,EAAGnW,QAAUA,IAC7CmD,EAAEnD,QAAUmW,EAAGpW,KAAKjD,QAGtB,MAGJ,IAAK,aAEGwG,EAAKC,OAAO4S,EAAGrT,KAAMA,KACvBK,EAAEnD,QAAUmW,EAAGN,UAGjB1S,EAAEL,KAAOQ,EAAK+S,UAAUvT,EAAMqT,EAAIhU,GAClC,MAGJ,IAAK,cAEGmB,EAAKC,OAAO4S,EAAGrT,KAAMA,IAASqT,EAAGnW,QAAUA,IAC7CmD,EAAEnD,QAAU4W,KAAKD,IAAI3W,EAASmW,EAAGnW,OAAQmW,EAAGpW,KAAKjD,SAGnD,MAGJ,IAAK,cAED,GAAIwG,EAAKC,OAAO4S,EAAGrT,KAAMA,IAASQ,EAAK6F,WAAWgN,EAAGrT,KAAMA,GACzD,OAAO,KAGTK,EAAEL,KAAOQ,EAAK+S,UAAUvT,EAAMqT,EAAIhU,GAClC,MAGJ,IAAK,aAED,GAAImB,EAAKC,OAAO4S,EAAGrT,KAAMA,GAAO,CAC9B,GAAIqT,EAAGN,WAAa7V,GAAsB,MAAZmN,EAC5B,OAAO,MACEgJ,EAAGN,SAAW7V,GAAUmW,EAAGN,WAAa7V,GAAuB,YAAbmN,KAC3DhK,EAAEnD,QAAUmW,EAAGN,SACf1S,EAAEL,KAAOQ,EAAK+S,UAAUvT,EAAMqT,EAAIkC,EAAgB,GAAIlW,EAAS,CAC7DgL,SAAU,mBAIdhK,EAAEL,KAAOQ,EAAK+S,UAAUvT,EAAMqT,EAAIhU,SAS5CqW,EAAW,CAIbnC,UAAW,SAAmBjJ,EAAK+I,GACjC,IAAI9I,EAAUD,EAAIC,QACdF,EAAWC,EAAID,SAEnB,GAAe,MAAXE,EAAJ,CAIA,IAAIzJ,EAAQsD,EAAMmP,UAAUhJ,EAAS8I,EAAI,CACvChJ,SAAUA,IAEZC,EAAIC,QAAUzJ,EAED,MAATA,GACFwJ,EAAIE,WAKV,SAASmL,EAAUtX,EAAQC,GACzB,IAAItC,EAAO1C,OAAO0C,KAAKqC,GAEvB,GAAI/E,OAAO6C,sBAAuB,CAChC,IAAIoC,EAAUjF,OAAO6C,sBAAsBkC,GACvCC,IAAgBC,EAAUA,EAAQC,QAAO,SAAUC,GACrD,OAAOnF,OAAOoF,yBAAyBL,EAAQI,GAAKjD,eAEtDQ,EAAK2C,KAAKC,MAAM5C,EAAMuC,GAGxB,OAAOvC,EAuBT,IAAI6H,EAAQ,CAKV1B,MAAO,SAAejB,GACpB,IAAI7B,EAAUP,UAAU9E,OAAS,QAAsBsF,IAAjBR,UAAU,GAAmBA,UAAU,GAAK,GAC9E8W,EAAoBvW,EAAQY,QAC5BA,OAAgC,IAAtB2V,GAAuCA,EACjD/U,EAASK,EAAML,OACfG,EAAQE,EAAMF,MAClB,OAAO6C,EAAMgS,WAAW3U,KAAWjB,EAAU,CAACY,EAAQG,GAAS,CAACA,EAAOH,IAMzEI,IAAK,SAAaC,GAChB,IAAI4U,EAAiBjS,EAAM1B,MAAMjB,GAE7BD,EADiB,YAAe6U,EAAgB,GAC3B,GAEzB,OAAO7U,GAMTR,OAAQ,SAAgBS,EAAO2O,GAC7B,OAAOzL,EAAM3D,OAAOS,EAAML,OAAQgP,EAAQhP,SAAWuD,EAAM3D,OAAOS,EAAMF,MAAO6O,EAAQ7O,QAMzFoG,SAAU,SAAkBlG,EAAOpF,GACjC,GAAI+H,EAAMC,QAAQhI,GAAS,CACzB,GAAI+H,EAAMuD,SAASlG,EAAOpF,EAAO+E,SAAWgD,EAAMuD,SAASlG,EAAOpF,EAAOkF,OACvE,OAAO,EAGT,IAAI+U,EAAiBlS,EAAM1B,MAAMjB,GAC7B8U,EAAiB,YAAeD,EAAgB,GAChDE,EAAKD,EAAe,GACpBE,EAAKF,EAAe,GAEpBG,EAAiBtS,EAAM1B,MAAMrG,GAC7Bsa,EAAiB,YAAeD,EAAgB,GAChDE,EAAKD,EAAe,GACpBE,EAAKF,EAAe,GAExB,OAAOhS,EAAMkK,SAAS2H,EAAII,IAAOjS,EAAM4N,QAAQkE,EAAII,GAGrD,IAAIC,EAAiB1S,EAAM1B,MAAMjB,GAC7BsV,EAAiB,YAAeD,EAAgB,GAChD7U,EAAQ8U,EAAe,GACvBvV,EAAMuV,EAAe,GAErBC,GAAe,EACfC,GAAc,EAUlB,OARItS,EAAM8F,QAAQpO,IAChB2a,EAAerS,EAAMuE,QAAQ7M,EAAQ4F,IAAU,EAC/CgV,EAActS,EAAMuE,QAAQ7M,EAAQmF,IAAQ,IAE5CwV,EAAejW,EAAKmI,QAAQ7M,EAAQ4F,EAAM1B,OAAS,EACnD0W,EAAclW,EAAKmI,QAAQ7M,EAAQmF,EAAIjB,OAAS,GAG3CyW,GAAgBC,GAMzBC,aAAc,SAAsBzV,EAAO2O,GACzC,IAAI7R,EAAOrC,EAAyBuF,EAAO,CAAC,SAAU,UAElD0V,EAAiB/S,EAAM1B,MAAMjB,GAC7B2V,EAAiB,YAAeD,EAAgB,GAChDE,EAAKD,EAAe,GACpBE,EAAKF,EAAe,GAEpBG,EAAiBnT,EAAM1B,MAAM0N,GAC7BoH,EAAiB,YAAeD,EAAgB,GAChDE,EAAKD,EAAe,GACpBE,EAAKF,EAAe,GAEpBvV,EAAQ0C,EAAMkK,SAASwI,EAAII,GAAMA,EAAKJ,EACtC7V,EAAMmD,EAAMkK,SAASyI,EAAII,GAAMJ,EAAKI,EAExC,OAAI/S,EAAMkK,SAASrN,EAAKS,GACf,KAjHb,SAAyB5F,GACvB,IAAK,IAAI7B,EAAI,EAAGA,EAAI6E,UAAU9E,OAAQC,IAAK,CACzC,IAAI2B,EAAyB,MAAhBkD,UAAU7E,GAAa6E,UAAU7E,GAAK,GAE/CA,EAAI,EACN0b,EAAUrc,OAAOsC,IAAS,GAAMmD,SAAQ,SAAUzD,GAChDF,EAAgBU,EAAQR,EAAKM,EAAON,OAE7BhC,OAAO0F,0BAChB1F,OAAO2F,iBAAiBnD,EAAQxC,OAAO0F,0BAA0BpD,IAEjE+Z,EAAUrc,OAAOsC,IAASmD,SAAQ,SAAUzD,GAC1ChC,OAAOiC,eAAeO,EAAQR,EAAKhC,OAAOoF,yBAAyB9C,EAAQN,OAKjF,OAAOQ,EAkGIsb,CAAgB,CACrBvW,OAAQa,EACRV,MAAOC,GACNjD,IAQP6X,WAAY,SAAoB3U,GAC9B,IAAIL,EAASK,EAAML,OACfG,EAAQE,EAAMF,MAClB,OAAOoD,EAAM4N,QAAQnR,EAAQG,IAO/BgN,YAAa,SAAqB9M,GAChC,IAAIL,EAASK,EAAML,OACfG,EAAQE,EAAMF,MAClB,OAAOoD,EAAM3D,OAAOI,EAAQG,IAQ9B2E,WAAY,SAAoBzE,GAC9B,OAAQ2C,EAAMmK,YAAY9M,IAQ5BmW,UAAW,SAAmBnW,GAC5B,OAAQ2C,EAAMgS,WAAW3U,IAM3B4C,QAAS,SAAiBzJ,GACxB,OAAO,YAAcA,IAAU+J,EAAM8F,QAAQ7P,EAAMwG,SAAWuD,EAAM8F,QAAQ7P,EAAM2G,QAMpFsW,OAAqB,IAAoB1S,MAAK,SAAS0S,EAAOpW,GAC5D,OAAO,IAAoBkE,MAAK,SAAiBmS,GAC/C,OACE,OAAQA,EAAWpa,KAAOoa,EAAWzc,MACnC,KAAK,EAEH,OADAyc,EAAWzc,KAAO,EACX,CAACoG,EAAML,OAAQ,UAExB,KAAK,EAEH,OADA0W,EAAWzc,KAAO,EACX,CAACoG,EAAMF,MAAO,SAEvB,KAAK,EACL,IAAK,MACH,OAAOuW,EAAW7R,UAGvB4R,MAML5V,MAAO,SAAeR,GACpB,IAAIsW,EAAiB3T,EAAM1B,MAAMjB,GAE7BQ,EADiB,YAAe8V,EAAgB,GACzB,GAE3B,OAAO9V,GAMT6R,UAAW,SAAmBrS,EAAOmS,GACnC,IAGIoE,EACAC,EAJArY,EAAUP,UAAU9E,OAAS,QAAsBsF,IAAjBR,UAAU,GAAmBA,UAAU,GAAK,GAC9E6Y,EAAqBtY,EAAQgL,SAC7BA,OAAkC,IAAvBsN,EAAgC,SAAWA,EAyB1D,MArBiB,WAAbtN,EACExG,EAAMwT,UAAUnW,IAClBuW,EAAiB,UACjBC,EAAgB,aAEhBD,EAAiB,WACjBC,EAAgB,WAEI,YAAbrN,EACLxG,EAAMwT,UAAUnW,IAClBuW,EAAiB,WACjBC,EAAgB,YAEhBD,EAAiB,UACjBC,EAAgB,aAGlBD,EAAiBpN,EACjBqN,EAAgBrN,GAGX,YAAQnJ,GAAO,SAAUyP,GAC9B,IAAI9P,EAASuD,EAAMmP,UAAU5C,EAAE9P,OAAQwS,EAAI,CACzChJ,SAAUoN,IAERzW,EAAQoD,EAAMmP,UAAU5C,EAAE3P,MAAOqS,EAAI,CACvChJ,SAAUqN,IAGZ,IAAK7W,IAAWG,EACd,OAAO,KAGT2P,EAAE9P,OAASA,EACX8P,EAAE3P,MAAQA,OAIZ4W,EAAW,CAIbrE,UAAW,SAAmBjJ,EAAK+I,GACjC,IAAI9I,EAAUD,EAAIC,QACdF,EAAWC,EAAID,SAEnB,GAAe,MAAXE,EAAJ,CAIA,IAAIvK,EAAO6D,EAAM0P,UAAUhJ,EAAS8I,EAAI,CACtChJ,SAAUA,IAEZC,EAAIC,QAAUvK,EAEF,MAARA,GACFsK,EAAIE,WAKV,SAASqN,EAAUxZ,EAAQC,GACzB,IAAItC,EAAO1C,OAAO0C,KAAKqC,GAEvB,GAAI/E,OAAO6C,sBAAuB,CAChC,IAAIoC,EAAUjF,OAAO6C,sBAAsBkC,GACvCC,IAAgBC,EAAUA,EAAQC,QAAO,SAAUC,GACrD,OAAOnF,OAAOoF,yBAAyBL,EAAQI,GAAKjD,eAEtDQ,EAAK2C,KAAKC,MAAM5C,EAAMuC,GAGxB,OAAOvC,EAGT,SAAS8b,EAAgBhc,GACvB,IAAK,IAAI7B,EAAI,EAAGA,EAAI6E,UAAU9E,OAAQC,IAAK,CACzC,IAAI2B,EAAyB,MAAhBkD,UAAU7E,GAAa6E,UAAU7E,GAAK,GAE/CA,EAAI,EACN4d,EAAUve,OAAOsC,IAAS,GAAMmD,SAAQ,SAAUzD,GAChDF,EAAgBU,EAAQR,EAAKM,EAAON,OAE7BhC,OAAO0F,0BAChB1F,OAAO2F,iBAAiBnD,EAAQxC,OAAO0F,0BAA0BpD,IAEjEic,EAAUve,OAAOsC,IAASmD,SAAQ,SAAUzD,GAC1ChC,OAAOiC,eAAeO,EAAQR,EAAKhC,OAAOoF,yBAAyB9C,EAAQN,OAKjF,OAAOQ,EAGT,IAAIwE,EAAO,CAITG,OAAQ,SAAgBxD,EAAM4S,GAC5B,IAAIxQ,EAAUP,UAAU9E,OAAS,QAAsBsF,IAAjBR,UAAU,GAAmBA,UAAU,GAAK,GAC9EiZ,EAAiB1Y,EAAQ2Y,MACzBA,OAA2B,IAAnBD,GAAoCA,EAEhD,IAAK,IAAIzc,KAAO2B,EACd,KAAI+a,GAAiB,SAAR1c,IAIT2B,EAAK3B,KAASuU,EAAQvU,GACxB,OAAO,EAIX,IAAK,IAAI2c,KAAQpI,EACf,KAAImI,GAAkB,SAATC,IAIThb,EAAKgb,KAAUpI,EAAQoI,GACzB,OAAO,EAIX,OAAO,GAMT1X,OAAQ,SAAgBlG,GACtB,OAAO,YAAcA,IAAgC,iBAAfA,EAAM4C,MAM9Cib,WAAY,SAAoB7d,GAC9B,OAAOpB,MAAMC,QAAQmB,KAA4B,IAAjBA,EAAML,QAAgBsG,EAAKC,OAAOlG,EAAM,MAS1EyN,QAAS,SAAiB7K,EAAMyR,GAC9B,IAAK,IAAIpT,KAAOoT,EACd,GAAY,SAARpT,GAIA2B,EAAK3B,KAASoT,EAAMpT,GACtB,OAAO,EAIX,OAAO,GAMT6c,YAAa,SAAqB9V,EAAM+V,GACtC,IAGIC,EAHAC,EAAS,CAACR,EAAgB,GAAIzV,IAE9BkW,EAAc5f,EAA2Byf,GAG7C,IACE,IAAKG,EAAYpe,MAAOke,EAAUE,EAAYlf,KAAKe,MAAO,CACxD,IAaIoe,EAbAC,EAAMJ,EAAQhe,MAEd2D,EAAOrC,EAAyB8c,EAAK,CAAC,SAAU,UAEhDC,EAAiB7U,EAAM1B,MAAMsW,GAC7BE,EAAiB,YAAeD,EAAgB,GAChDhX,EAAQiX,EAAe,GACvB1X,EAAM0X,EAAe,GAErB7d,EAAO,GACPlC,EAAI,EAEJggB,EAAcjgB,EAA2B2f,GAG7C,IACE,IAAKM,EAAYze,MAAOqe,EAAUI,EAAYvf,KAAKe,MAAO,CACxD,IAAIuK,EAAO6T,EAAQne,MACfL,EAAS2K,EAAK1H,KAAKjD,OACnBkD,EAAStE,EAGb,GAFAA,GAAKoB,EAED0H,EAAMxE,QAAUA,GAAU+D,EAAI/D,QAAUA,EAASlD,EACnDV,OAAOuf,OAAOlU,EAAM3G,GACpBlD,EAAK6D,KAAKgG,QAKZ,GAAIjD,EAAMxE,OAASA,EAASlD,GAAUiH,EAAI/D,OAASA,GAAU+D,EAAI/D,SAAWA,GAAqB,IAAXA,EACpFpC,EAAK6D,KAAKgG,OADZ,CAQA,IAAImU,EAASnU,EACTnD,OAAS,EACTb,OAAQ,EAEZ,GAAIM,EAAI/D,OAASA,EAASlD,EAAQ,CAChC,IAAI+e,EAAM9X,EAAI/D,OAASA,EACvByD,EAAQmX,EAAgB,GAAIgB,EAAQ,CAClC7b,KAAM6b,EAAO7b,KAAKvD,MAAMqf,KAE1BD,EAAShB,EAAgB,GAAIgB,EAAQ,CACnC7b,KAAM6b,EAAO7b,KAAKvD,MAAM,EAAGqf,KAI/B,GAAIrX,EAAMxE,OAASA,EAAQ,CACzB,IAAI8b,EAAOtX,EAAMxE,OAASA,EAE1BsE,EAASsW,EAAgB,GAAIgB,EAAQ,CACnC7b,KAAM6b,EAAO7b,KAAKvD,MAAM,EAAGsf,KAE7BF,EAAShB,EAAgB,GAAIgB,EAAQ,CACnC7b,KAAM6b,EAAO7b,KAAKvD,MAAMsf,KAI5B1f,OAAOuf,OAAOC,EAAQ9a,GAElBwD,GACF1G,EAAK6D,KAAK6C,GAGZ1G,EAAK6D,KAAKma,GAENnY,GACF7F,EAAK6D,KAAKgC,KAGd,MAAOjG,GACPke,EAAYte,EAAEI,GACd,QACAke,EAAYpe,IAGd8d,EAASxd,GAEX,MAAOJ,GACP6d,EAAYje,EAAEI,GACd,QACA6d,EAAY/d,IAGd,OAAO8d,IAIX,SAASW,EAAU5a,EAAQC,GACzB,IAAItC,EAAO1C,OAAO0C,KAAKqC,GAEvB,GAAI/E,OAAO6C,sBAAuB,CAChC,IAAIoC,EAAUjF,OAAO6C,sBAAsBkC,GACvCC,IAAgBC,EAAUA,EAAQC,QAAO,SAAUC,GACrD,OAAOnF,OAAOoF,yBAAyBL,EAAQI,GAAKjD,eAEtDQ,EAAK2C,KAAKC,MAAM5C,EAAMuC,GAGxB,OAAOvC,EAGT,SAASkd,GAAgBpd,GACvB,IAAK,IAAI7B,EAAI,EAAGA,EAAI6E,UAAU9E,OAAQC,IAAK,CACzC,IAAI2B,EAAyB,MAAhBkD,UAAU7E,GAAa6E,UAAU7E,GAAK,GAE/CA,EAAI,EACNgf,EAAU3f,OAAOsC,IAAS,GAAMmD,SAAQ,SAAUzD,GAChDF,EAAgBU,EAAQR,EAAKM,EAAON,OAE7BhC,OAAO0F,0BAChB1F,OAAO2F,iBAAiBnD,EAAQxC,OAAO0F,0BAA0BpD,IAEjEqd,EAAU3f,OAAOsC,IAASmD,SAAQ,SAAUzD,GAC1ChC,OAAOiC,eAAeO,EAAQR,EAAKhC,OAAOoF,yBAAyB9C,EAAQN,OAKjF,OAAOQ,EAkZT,SAASqd,GAAU9a,EAAQC,GACzB,IAAItC,EAAO1C,OAAO0C,KAAKqC,GAEvB,GAAI/E,OAAO6C,sBAAuB,CAChC,IAAIoC,EAAUjF,OAAO6C,sBAAsBkC,GACvCC,IAAgBC,EAAUA,EAAQC,QAAO,SAAUC,GACrD,OAAOnF,OAAOoF,yBAAyBL,EAAQI,GAAKjD,eAEtDQ,EAAK2C,KAAKC,MAAM5C,EAAMuC,GAGxB,OAAOvC,EAGT,SAASod,GAAgBtd,GACvB,IAAK,IAAI7B,EAAI,EAAGA,EAAI6E,UAAU9E,OAAQC,IAAK,CACzC,IAAI2B,EAAyB,MAAhBkD,UAAU7E,GAAa6E,UAAU7E,GAAK,GAE/CA,EAAI,EACNkf,GAAU7f,OAAOsC,IAAS,GAAMmD,SAAQ,SAAUzD,GAChDF,EAAgBU,EAAQR,EAAKM,EAAON,OAE7BhC,OAAO0F,0BAChB1F,OAAO2F,iBAAiBnD,EAAQxC,OAAO0F,0BAA0BpD,IAEjEud,GAAU7f,OAAOsC,IAASmD,SAAQ,SAAUzD,GAC1ChC,OAAOiC,eAAeO,EAAQR,EAAKhC,OAAOoF,yBAAyB9C,EAAQN,OAKjF,OAAOQ,EAGT,IAAIud,GAAiB,CAInBC,YAAa,SAAqBla,EAAQyG,GACxC,IAAIxG,EAAUP,UAAU9E,OAAS,QAAsBsF,IAAjBR,UAAU,GAAmBA,UAAU,GAAK,GAClFI,EAAOiK,mBAAmB/J,GAAQ,WAChC,IAAIma,EAAmBla,EAAQma,QAC3BA,OAA+B,IAArBD,GAAsCA,EAChDE,EAAkBpa,EAAQG,MAC1BA,OAA4B,IAApBia,GAAqCA,EAC7CC,EAAiBra,EAAQK,KACzBA,OAA0B,IAAnBga,EAA4B,SAAWA,EAC9C9Z,EAAKP,EAAQO,GACbE,EAAQT,EAAQS,MAChB6Z,EAASta,EAAQsa,OAMrB,GAJIpX,EAAK4O,OAAOtL,KACdA,EAAQ,CAACA,IAGU,IAAjBA,EAAM7L,OAAV,CAIA,IAAI4f,EAAS/T,EAETxD,EADU,YAAeuX,EAAQ,GAClB,GAqBnB,GAhBKha,IAEDA,EADER,EAAOS,UACJT,EAAOS,UACHT,EAAOsD,SAAS1I,OAAS,EAC7BkF,EAAO+B,IAAI7B,EAAQ,IAEnB,CAAC,GAGRua,GAAS,GAGG,MAAVA,IACFA,GAAS,GAGP9V,EAAMC,QAAQlE,GAKhB,GAJK4Z,IACH5Z,EAAKV,EAAO0O,YAAYxO,EAAQQ,IAG9BiE,EAAMmK,YAAYpO,GACpBA,EAAKA,EAAGiB,WACH,CACL,IAAIgZ,EAAiBhW,EAAM1B,MAAMvC,GAE7BqB,EADiB,YAAe4Y,EAAgB,GAC3B,GAErBxO,EAAWnM,EAAOmM,SAASjM,EAAQ6B,GACvC6Y,GAAWpP,OAAOtL,EAAQ,CACxBQ,GAAIA,IAENA,EAAKyL,EAASb,QAIlB,GAAIpG,EAAM8F,QAAQtK,GAAK,CACR,MAATE,IAEAA,EADEQ,EAAKC,OAAO8B,GACN,SAAehJ,GACrB,OAAOiH,EAAKC,OAAOlH,IAEZ+F,EAAO0D,SAAST,GACjB,SAAehJ,GACrB,OAAOiH,EAAKC,OAAOlH,IAAM6F,EAAO4D,SAAS1D,EAAQ/F,IAG3C,SAAeA,GACrB,OAAO6F,EAAO0D,QAAQxD,EAAQ/F,KAKpC,IAAI0gB,EAAiB7a,EAAO2G,MAAMzG,EAAQ,CACxCQ,GAAIA,EAAGI,KACPF,MAAOA,EACPJ,KAAMA,EACNF,MAAOA,IAGLgK,EADiB,YAAeuQ,EAAgB,GACzB,GAE3B,IAAIvQ,EAeF,OAdA,IACIwQ,EADS,YAAexQ,EAAO,GACX,GAEpBW,EAAUjL,EAAOiL,QAAQ/K,EAAQ4a,GACjCC,EAAU/a,EAAOiF,MAAM/E,EAAQQ,EAAIoa,GACvCF,GAAWI,WAAW9a,EAAQ,CAC5BQ,GAAIA,EACJE,MAAOA,EACPJ,KAAMA,EACNF,MAAOA,IAET,IAAIQ,EAAOmK,EAAQK,QACnB5K,EAAKqa,EAAUzZ,EAAK1F,KAAKkF,GAAQA,EAMrC,IAAIyJ,EAAajJ,EAAK0G,OAAOtH,GACzByP,EAAQzP,EAAGA,EAAG5F,OAAS,GAE3B,GAAKwF,IAASN,EAAOqP,KAAKnP,EAAQ,CAChCQ,GAAI6J,IADN,CAMA,IACI0Q,EADAC,EAAczhB,EAA2BkN,GAG7C,IACE,IAAKuU,EAAYjgB,MAAOggB,EAAUC,EAAY/gB,KAAKe,MAAO,CACxD,IAAIigB,EAAQF,EAAQ9f,MAEhBigB,EAAQ7Q,EAAWH,OAAO+F,GAE9BA,IACAjQ,EAAOR,MAAM,CACXiU,KAAM,cACN7S,KAAMsa,EACNjY,KAAMgY,KAGV,MAAO3f,GACP0f,EAAY9f,EAAEI,GACd,QACA0f,EAAY5f,IAGd,GAAImf,EAAQ,CACV,IAAI7Y,EAAQ5B,EAAO+B,IAAI7B,EAAQQ,GAE3BkB,GACFgZ,GAAWH,OAAOva,EAAQ0B,UAUlCyZ,UAAW,SAAmBnb,GAC5B,IAAIC,EAAUP,UAAU9E,OAAS,QAAsBsF,IAAjBR,UAAU,GAAmBA,UAAU,GAAK,GAClFI,EAAOiK,mBAAmB/J,GAAQ,WAChC,IAAIob,EAAenb,EAAQO,GACvBA,OAAsB,IAAjB4a,EAA0Bpb,EAAOS,UAAY2a,EAClDC,EAAiBpb,EAAQK,KACzBA,OAA0B,IAAnB+a,EAA4B,SAAWA,EAC9CC,EAAkBrb,EAAQG,MAC1BA,OAA4B,IAApBkb,GAAqCA,EAC7C5a,EAAQT,EAAQS,MAQpB,GANa,MAATA,IACFA,EAAQU,EAAKuG,OAAOnH,GAAM+a,GAAUvb,EAAQQ,GAAM,SAAUvG,GAC1D,OAAO6F,EAAO0D,QAAQxD,EAAQ/F,KAI7BuG,EAiBL,IAbA,IAAIkI,EAAU5I,EAAO2G,MAAMzG,EAAQ,CACjCQ,GAAIA,EACJE,MAAOA,EACPJ,KAAMA,EACNF,MAAOA,IASAob,EAAK,EAAGC,EAPF5hB,MAAMY,KAAKiO,GAAS,SAAUY,GAC3C,IACIrI,EADQ,YAAeqI,EAAM,GACnB,GAEd,OAAOxJ,EAAOiL,QAAQ/K,EAAQiB,MAGOua,EAAKC,EAAU7gB,OAAQ4gB,IAAM,CAClE,IACI5a,EADU6a,EAAUD,GACLpQ,QAEnB,GAAIxK,EAAKhG,OAAS,EAChB,MAAM,IAAIgN,MAAM,+BAA+BsC,OAAOtJ,EAAM,+CAG9D,IAAI8a,EAAkB5b,EAAOmD,KAAKjD,EAAQoB,EAAK0G,OAAOlH,IAElD+a,EAAmB,YAAeD,EAAiB,GACnD5T,EAAS6T,EAAiB,GAC1BtR,EAAasR,EAAiB,GAE9B1L,EAAQrP,EAAKA,EAAKhG,OAAS,GAC3BA,EAASkN,EAAOxE,SAAS1I,OAE7B,GAAe,IAAXA,EAAc,CAChB,IAAIghB,EAASxa,EAAK1F,KAAK2O,GACvBqQ,GAAWmB,UAAU7b,EAAQ,CAC3BQ,GAAII,EACJ6G,GAAImU,EACJxb,MAAOA,IAETsa,GAAWoB,YAAY9b,EAAQ,CAC7BQ,GAAI6J,EACJjK,MAAOA,SAEJ,GAAc,IAAV6P,EACTyK,GAAWmB,UAAU7b,EAAQ,CAC3BQ,GAAII,EACJ6G,GAAI4C,EACJjK,MAAOA,SAEJ,GAAI6P,IAAUrV,EAAS,EAAG,CAC/B,IAAImhB,EAAU3a,EAAK1F,KAAK2O,GAExBqQ,GAAWmB,UAAU7b,EAAQ,CAC3BQ,GAAII,EACJ6G,GAAIsU,EACJ3b,MAAOA,QAEJ,CACL,IAAI4b,EAAY5a,EAAK1F,KAAKkF,GAEtBqb,EAAW7a,EAAK1F,KAAK2O,GAEzBqQ,GAAWI,WAAW9a,EAAQ,CAC5BQ,GAAIwb,EACJ5b,MAAOA,IAETsa,GAAWmB,UAAU7b,EAAQ,CAC3BQ,GAAII,EACJ6G,GAAIwU,EACJ7b,MAAOA,UAWjB8b,WAAY,SAAoBlc,GAC9B,IAAIC,EAAUP,UAAU9E,OAAS,QAAsBsF,IAAjBR,UAAU,GAAmBA,UAAU,GAAK,GAClFI,EAAOiK,mBAAmB/J,GAAQ,WAChC,IAAIU,EAAQT,EAAQS,MAChByb,EAAelc,EAAQO,GACvBA,OAAsB,IAAjB2b,EAA0Bnc,EAAOS,UAAY0b,EAClDC,EAAoBnc,EAAQma,QAC5BA,OAAgC,IAAtBgC,GAAuCA,EACjDC,EAAkBpc,EAAQG,MAC1BA,OAA4B,IAApBic,GAAqCA,EAC7CC,EAAiBrc,EAAQK,KACzBA,OAA0B,IAAnBgc,EAA4B,SAAWA,EAElD,GAAK9b,EAAL,CAIA,GAAa,MAATE,EACF,GAAIU,EAAKuG,OAAOnH,GAAK,CACnB,IAAI+b,EAAkBzc,EAAOgI,OAAO9H,EAAQQ,GAExCsH,EADkB,YAAeyU,EAAiB,GACzB,GAE7B7b,EAAQ,SAAezG,GACrB,OAAO6N,EAAOxE,SAAS0E,SAAS/N,SAGlCyG,EAAQ,SAAezG,GACrB,OAAO6F,EAAO0D,QAAQxD,EAAQ/F,IASpC,IAJKmgB,GAAW3V,EAAMC,QAAQlE,KAC5BA,EAAKV,EAAO0O,YAAYxO,EAAQQ,IAG9BiE,EAAMC,QAAQlE,GAChB,GAAIiE,EAAMmK,YAAYpO,GACpBA,EAAKA,EAAGiB,WACH,CACL,IAAI+a,EAAiB/X,EAAM1B,MAAMvC,GAE7BqB,EADiB,YAAe2a,EAAgB,GAC3B,GAErBvQ,EAAWnM,EAAOmM,SAASjM,EAAQ6B,GACvC6Y,GAAWpP,OAAOtL,EAAQ,CACxBQ,GAAIA,IAENA,EAAKyL,EAASb,QAEI,MAAdnL,EAAQO,IACVka,GAAWH,OAAOva,EAAQQ,GAKhC,IAAIic,EAAiB3c,EAAO2G,MAAMzG,EAAQ,CACxCQ,GAAIA,EACJE,MAAOA,EACPN,MAAOA,EACPE,KAAMA,IAGJ6K,EADkB,YAAesR,EAAgB,GACvB,GAE1B1e,EAAO+B,EAAO6G,SAAS3G,EAAQ,CACjCQ,GAAIA,EACJE,MAAOA,EACPN,MAAOA,EACPE,KAAMA,IAGR,GAAK6K,GAAYpN,EAAjB,CAIA,IAAI2e,EAAW,YAAevR,EAAS,GACnClI,EAAOyZ,EAAS,GAChB9b,EAAO8b,EAAS,GAEhBC,EAAS,YAAe5e,EAAM,GAC9B+I,EAAW6V,EAAO,GAClB5V,EAAW4V,EAAO,GAEtB,GAAoB,IAAhB/b,EAAKhG,QAAoC,IAApBmM,EAASnM,OAAlC,CAIA,IAqBIgZ,EACAD,EAtBAnB,EAAUpR,EAAK1F,KAAKqL,GACpB6V,EAAaxb,EAAKyJ,OAAOjK,EAAMmG,GAC/B8V,EAAoBzb,EAAK8S,UAAUtT,EAAMmG,GACzChG,EAASlH,MAAMY,KAAKqF,EAAOiB,OAAOf,EAAQ,CAC5CQ,GAAII,KACF,SAAUiJ,GAIZ,OAHa,YAAeA,EAAO,GACpB,MAGdvP,MAAMsiB,EAAWhiB,QAAQN,MAAM,GAAI,GAGlCwiB,EAAgBhd,EAAOC,MAAMC,EAAQ,CACvCQ,GAAII,EACJN,KAAM,UACNI,MAAO,SAAezG,GACpB,OAAO8G,EAAOiH,SAAS/N,IAAMgK,EAAQC,UAAUjK,IAA4B,IAAtBA,EAAEqJ,SAAS1I,UAGhEmiB,EAAWD,GAAiBhd,EAAOiL,QAAQ/K,EAAQ8c,EAAc,IAKrE,GAAI5b,EAAKC,OAAO8B,IAAS/B,EAAKC,OAAO2F,GAAW,CAC9C,IAAIlI,EAAOrC,EAAyB0G,EAAM,CAAC,SAE3C0Q,EAAW7M,EAASjJ,KAAKjD,OACzBgZ,EAAahV,MACR,KAAIqF,EAAQC,UAAUjB,KAASgB,EAAQC,UAAU4C,GAMtD,MAAM,IAAIc,MAAM,kCAAkCsC,OAAOtJ,EAAM,iEAAiEsJ,OAAOgG,KAAKC,UAAUlN,GAAO,KAAKiH,OAAOgG,KAAKC,UAAUrJ,KALpLlI,EAAOrC,EAAyB0G,EAAM,CAAC,aAE3C0Q,EAAW7M,EAASxD,SAAS1I,OAC7BgZ,EAAahV,EAOVie,GACHnC,GAAWmB,UAAU7b,EAAQ,CAC3BQ,GAAII,EACJ6G,GAAI+K,EACJpS,MAAOA,IAMP2c,GACFrC,GAAWoB,YAAY9b,EAAQ,CAC7BQ,GAAIuc,EAAS5R,QACb/K,MAAOA,IAQP6D,EAAQC,UAAU4C,IAAahH,EAAOqF,QAAQnF,EAAQ8G,IAAa5F,EAAKC,OAAO2F,IAA+B,KAAlBA,EAASjJ,KACvG6c,GAAWoB,YAAY9b,EAAQ,CAC7BQ,GAAIuG,EACJ3G,MAAOA,IAGTJ,EAAOR,MAAM,CACXiU,KAAM,aACN7S,KAAM4R,EACNmB,SAAUA,EACVC,WAAYA,IAIZmJ,GACFA,EAAS3R,eAQfyQ,UAAW,SAAmB7b,EAAQC,GACpCH,EAAOiK,mBAAmB/J,GAAQ,WAChC,IAAIyH,EAAKxH,EAAQwH,GACbuV,EAAe/c,EAAQO,GACvBA,OAAsB,IAAjBwc,EAA0Bhd,EAAOS,UAAYuc,EAClDC,EAAiBhd,EAAQK,KACzBA,OAA0B,IAAnB2c,EAA4B,SAAWA,EAC9CC,EAAmBjd,EAAQG,MAC3BA,OAA6B,IAArB8c,GAAsCA,EAC9Cxc,EAAQT,EAAQS,MAEpB,GAAKF,EAAL,CAIa,MAATE,IACFA,EAAQU,EAAKuG,OAAOnH,GAAM+a,GAAUvb,EAAQQ,GAAM,SAAUvG,GAC1D,OAAO6F,EAAO0D,QAAQxD,EAAQ/F,KAkBlC,IAdA,IAAIkjB,EAAQrd,EAAOiL,QAAQ/K,EAAQyH,GAC/B2V,EAAUtd,EAAO2G,MAAMzG,EAAQ,CACjCQ,GAAIA,EACJE,MAAOA,EACPJ,KAAMA,EACNF,MAAOA,IASAid,EAAM,EAAGC,EAPHzjB,MAAMY,KAAK2iB,GAAS,SAAUG,GAC3C,IACItc,EADS,YAAesc,EAAO,GACpB,GAEf,OAAOzd,EAAOiL,QAAQ/K,EAAQiB,MAGSoc,EAAMC,EAAW1iB,OAAQyiB,IAAO,CACvE,IACIzc,EADU0c,EAAWD,GACNjS,QACfoH,EAAU2K,EAAMhS,QAEA,IAAhBvK,EAAKhG,QACPoF,EAAOR,MAAM,CACXiU,KAAM,YACN7S,KAAMA,EACN4R,QAASA,IAKf2K,EAAM/R,aAOV0Q,YAAa,SAAqB9b,GAChC,IAAIC,EAAUP,UAAU9E,OAAS,QAAsBsF,IAAjBR,UAAU,GAAmBA,UAAU,GAAK,GAClFI,EAAOiK,mBAAmB/J,GAAQ,WAChC,IAAIwd,EAAoBvd,EAAQma,QAC5BA,OAAgC,IAAtBoD,GAAuCA,EACjDC,EAAmBxd,EAAQG,MAC3BA,OAA6B,IAArBqd,GAAsCA,EAC9CC,EAAiBzd,EAAQK,KACzBA,OAA0B,IAAnBod,EAA4B,SAAWA,EAC9CC,EAAgB1d,EAAQO,GACxBA,OAAuB,IAAlBmd,EAA2B3d,EAAOS,UAAYkd,EACnDjd,EAAQT,EAAQS,MAEpB,GAAKF,EAAL,CAIa,MAATE,IACFA,EAAQU,EAAKuG,OAAOnH,GAAM+a,GAAUvb,EAAQQ,GAAM,SAAUvG,GAC1D,OAAO6F,EAAO0D,QAAQxD,EAAQ/F,MAI7BmgB,GAAW3V,EAAMC,QAAQlE,KAC5BA,EAAKV,EAAO0O,YAAYxO,EAAQQ,IAgBlC,IAbA,IAAIod,EAAS9d,EAAO2G,MAAMzG,EAAQ,CAChCQ,GAAIA,EACJE,MAAOA,EACPJ,KAAMA,EACNF,MAAOA,IASAyd,EAAM,EAAGC,EAPHjkB,MAAMY,KAAKmjB,GAAQ,SAAUG,GAC1C,IACI9c,EADS,YAAe8c,EAAO,GACpB,GAEf,OAAOje,EAAOiL,QAAQ/K,EAAQiB,MAGS4c,EAAMC,EAAWljB,OAAQijB,IAAO,CACvE,IACIjd,EADUkd,EAAWD,GACNzS,QAEnB,GAAIxK,EAAM,CACR,IAAIod,EAAele,EAAOmD,KAAKjD,EAAQY,GAEnCqC,EADgB,YAAe+a,EAAc,GACxB,GAEzBhe,EAAOR,MAAM,CACXiU,KAAM,cACN7S,KAAMA,EACNqC,KAAMA,WAUhBgb,SAAU,SAAkBje,EAAQsP,GAClC,IAAIrP,EAAUP,UAAU9E,OAAS,QAAsBsF,IAAjBR,UAAU,GAAmBA,UAAU,GAAK,GAClFI,EAAOiK,mBAAmB/J,GAAQ,WAChC,IAAIU,EAAQT,EAAQS,MAChBwd,EAAgBje,EAAQO,GACxBA,OAAuB,IAAlB0d,EAA2Ble,EAAOS,UAAYyd,EACnDC,EAAoBle,EAAQma,QAC5BA,OAAgC,IAAtB+D,GAAuCA,EACjDC,EAAkBne,EAAQK,KAC1BA,OAA2B,IAApB8d,EAA6B,SAAWA,EAC/CC,EAAiBpe,EAAQqe,MACzBA,OAA2B,IAAnBD,GAAoCA,EAC5CE,EAAmBte,EAAQG,MAC3BA,OAA6B,IAArBme,GAAsCA,EAElD,GAAK/d,EAAL,CAcA,GAVa,MAATE,IACFA,EAAQU,EAAKuG,OAAOnH,GAAM+a,GAAUvb,EAAQQ,GAAM,SAAUvG,GAC1D,OAAO6F,EAAO0D,QAAQxD,EAAQ/F,MAI7BmgB,GAAW3V,EAAMC,QAAQlE,KAC5BA,EAAKV,EAAO0O,YAAYxO,EAAQQ,IAG9B8d,GAAS7Z,EAAMC,QAAQlE,GAAK,CAC9B,IAAIuN,EAAWjO,EAAOiO,SAAS/N,EAAQQ,EAAI,CACzCyK,SAAU,WAGRuT,EAAiB/Z,EAAM1B,MAAMvC,GAC7Bie,EAAiB,YAAeD,EAAgB,GAChDlc,EAAQmc,EAAe,GACvB5c,EAAM4c,EAAe,GAErBC,EAAqB,WAATpe,EAAoB,SAAW,UAC/Coa,GAAWI,WAAW9a,EAAQ,CAC5BQ,GAAIqB,EACJnB,MAAOA,EACPJ,KAAMoe,EACNte,MAAOA,IAETsa,GAAWI,WAAW9a,EAAQ,CAC5BQ,GAAI8B,EACJ5B,MAAOA,EACPJ,KAAMoe,EACNte,MAAOA,IAETI,EAAKuN,EAAS3C,QAEI,MAAdnL,EAAQO,IACVka,GAAWH,OAAOva,EAAQQ,GAI9B,IAMIme,EANAC,EAAcrlB,EAA2BuG,EAAO2G,MAAMzG,EAAQ,CAChEQ,GAAIA,EACJE,MAAOA,EACPJ,KAAMA,EACNF,MAAOA,KAIT,IACE,IAAKwe,EAAY7jB,MAAO4jB,EAAUC,EAAY3kB,KAAKe,MAAO,CACxD,IAAI6jB,EAAgB,YAAeF,EAAQ1jB,MAAO,GAC9CgI,EAAO4b,EAAc,GACrBje,EAAOie,EAAc,GAErBjL,EAAa,GACbC,EAAgB,GAEpB,GAAoB,IAAhBjT,EAAKhG,OAAT,CAIA,IAAK,IAAIkkB,KAAKxP,EACF,aAANwP,GAA0B,SAANA,GAIpBxP,EAAMwP,KAAO7b,EAAK6b,KACpBlL,EAAWkL,GAAK7b,EAAK6b,GACrBjL,EAAciL,GAAKxP,EAAMwP,IAIa,IAAtC5kB,OAAO0C,KAAKiX,GAAejZ,QAC7BoF,EAAOR,MAAM,CACXiU,KAAM,WACN7S,KAAMA,EACNgT,WAAYA,EACZC,cAAeA,MAIrB,MAAOvY,GACPsjB,EAAY1jB,EAAEI,GACd,QACAsjB,EAAYxjB,UAQlB0f,WAAY,SAAoB9a,GAC9B,IAAIC,EAAUP,UAAU9E,OAAS,QAAsBsF,IAAjBR,UAAU,GAAmBA,UAAU,GAAK,GAClFI,EAAOiK,mBAAmB/J,GAAQ,WAChC,IAAI+e,EAAkB9e,EAAQK,KAC1BA,OAA2B,IAApBye,EAA6B,SAAWA,EAC/CC,EAAmB/e,EAAQG,MAC3BA,OAA6B,IAArB4e,GAAsCA,EAC9Cte,EAAQT,EAAQS,MAChBue,EAAgBhf,EAAQO,GACxBA,OAAuB,IAAlBye,EAA2Bjf,EAAOS,UAAYwe,EACnDC,EAAkBjf,EAAQkf,OAC1BA,OAA6B,IAApBD,EAA6B,EAAIA,EAC1CE,EAAkBnf,EAAQof,OAC1BA,OAA6B,IAApBD,GAAqCA,EAclD,GAZa,MAAT1e,IACFA,EAAQ,SAAezG,GACrB,OAAO6F,EAAO0D,QAAQxD,EAAQ/F,KAI9BwK,EAAMC,QAAQlE,KAChBA,EAAK8e,GAAYtf,EAAQQ,IAKvBY,EAAKuG,OAAOnH,GAAK,CACnB,IAAII,EAAOJ,EACPkB,EAAQ5B,EAAO4B,MAAM1B,EAAQY,GAE7B2e,EAAkBzf,EAAOgI,OAAO9H,EAAQY,GAExCkH,EADkB,YAAeyX,EAAiB,GACzB,GAE7B7e,EAAQ,SAAezG,GACrB,OAAOA,IAAM6N,GAGfqX,EAASzd,EAAMd,KAAKhG,OAASgG,EAAKhG,OAAS,EAC3C4F,EAAKkB,EACL2d,GAAS,EAGX,GAAK7e,EAAL,CAIA,IAAIgf,EAAY1f,EAAOmM,SAASjM,EAAQQ,EAAI,CAC1CyK,SAAU,aAGRwU,EAAkB3f,EAAO2G,MAAMzG,EAAQ,CACzCQ,GAAIA,EACJE,MAAOA,EACPJ,KAAMA,EACNF,MAAOA,IAGLsf,EADkB,YAAeD,EAAiB,GACxB,GAE9B,GAAKC,EAAL,CAIA,IAAIC,EAAY7f,EAAOqP,KAAKnP,EAAQ,CAClCQ,GAAIA,EACJF,KAAM,YAIR,IAAKF,GAASuf,EAAW,CACvB,IAAIC,EAAa,YAAeD,EAAW,GACvCE,EAAWD,EAAW,GACtBE,EAAWF,EAAW,GAE1B,GAAI3b,EAAQC,UAAU2b,IAAa7f,EAAO0D,SAASmc,GAAW,CAC5D,IAAIte,EAAQzB,EAAOyB,MAAMvB,EAAQ8f,GAEjC,IAAKve,EAAO,CACV,IAGIwe,EAAY3e,EAAK1F,KAAKokB,GAC1BpF,GAAWR,YAAYla,EAJZ,CACTnC,KAAM,IAG6B,CACnC2C,GAAIuf,EACJ3f,MAAOA,IAETmB,EAAQzB,EAAO4B,MAAM1B,EAAQ+f,GAG/Bvf,EAAKe,EACL8d,GAAS,EAIXF,EADoB3e,EAAGI,KAAKhG,OAASklB,EAASllB,OACrB,EACzBykB,GAAS,EAGX,IAcIW,EAdAC,EAAWngB,EAAOmM,SAASjM,EAAQQ,GACnC8J,EAAQ9J,EAAGI,KAAKhG,OAASukB,EAGzBe,EADW,YAAeR,EAAS,GACZ,GAEvBS,EAAa3f,EAAGI,KAAKtG,MAAM,EAAGgQ,GAC9BqJ,EAAsB,IAAXwL,EAAe3e,EAAG1C,OAAS0C,EAAGI,KAAK0J,GAtCtC,EAwCR8V,EAAc7mB,EAA2BuG,EAAOiB,OAAOf,EAAQ,CACjEQ,GAAI2f,EACJtf,SAAS,EACTT,MAAOA,KAIT,IACE,IAAKggB,EAAYrlB,MAAOilB,EAAUI,EAAYnmB,KAAKe,MAAO,CACxD,IAAIqlB,EAAgB,YAAeL,EAAQ/kB,MAAO,GAC9CgI,EAAOod,EAAc,GACrBC,EAASD,EAAc,GAEvB/B,GAAQ,EAEZ,GAAIgC,EAAO1lB,OAASslB,EAAYtlB,QAA4B,IAAlB0lB,EAAO1lB,SAAiBwF,GAASN,EAAOsE,OAAOpE,EAAQiD,GAC/F,MAGF,IAAIsd,EAASf,EAAUrU,QACnBpG,EAAQjF,EAAOiF,MAAM/E,EAAQugB,EAAQD,GAEzC,GAAIjB,IAAWG,IAAc1f,EAAOmF,OAAOjF,EAAQugB,EAAQD,GAAS,CAClEhC,GAAQ,EAER,IAAI1K,EAAarX,EAAyB0G,EAAM,CAAC,OAAQ,aAEzDjD,EAAOR,MAAM,CACXiU,KAAM,aACN7S,KAAM0f,EACN3M,SAAUA,EACVC,WAAYA,IAIhBD,EAAW2M,EAAOA,EAAO1lB,OAAS,IAAM0jB,GAASvZ,EAAQ,EAAI,IAE/D,MAAOzJ,GACP8kB,EAAYllB,EAAEI,GACd,QACA8kB,EAAYhlB,IAGd,GAAkB,MAAd6E,EAAQO,GAAY,CACtB,IAAIggB,EAAUP,EAAS9U,SAAWrL,EAAO+B,IAAI7B,EAAQ,IAErD0a,GAAWH,OAAOva,EAAQwgB,GAG5BhB,EAAUpU,QACV6U,EAAS7U,cAObqV,WAAY,SAAoBzgB,EAAQsP,GACtC,IAAIrP,EAAUP,UAAU9E,OAAS,QAAsBsF,IAAjBR,UAAU,GAAmBA,UAAU,GAAK,GAE7E7F,MAAMC,QAAQwV,KACjBA,EAAQ,CAACA,IAGX,IAGIoR,EAHAzkB,EAAM,GAEN0kB,EAAcpnB,EAA2B+V,GAG7C,IACE,IAAKqR,EAAY5lB,MAAO2lB,EAAUC,EAAY1mB,KAAKe,MAAO,CACxD,IAAIkB,EAAMwkB,EAAQzlB,MAClBgB,EAAIC,GAAO,MAEb,MAAOZ,GACPqlB,EAAYzlB,EAAEI,GACd,QACAqlB,EAAYvlB,IAGdsf,GAAWuD,SAASje,EAAQ/D,EAAKgE,IAOnC2gB,YAAa,SAAqB5gB,EAAQC,GACxCH,EAAOiK,mBAAmB/J,GAAQ,WAChC,IAAI6gB,EAAkB5gB,EAAQK,KAC1BA,OAA2B,IAApBugB,EAA6B,SAAWA,EAC/CC,EAAkB7gB,EAAQqe,MAC1BA,OAA4B,IAApBwC,GAAqCA,EAC7CC,EAAmB9gB,EAAQG,MAC3BA,OAA6B,IAArB2gB,GAAsCA,EAC9CC,EAAgB/gB,EAAQO,GACxBA,OAAuB,IAAlBwgB,EAA2BhhB,EAAOS,UAAYugB,EACnDtgB,EAAQT,EAAQS,MAEpB,GAAKF,EAAL,CAIa,MAATE,IACFA,EAAQU,EAAKuG,OAAOnH,GAAM+a,GAAUvb,EAAQQ,GAAM,SAAUvG,GAC1D,OAAO6F,EAAO0D,QAAQxD,EAAQ/F,KAI9BmH,EAAKuG,OAAOnH,KACdA,EAAKV,EAAOgC,MAAM9B,EAAQQ,IAuC5B,IApCA,IAAIuN,EAAWtJ,EAAMC,QAAQlE,GAAMV,EAAOiO,SAAS/N,EAAQQ,GAAM,KAC7DkI,EAAU5I,EAAO2G,MAAMzG,EAAQ,CACjCQ,GAAIA,EACJE,MAAOA,EACPJ,KAAMA,EACNF,MAAOA,IASL6gB,EAAQ,SAAelW,GACzB,IAAInK,EAAOmK,EAAQK,QAEf8V,EAAgBphB,EAAOmD,KAAKjD,EAAQY,GAEpCqC,EADgB,YAAeie,EAAe,GACzB,GAErBpf,EAAQhC,EAAOgC,MAAM9B,EAAQY,GAE7B0d,GAASvQ,IACXjM,EAAQ2C,EAAM8S,aAAaxJ,EAAS5C,QAASrJ,IAG/C4Y,GAAWS,UAAUnb,EAAQ,CAC3BQ,GAAIsB,EACJpB,MAAO,SAAezG,GACpB,OAAOgJ,EAAKK,SAAS0E,SAAS/N,IAEhCmG,MAAOA,KAIF+gB,EAAM,EAAGC,EA7BHvnB,MAAMY,KAAKiO,GAAS,SAAU2Y,GAC3C,IACIpgB,EADS,YAAeogB,EAAO,GACpB,GAEf,OAAOvhB,EAAOiL,QAAQ/K,EAAQiB,MAyBSkgB,EAAMC,EAAWxmB,OAAQumB,IAAO,CAGvEF,EAFcG,EAAWD,IAKvBpT,GACFA,EAAS3C,aASfkW,UAAW,SAAmBthB,EAAQqD,GACpC,IAAIpD,EAAUP,UAAU9E,OAAS,QAAsBsF,IAAjBR,UAAU,GAAmBA,UAAU,GAAK,GAClFI,EAAOiK,mBAAmB/J,GAAQ,WAChC,IAAIuhB,EAAkBthB,EAAQK,KAC1BA,OAA2B,IAApBihB,EAA6B,SAAWA,EAC/CC,EAAkBvhB,EAAQqe,MAC1BA,OAA4B,IAApBkD,GAAqCA,EAC7CC,EAAmBxhB,EAAQG,MAC3BA,OAA6B,IAArBqhB,GAAsCA,EAC9C/gB,EAAQT,EAAQS,MAChBghB,EAAgBzhB,EAAQO,GACxBA,OAAuB,IAAlBkhB,EAA2B1hB,EAAOS,UAAYihB,EAEvD,GAAKlhB,EAAL,CAkBA,GAda,MAATE,IAEAA,EADEU,EAAKuG,OAAOnH,GACN+a,GAAUvb,EAAQQ,GACjBR,EAAO0D,SAASL,GACjB,SAAepJ,GACrB,OAAO6F,EAAO4D,SAAS1D,EAAQ/F,IAAMiH,EAAKC,OAAOlH,IAG3C,SAAeA,GACrB,OAAO6F,EAAO0D,QAAQxD,EAAQ/F,KAKhCqkB,GAAS7Z,EAAMC,QAAQlE,GAAK,CAC9B,IAAImhB,EAAiBld,EAAM1B,MAAMvC,GAC7BohB,EAAiB,YAAeD,EAAgB,GAChDrf,EAAQsf,EAAe,GACvB/f,EAAM+f,EAAe,GAErB7T,EAAWjO,EAAOiO,SAAS/N,EAAQQ,EAAI,CACzCyK,SAAU,WAEZyP,GAAWI,WAAW9a,EAAQ,CAC5BQ,GAAIqB,EACJnB,MAAOA,EACPN,MAAOA,IAETsa,GAAWI,WAAW9a,EAAQ,CAC5BQ,GAAI8B,EACJ5B,MAAOA,EACPN,MAAOA,IAETI,EAAKuN,EAAS3C,QAEI,MAAdnL,EAAQO,IACVka,GAAWH,OAAOva,EAAQQ,GAe9B,IAXA,IAWSqhB,EAAM,EAAGC,EAXNjoB,MAAMY,KAAKqF,EAAO2G,MAAMzG,EAAQ,CAC1CQ,GAAIA,EACJE,MAAOV,EAAO0D,SAASL,GAAW,SAAUpJ,GAC1C,OAAO6F,EAAO0D,QAAQxD,EAAQ/F,IAC5B,SAAUA,GACZ,OAAO6F,EAAOqE,SAASlK,IAEzBqG,KAAM,SACNF,MAAOA,KAGyByhB,EAAMC,EAAOlnB,OAAQinB,IAAO,CAC5D,IACIE,EADY,YAAeD,EAAOD,GAAM,GACnB,GAErBG,EAAIvd,EAAMC,QAAQlE,GAAMiE,EAAM8S,aAAa/W,EAAIV,EAAOgC,MAAM9B,EAAQ+hB,IAAavhB,EAErF,GAAKwhB,EAAL,CAIA,IAAItZ,EAAU7O,MAAMY,KAAKqF,EAAO2G,MAAMzG,EAAQ,CAC5CQ,GAAIwhB,EACJthB,MAAOA,EACPJ,KAAMA,EACNF,MAAOA,KAGLsI,EAAQ9N,OAAS,GACnB,WACE,IACIoI,EADW,YAAe0F,EAAS,GAClB,GAEjBpD,EAAOoD,EAAQA,EAAQ9N,OAAS,GAGhC6P,EADS,YAAezH,EAAO,GACZ,GAGnB4H,EADQ,YAAetF,EAAM,GACZ,GAEjBsX,EAAaxb,EAAKC,OAAOoJ,EAAWG,GAAYxJ,EAAK0G,OAAO2C,GAAarJ,EAAKyJ,OAAOJ,EAAWG,GAChG9I,EAAQhC,EAAOgC,MAAM9B,EAAQyK,EAAWG,GACxCqX,EAAkBniB,EAAOmD,KAAKjD,EAAQ4c,GAGtCsF,EADmB,YAAeD,EAAiB,GACrB,GAE9B3X,EAAQsS,EAAWhiB,OAAS,EAC5BunB,EAAc/gB,EAAK1F,KAAKkP,EAAStQ,MAAM,EAAGgQ,IAE1C8X,EAAUpI,GAAgB,GAAI3W,EAAS,CACzCC,SAAU,KAGZoX,GAAWR,YAAYla,EAAQoiB,EAAS,CACtC5hB,GAAI2hB,EACJ/hB,MAAOA,IAETsa,GAAWmB,UAAU7b,EAAQ,CAC3BQ,GAAIsB,EACJpB,MAAO,SAAezG,GACpB,OAAOioB,EAAW5e,SAAS0E,SAAS/N,IAEtCwN,GAAI0a,EAAYjY,OAAO,GACvB9J,MAAOA,IApCX,WAgDNkf,GAAc,SAAqBtf,EAAQ8B,GAC7C,GAAI2C,EAAMmK,YAAY9M,GACpB,OAAOA,EAAML,OAEb,IAAI4gB,EAAiB5d,EAAM1B,MAAMjB,GAE7BD,EADiB,YAAewgB,EAAgB,GAC3B,GAErBpW,EAAWnM,EAAOmM,SAASjM,EAAQ6B,GAIvC,OAHA6Y,GAAWpP,OAAOtL,EAAQ,CACxBQ,GAAIsB,IAECmK,EAASb,SAIhBmQ,GAAY,SAAmBvb,EAAQY,GACzC,IAAI0hB,EAAgBxiB,EAAOmD,KAAKjD,EAAQY,GAEpCqC,EADgB,YAAeqf,EAAe,GACzB,GAEzB,OAAO,SAAUroB,GACf,OAAOA,IAAMgJ,IAIjB,SAASsf,GAAUtjB,EAAQC,GACzB,IAAItC,EAAO1C,OAAO0C,KAAKqC,GAEvB,GAAI/E,OAAO6C,sBAAuB,CAChC,IAAIoC,EAAUjF,OAAO6C,sBAAsBkC,GACvCC,IAAgBC,EAAUA,EAAQC,QAAO,SAAUC,GACrD,OAAOnF,OAAOoF,yBAAyBL,EAAQI,GAAKjD,eAEtDQ,EAAK2C,KAAKC,MAAM5C,EAAMuC,GAGxB,OAAOvC,EA2tBT,SAAS4lB,GAAUvjB,EAAQC,GACzB,IAAItC,EAAO1C,OAAO0C,KAAKqC,GAEvB,GAAI/E,OAAO6C,sBAAuB,CAChC,IAAIoC,EAAUjF,OAAO6C,sBAAsBkC,GACvCC,IAAgBC,EAAUA,EAAQC,QAAO,SAAUC,GACrD,OAAOnF,OAAOoF,yBAAyBL,EAAQI,GAAKjD,eAEtDQ,EAAK2C,KAAKC,MAAM5C,EAAMuC,GAGxB,OAAOvC,EAuBT,IAAI8d,GApBJ,SAAyBhe,GACvB,IAAK,IAAI7B,EAAI,EAAGA,EAAI6E,UAAU9E,OAAQC,IAAK,CACzC,IAAI2B,EAAyB,MAAhBkD,UAAU7E,GAAa6E,UAAU7E,GAAK,GAE/CA,EAAI,EACN2nB,GAAUtoB,OAAOsC,IAAS,GAAMmD,SAAQ,SAAUzD,GAChDF,EAAgBU,EAAQR,EAAKM,EAAON,OAE7BhC,OAAO0F,0BAChB1F,OAAO2F,iBAAiBnD,EAAQxC,OAAO0F,0BAA0BpD,IAEjEgmB,GAAUtoB,OAAOsC,IAASmD,SAAQ,SAAUzD,GAC1ChC,OAAOiC,eAAeO,EAAQR,EAAKhC,OAAOoF,yBAAyB9C,EAAQN,OAKjF,OAAOQ,EAGQ+lB,CAAgB,GA/vET,CAItBtO,UAAW,SAAmBnU,EAAQiU,GACpCjU,EAAOsD,SAAW,YAAYtD,EAAOsD,UACrC,IAAI7C,EAAYT,EAAOS,WAAa,YAAYT,EAAOS,WAEvD,OAAQwT,EAAGR,MACT,IAAK,cAED,IAAI7S,EAAOqT,EAAGrT,KACVqC,EAAOgR,EAAGhR,KACV6E,EAAS3E,EAAK2E,OAAO9H,EAAQY,GAC7BqP,EAAQrP,EAAKA,EAAKhG,OAAS,GAG/B,GAFAkN,EAAOxE,SAASsO,OAAO3B,EAAO,EAAGhN,GAE7BxC,EAAW,CACb,IACIiiB,EADAC,EAAcppB,EAA2BkL,EAAMyT,OAAOzX,IAG1D,IACE,IAAKkiB,EAAY5nB,MAAO2nB,EAAUC,EAAY1oB,KAAKe,MAAO,CACxD,IAAI4nB,EAAgB,YAAeF,EAAQznB,MAAO,GAC9CyG,EAAQkhB,EAAc,GAG1BniB,EAFUmiB,EAAc,IAEP5d,EAAMmP,UAAUzS,EAAOuS,IAE1C,MAAO3Y,IACPqnB,EAAYznB,EAAEI,IACd,QACAqnB,EAAYvnB,KAIhB,MAGJ,IAAK,cAED,IAAI8f,EAAQjH,EAAGrT,KACX9C,EAASmW,EAAGnW,OACZD,EAAOoW,EAAGpW,KAEVod,EAAQ9X,EAAKoC,KAAKvF,EAAQkb,GAE1B9Y,EAAS6Y,EAAMpd,KAAKvD,MAAM,EAAGwD,GAE7ByD,EAAQ0Z,EAAMpd,KAAKvD,MAAMwD,GAI7B,GAFAmd,EAAMpd,KAAOuE,EAASvE,EAAO0D,EAEzBd,EAAW,CACb,IACIoiB,EADAC,EAAcvpB,EAA2BkL,EAAMyT,OAAOzX,IAG1D,IACE,IAAKqiB,EAAY/nB,MAAO8nB,EAAUC,EAAY7oB,KAAKe,MAAO,CACxD,IAAI+nB,EAAgB,YAAeF,EAAQ5nB,MAAO,GAC9CslB,EAASwC,EAAc,GAG3BtiB,EAFWsiB,EAAc,IAEP/d,EAAMmP,UAAUoM,EAAQtM,IAE5C,MAAO3Y,IACPwnB,EAAY5nB,EAAEI,IACd,QACAwnB,EAAY1nB,KAIhB,MAGJ,IAAK,aAED,IAAIklB,EAASrM,EAAGrT,KAEZoiB,EAAS7f,EAAKkC,IAAIrF,EAAQsgB,GAE1BvZ,EAAW3F,EAAKuF,SAAS2Z,GACzBviB,EAAOoF,EAAKkC,IAAIrF,EAAQ+G,GAExBkc,EAAU9f,EAAK2E,OAAO9H,EAAQsgB,GAE9B4C,EAAS5C,EAAOA,EAAO1lB,OAAS,GAEpC,GAAIsG,EAAKC,OAAO6hB,IAAW9hB,EAAKC,OAAOpD,GACrCA,EAAKF,MAAQmlB,EAAOnlB,SACf,IAAKqD,EAAKC,OAAO6hB,IAAY9hB,EAAKC,OAAOpD,GAK9C,MAAM,IAAI6J,MAAM,kDAAoDsC,OAAOoW,EAAQ,uCAAuCpW,OAAO8Y,EAAQ,KAAK9Y,OAAOnM,IAJrJ,IAAIolB,GAEHA,EAAiBplB,EAAKuF,UAAU/D,KAAKC,MAAM2jB,EAAgB,YAAmBH,EAAO1f,WAOxF,GAFA2f,EAAQ3f,SAASsO,OAAOsR,EAAQ,GAE5BziB,EAAW,CACb,IACI2iB,EADAC,EAAc9pB,EAA2BkL,EAAMyT,OAAOzX,IAG1D,IACE,IAAK4iB,EAAYtoB,MAAOqoB,EAAUC,EAAYppB,KAAKe,MAAO,CACxD,IAAIsoB,EAAgB,YAAeF,EAAQnoB,MAAO,GAC9CulB,EAAU8C,EAAc,GAG5B7iB,EAFY6iB,EAAc,IAEPte,EAAMmP,UAAUqM,EAASvM,IAE9C,MAAO3Y,IACP+nB,EAAYnoB,EAAEI,IACd,QACA+nB,EAAYjoB,KAIhB,MAGJ,IAAK,YAED,IAAImoB,EAAStP,EAAGrT,KACZ4R,EAAUyB,EAAGzB,QAEjB,GAAIpR,EAAK6F,WAAWsc,EAAQ/Q,GAC1B,MAAM,IAAI5K,MAAM,uBAAuBsC,OAAOqZ,EAAQ,mBAAmBrZ,OAAOsI,EAAS,gDAG3F,IAAIgR,EAASrgB,EAAKkC,IAAIrF,EAAQujB,GAE1BE,EAAWtgB,EAAK2E,OAAO9H,EAAQujB,GAE/BG,EAAUH,EAAOA,EAAO3oB,OAAS,GAOrC6oB,EAASngB,SAASsO,OAAO8R,EAAS,GAElC,IAAIC,EAAWviB,EAAK+S,UAAUoP,EAAQtP,GAClC2P,EAAYzgB,EAAKkC,IAAIrF,EAAQoB,EAAK0G,OAAO6b,IACzCE,EAAWF,EAASA,EAAS/oB,OAAS,GAG1C,GAFAgpB,EAAUtgB,SAASsO,OAAOiS,EAAU,EAAGL,GAEnC/iB,EAAW,CACb,IACIqjB,EADAC,EAAcxqB,EAA2BkL,EAAMyT,OAAOzX,IAG1D,IACE,IAAKsjB,EAAYhpB,MAAO+oB,EAAUC,EAAY9pB,KAAKe,MAAO,CACxD,IAAIgpB,EAAgB,YAAeF,EAAQ7oB,MAAO,GAC9CgpB,EAAUD,EAAc,GAG5BvjB,EAFYujB,EAAc,IAEPhf,EAAMmP,UAAU8P,EAAShQ,IAE9C,MAAO3Y,IACPyoB,EAAY7oB,EAAEI,IACd,QACAyoB,EAAY3oB,KAIhB,MAGJ,IAAK,cAED,IAAI8oB,EAASjQ,EAAGrT,KACZujB,GAAUD,EAAOA,EAAOtpB,OAAS,GAQrC,GANeuI,EAAK2E,OAAO9H,EAAQkkB,GAE1B5gB,SAASsO,OAAOuS,GAAS,GAI9B1jB,EAAW,CACb,IACI2jB,GADAC,GAAc9qB,EAA2BkL,EAAMyT,OAAOzX,IAG1D,IACE,IAAK4jB,GAAYtpB,MAAOqpB,GAAUC,GAAYpqB,KAAKe,MAAO,CACxD,IAAIspB,GAAgB,YAAeF,GAAQnpB,MAAO,GAC9CspB,GAAUD,GAAc,GACxBE,GAAQF,GAAc,GAEtBlO,GAASpR,EAAMmP,UAAUoQ,GAAStQ,GAEtC,GAAiB,MAAbxT,GAA+B,MAAV2V,GACvB3V,EAAU+jB,IAASpO,OACd,CACL,IAKIqO,GALAC,QAAQ,EAERhpB,QAAO,EAEPipB,GAAcprB,EAA2B4J,EAAK4P,MAAM/S,IAGxD,IACE,IAAK2kB,GAAY5pB,MAAO0pB,GAAUE,GAAY1qB,KAAKe,MAAO,CACxD,IAAI4pB,GAAgB,YAAeH,GAAQxpB,MAAO,GAC9ChB,GAAI2qB,GAAc,GAClB3jB,GAAI2jB,GAAc,GAEtB,IAAiC,IAA7BxjB,EAAKmI,QAAQtI,GAAGijB,GAEb,CACLxoB,GAAO,CAACzB,GAAGgH,IACX,MAHAyjB,GAAQ,CAACzqB,GAAGgH,KAMhB,MAAO3F,IACPqpB,GAAYzpB,EAAEI,IACd,QACAqpB,GAAYvpB,IAGVspB,IACFH,GAAQ3jB,KAAO8jB,GAAM,GACrBH,GAAQzmB,OAAS4mB,GAAM,GAAG7mB,KAAKjD,QACtBc,IACT6oB,GAAQ3jB,KAAOlF,GAAK,GACpB6oB,GAAQzmB,OAAS,GAEjB2C,EAAY,OAIlB,MAAOnF,IACP+oB,GAAYnpB,EAAEI,IACd,QACA+oB,GAAYjpB,KAIhB,MAGJ,IAAK,cAED,IAAIypB,GAAS5Q,EAAGrT,KACZkkB,GAAU7Q,EAAGnW,OACbinB,GAAQ9Q,EAAGpW,KAEXmnB,GAAS7hB,EAAKoC,KAAKvF,EAAQ6kB,IAE3BI,GAAUD,GAAOnnB,KAAKvD,MAAM,EAAGwqB,IAE/BI,GAASF,GAAOnnB,KAAKvD,MAAMwqB,GAAUC,GAAMnqB,QAI/C,GAFAoqB,GAAOnnB,KAAOonB,GAAUC,GAEpBzkB,EAAW,CACb,IACI0kB,GADAC,GAAc7rB,EAA2BkL,EAAMyT,OAAOzX,IAG1D,IACE,IAAK2kB,GAAYrqB,MAAOoqB,GAAUC,GAAYnrB,KAAKe,MAAO,CACxD,IAAIqqB,GAAgB,YAAeF,GAAQlqB,MAAO,GAC9CqqB,GAAUD,GAAc,GAG5B5kB,EAFY4kB,GAAc,IAEPrgB,EAAMmP,UAAUmR,GAASrR,IAE9C,MAAO3Y,IACP8pB,GAAYlqB,EAAEI,IACd,QACA8pB,GAAYhqB,KAIhB,MAGJ,IAAK,WAED,IAAImqB,GAAStR,EAAGrT,KACZiT,GAAgBI,EAAGJ,cAEvB,GAAsB,IAAlB0R,GAAO3qB,OACT,MAAM,IAAIgN,MAAM,2CAGlB,IAAI4d,GAASriB,EAAKkC,IAAIrF,EAAQulB,IAE9B,IAAK,IAAIE,MAAS5R,GAAe,CAC/B,GAAc,aAAV4R,IAAkC,SAAVA,GAC1B,MAAM,IAAI7d,MAAM,mBAAoBsC,OAAOub,GAAO,yBAGpD,IAAIxqB,GAAQ4Y,GAAc4R,IAEb,MAATxqB,UACKuqB,GAAOC,IAEdD,GAAOC,IAASxqB,GAIpB,MAGJ,IAAK,gBAED,IAAIoZ,GAAiBJ,EAAGJ,cAExB,GAAsB,MAAlBQ,GACF5T,EAAY4T,QACP,GAAiB,MAAb5T,EAAmB,CAC5B,IAAKgE,EAAMC,QAAQ2P,IACjB,MAAM,IAAIzM,MAAM,mEAAqEsC,OAAOgG,KAAKC,UAAUkE,IAAiB,yCAG9H5T,EAAY4T,QAEZna,OAAOuf,OAAOhZ,EAAW4T,IAG3B,MAGJ,IAAK,aAED,IAAIqR,GAASzR,EAAGrT,KACZ+S,GAAWM,EAAGN,SACdC,GAAaK,EAAGL,WAEpB,GAAsB,IAAlB8R,GAAO9qB,OACT,MAAM,IAAIgN,MAAM,kDAAoDsC,OAAOwb,GAAQ,6CAGrF,IAKIC,GALAC,GAASziB,EAAKkC,IAAIrF,EAAQ0lB,IAE1BG,GAAW1iB,EAAK2E,OAAO9H,EAAQ0lB,IAE/BI,GAAUJ,GAAOA,GAAO9qB,OAAS,GAGrC,GAAIsG,EAAKC,OAAOykB,IAAS,CACvB,IAAIG,GAAWH,GAAO/nB,KAAKvD,MAAM,EAAGqZ,IAEhCqS,GAAUJ,GAAO/nB,KAAKvD,MAAMqZ,IAEhCiS,GAAO/nB,KAAOkoB,GACdJ,GAAU7L,GAAgB,GAAI8L,GAAQ,GAAIhS,GAAY,CACpD/V,KAAMmoB,SAEH,CACL,IAAIC,GAAWL,GAAOtiB,SAAShJ,MAAM,EAAGqZ,IAEpCuS,GAAUN,GAAOtiB,SAAShJ,MAAMqZ,IAEpCiS,GAAOtiB,SAAW2iB,GAClBN,GAAU7L,GAAgB,GAAI8L,GAAQ,GAAIhS,GAAY,CACpDtQ,SAAU4iB,KAMd,GAFAL,GAASviB,SAASsO,OAAOkU,GAAU,EAAG,EAAGH,IAErCllB,EAAW,CACb,IACI0lB,GADAC,GAAc7sB,EAA2BkL,EAAMyT,OAAOzX,IAG1D,IACE,IAAK2lB,GAAYrrB,MAAOorB,GAAUC,GAAYnsB,KAAKe,MAAO,CACxD,IAAIqrB,GAAgB,YAAeF,GAAQlrB,MAAO,GAC9CqrB,GAAUD,GAAc,GAG5B5lB,EAFY4lB,GAAc,IAEPrhB,EAAMmP,UAAUmS,GAASrS,IAE9C,MAAO3Y,IACP8qB,GAAYlrB,EAAEI,IACd,QACA8qB,GAAYhrB,MAQtB4E,EAAOsD,SAAW,YAAYtD,EAAOsD,UAGnCtD,EAAOS,UADLA,EACiB,YAAQA,GAAa,YAAYA,GAAaA,EAE9C,OAq3D+B,GAAIwZ,GAAgB,GAtuBlD,CAIxBsM,SAAU,SAAkBvmB,GAC1B,IAAIC,EAAUP,UAAU9E,OAAS,QAAsBsF,IAAjBR,UAAU,GAAmBA,UAAU,GAAK,GAC9E8mB,EAAiBvmB,EAAQ0B,KACzBA,OAA0B,IAAnB6kB,EAA4B,SAAWA,EAC9C/lB,EAAYT,EAAOS,UAEvB,GAAKA,EAEE,GAAa,WAATkB,EACT+Y,GAAWH,OAAOva,EAAQS,EAAUgB,aAC/B,GAAa,UAATE,EACT+Y,GAAWH,OAAOva,EAAQS,EAAUmB,YAC/B,GAAa,UAATD,EAAkB,CAC3B,IAAI8kB,EAAiBhiB,EAAM1B,MAAMtC,GAC7BimB,EAAiB,YAAeD,EAAgB,GAChDnkB,EAAQokB,EAAe,GAE3BhM,GAAWH,OAAOva,EAAQsC,QACrB,GAAa,QAATX,EAAgB,CACzB,IAAIglB,EAAiBliB,EAAM1B,MAAMtC,GAC7BmmB,EAAiB,YAAeD,EAAgB,GAChD9kB,EAAM+kB,EAAe,GAEzBlM,GAAWH,OAAOva,EAAQ6B,KAO9BglB,SAAU,SAAkB7mB,GAC1B,IAAIS,EAAYT,EAAOS,UAEnBA,GACFT,EAAOR,MAAM,CACXiU,KAAM,gBACNG,WAAYnT,EACZoT,cAAe,QAQrBiT,KAAM,SAAc9mB,GAClB,IAAIC,EAAUP,UAAU9E,OAAS,QAAsBsF,IAAjBR,UAAU,GAAmBA,UAAU,GAAK,GAC9Ee,EAAYT,EAAOS,UACnBsmB,EAAqB9mB,EAAQ+B,SAC7BA,OAAkC,IAAvB+kB,EAAgC,EAAIA,EAC/CC,EAAiB/mB,EAAQ0C,KACzBA,OAA0B,IAAnBqkB,EAA4B,YAAcA,EACjDC,EAAoBhnB,EAAQY,QAC5BA,OAAgC,IAAtBomB,GAAuCA,EACjDC,EAAiBjnB,EAAQ0B,KACzBA,OAA0B,IAAnBulB,EAA4B,KAAOA,EAE9C,GAAKzmB,EAAL,CAIa,UAATkB,IACFA,EAAO8C,EAAMgS,WAAWhW,GAAa,QAAU,UAGpC,QAATkB,IACFA,EAAO8C,EAAMgS,WAAWhW,GAAa,SAAW,SAGlD,IAAIgB,EAAShB,EAAUgB,OACnBG,EAAQnB,EAAUmB,MAClBulB,EAAO,CACTnlB,SAAUA,EACVW,KAAMA,GAEJ2M,EAAQ,GAEZ,GAAY,MAAR3N,GAAyB,WAATA,EAAmB,CACrC,IAAID,EAAQb,EAAUf,EAAOsC,OAAOpC,EAAQyB,EAAQ0lB,GAAQrnB,EAAOyB,MAAMvB,EAAQyB,EAAQ0lB,GAErFzlB,IACF4N,EAAM7N,OAASC,GAInB,GAAY,MAARC,GAAyB,UAATA,EAAkB,CACpC,IAAI4e,EAAS1f,EAAUf,EAAOsC,OAAOpC,EAAQ4B,EAAOulB,GAAQrnB,EAAOyB,MAAMvB,EAAQ4B,EAAOulB,GAEpF5G,IACFjR,EAAM1N,MAAQ2e,GAIlB7F,GAAW0M,aAAapnB,EAAQsP,KAMlCiL,OAAQ,SAAgBva,EAAQtD,GAC9B,IAAI+D,EAAYT,EAAOS,UAGvB,GAFA/D,EAASoD,EAAOgC,MAAM9B,EAAQtD,GAE1B+D,EACFia,GAAW0M,aAAapnB,EAAQtD,OADlC,CAKA,IAAK+H,EAAMC,QAAQhI,GACjB,MAAM,IAAIkL,MAAM,qIAAqIsC,OAAOgG,KAAKC,UAAUzT,KAG7KsD,EAAOR,MAAM,CACXiU,KAAM,gBACNG,WAAYnT,EACZoT,cAAenX,MAOnB2qB,SAAU,SAAkBrnB,EAAQsP,EAAOrP,GACzC,IAAIQ,EAAYT,EAAOS,UACnB6mB,EAAiBrnB,EAAQ0B,KACzBA,OAA0B,IAAnB2lB,EAA4B,OAASA,EAEhD,GAAK7mB,EAAL,CAIa,UAATkB,IACFA,EAAO8C,EAAMgS,WAAWhW,GAAa,QAAU,UAGpC,QAATkB,IACFA,EAAO8C,EAAMgS,WAAWhW,GAAa,SAAW,SAGlD,IAAIgB,EAAShB,EAAUgB,OACnBG,EAAQnB,EAAUmB,MAClBF,EAAiB,WAATC,EAAoBF,EAASG,EACzC8Y,GAAW0M,aAAapnB,EAAQ,YAAiB,GAAa,WAAT2B,EAAoB,SAAW,QAtKxF,SAAyBjF,GACvB,IAAK,IAAI7B,EAAI,EAAGA,EAAI6E,UAAU9E,OAAQC,IAAK,CACzC,IAAI2B,EAAyB,MAAhBkD,UAAU7E,GAAa6E,UAAU7E,GAAK,GAE/CA,EAAI,EACN0nB,GAAUroB,OAAOsC,IAAS,GAAMmD,SAAQ,SAAUzD,GAChDF,EAAgBU,EAAQR,EAAKM,EAAON,OAE7BhC,OAAO0F,0BAChB1F,OAAO2F,iBAAiBnD,EAAQxC,OAAO0F,0BAA0BpD,IAEjE+lB,GAAUroB,OAAOsC,IAASmD,SAAQ,SAAUzD,GAC1ChC,OAAOiC,eAAeO,EAAQR,EAAKhC,OAAOoF,yBAAyB9C,EAAQN,OAKjF,OAAOQ,EAqJwF6qB,CAAgB,GAAI7lB,EAAO,GAAI4N,OAM9H8X,aAAc,SAAsBpnB,EAAQsP,GAC1C,IAAI7O,EAAYT,EAAOS,UACnB+mB,EAAW,GACXC,EAAW,GAEf,GAAKhnB,EAAL,CAIA,IAAK,IAAIqe,KAAKxP,GACF,WAANwP,GAAkC,MAAhBxP,EAAM7N,SAAmBuD,EAAM3D,OAAOiO,EAAM7N,OAAQhB,EAAUgB,SAAiB,UAANqd,GAAgC,MAAfxP,EAAM1N,QAAkBoD,EAAM3D,OAAOiO,EAAM1N,MAAOnB,EAAUmB,QAAgB,WAANkd,GAAwB,UAANA,GAAiBxP,EAAMwP,KAAOre,EAAUqe,MAC9O0I,EAAS1I,GAAKre,EAAUqe,GACxB2I,EAAS3I,GAAKxP,EAAMwP,IAIpB5kB,OAAO0C,KAAK4qB,GAAU5sB,OAAS,GACjCoF,EAAOR,MAAM,CACXiU,KAAM,gBACNG,WAAY4T,EACZ3T,cAAe4T,OA0jB8E,GArjBhF,CAInBnc,OAAQ,SAAiBtL,GACvB,IAAIC,EAAUP,UAAU9E,OAAS,QAAsBsF,IAAjBR,UAAU,GAAmBA,UAAU,GAAK,GAClFI,EAAOiK,mBAAmB/J,GAAQ,WAChC,IAAI0nB,EAAqBznB,EAAQY,QAC7BA,OAAiC,IAAvB6mB,GAAwCA,EAClDC,EAAiB1nB,EAAQ0C,KACzBA,OAA0B,IAAnBglB,EAA4B,YAAcA,EACjDC,EAAqB3nB,EAAQ+B,SAC7BA,OAAkC,IAAvB4lB,EAAgC,EAAIA,EAC/CC,EAAmB5nB,EAAQG,MAC3BA,OAA6B,IAArBynB,GAAsCA,EAC9CC,EAAgB7nB,EAAQO,GACxBA,OAAuB,IAAlBsnB,EAA2B9nB,EAAOS,UAAYqnB,EACnDC,EAAoB9nB,EAAQma,QAC5BA,OAAgC,IAAtB2N,GAAuCA,EAErD,GAAKvnB,EAAL,CAQA,GAJIiE,EAAMC,QAAQlE,IAAOiE,EAAMmK,YAAYpO,KACzCA,EAAKA,EAAGiB,QAGNuD,EAAM8F,QAAQtK,GAAK,CACrB,IAAIwnB,EAAeloB,EAAOqP,KAAKnP,EAAQ,CACrCQ,GAAIA,EACJF,KAAM,YAGR,IAAKF,GAAS4nB,EAAc,CAI1BxnB,EAHoB,YAAewnB,EAAc,GACpB,OAGxB,CACL,IAAIb,EAAO,CACTxkB,KAAMA,EACNX,SAAUA,GAGZxB,EAAK,CACHiB,OAAQjB,EACRoB,MAHWf,EAAUf,EAAOsC,OAAOpC,EAAQQ,EAAI2mB,IAASrnB,EAAOwC,MAAMtC,EAAQ,IAAMF,EAAOyB,MAAMvB,EAAQQ,EAAI2mB,IAASrnB,EAAO+B,IAAI7B,EAAQ,KAK1Ioa,GAAU,GAId,GAAIhZ,EAAKuG,OAAOnH,GACdka,GAAWoB,YAAY9b,EAAQ,CAC7BQ,GAAIA,EACJJ,MAAOA,SAKX,IAAIqE,EAAMmK,YAAYpO,GAAtB,CAIK4Z,IACH5Z,EAAKV,EAAO0O,YAAYxO,EAAQQ,EAAI,CAClCJ,MAAOA,KAIX,IAAI6nB,EAAiBxjB,EAAM1B,MAAMvC,GAC7B0nB,EAAiB,YAAeD,EAAgB,GAChD3lB,EAAQ4lB,EAAe,GACvBrmB,EAAMqmB,EAAe,GAErBC,EAAaroB,EAAOC,MAAMC,EAAQ,CACpCU,MAAO,SAAezG,GACpB,OAAO6F,EAAO0D,QAAQxD,EAAQ/F,IAEhCuG,GAAI8B,EACJlC,MAAOA,IAEL0O,EAAWhP,EAAOC,MAAMC,EAAQ,CAClCU,MAAO,SAAezG,GACpB,OAAO6F,EAAO0D,QAAQxD,EAAQ/F,IAEhCuG,GAAIqB,EACJzB,MAAOA,IAELgoB,EAAiBD,GAAcrZ,IAAa1N,EAAKC,OAAO8mB,EAAW,GAAIrZ,EAAS,IAChFuZ,EAAejnB,EAAKC,OAAOiB,EAAM1B,KAAMiB,EAAIjB,MAC3C0nB,EAAYloB,EAAQ,KAAON,EAAOqP,KAAKnP,EAAQ,CACjDQ,GAAI8B,EACJhC,KAAM,YAEJioB,EAAUnoB,EAAQ,KAAON,EAAOqP,KAAKnP,EAAQ,CAC/CQ,GAAIqB,EACJvB,KAAM,YAGR,GAAIgoB,EAAW,CACb,IAAIlmB,EAAStC,EAAOsC,OAAOpC,EAAQsC,GAE/BF,GAAU+lB,GAAc/mB,EAAK6F,WAAWkhB,EAAW,GAAI/lB,EAAOxB,QAChE0B,EAAQF,GAIZ,GAAImmB,EAAS,CACX,IAAIhnB,EAAQzB,EAAOyB,MAAMvB,EAAQ6B,GAE7BN,GAASuN,GAAY1N,EAAK6F,WAAW6H,EAAS,GAAIvN,EAAMX,QAC1DiB,EAAMN,GAMV,IACIqJ,EAMA4d,EAPA9f,EAAU,GAGV+f,EAAclvB,EAA2BuG,EAAO2G,MAAMzG,EAAQ,CAChEQ,GAAIA,EACJJ,MAAOA,KAIT,IACE,IAAKqoB,EAAY1tB,MAAOytB,EAAUC,EAAYxuB,KAAKe,MAAO,CACxD,IAAIoP,EAAQoe,EAAQvtB,MAEhBytB,EAAU,YAAete,EAAO,GAChCnH,EAAOylB,EAAQ,GACf9nB,EAAO8nB,EAAQ,GAEf9d,GAA6C,IAAjCxJ,EAAKmI,QAAQ3I,EAAMgK,MAI9BxK,GAASN,EAAOsE,OAAOpE,EAAQiD,KAAU7B,EAAK8T,SAAStU,EAAM0B,EAAM1B,QAAUQ,EAAK8T,SAAStU,EAAMiB,EAAIjB,SACxG8H,EAAQnJ,KAAK6K,GACbQ,EAAWhK,IAGf,MAAOtF,IACPmtB,EAAYvtB,EAAEI,IACd,QACAmtB,EAAYrtB,IAGd,IAAIiQ,EAAWxR,MAAMY,KAAKiO,GAAS,SAAUY,GAC3C,IACIrI,EADS,YAAeqI,EAAM,GACnB,GAEf,OAAOxJ,EAAOiL,QAAQ/K,EAAQiB,MAE5B0nB,EAAW7oB,EAAOmM,SAASjM,EAAQsC,GACnCsmB,EAAS9oB,EAAOmM,SAASjM,EAAQ6B,GAErC,IAAKwmB,IAAiBC,EAAW,CAC/B,IAAI/H,EAASoI,EAASxd,QAElB0d,EAAgB/oB,EAAOyF,KAAKvF,EAAQugB,GAEpCtF,EADgB,YAAe4N,EAAe,GACxB,GAEtB3N,EAAQqF,EAAO3f,KAEf9C,EADSwE,EACOxE,OAEhBD,EAAOod,EAAMpd,KAAKvD,MAAMwD,GAE5BkC,EAAOR,MAAM,CACXiU,KAAM,cACN7S,KAAMsa,EACNpd,OAAQA,EACRD,KAAMA,IAIV,IAAK,IAAIirB,EAAM,EAAGC,EAAa1d,EAAUyd,EAAMC,EAAWnuB,OAAQkuB,IAAO,CACvE,IAEIxI,EAFUyI,EAAWD,GAEJ1d,QAErBsP,GAAWoB,YAAY9b,EAAQ,CAC7BQ,GAAI8f,EACJlgB,MAAOA,IAIX,IAAKmoB,EAAS,CACZ,IAAI/H,GAAUoI,EAAOzd,QAEjB6d,GAAgBlpB,EAAOyF,KAAKvF,EAAQwgB,IAEpCwC,GADgB,YAAegG,GAAe,GACvB,GAEvBzF,GAAS/C,GAAQ5f,KAEjBkkB,GAAUuD,EAAe/lB,EAAMxE,OAAS,EAExCinB,GAAQ/B,GAAOnlB,KAAKvD,MAAMwqB,GAASjjB,EAAI/D,QAE3CkC,EAAOR,MAAM,CACXiU,KAAM,cACN7S,KAAM2iB,GACNzlB,OAAQgnB,GACRjnB,KAAMknB,MAILsD,GAAgBD,GAAkBQ,EAAOzd,SAAWwd,EAASxd,SAChEuP,GAAWwB,WAAWlc,EAAQ,CAC5BQ,GAAIooB,EAAOzd,QACXiP,SAAS,EACTha,MAAOA,IAIX,IAAIsB,GAAQknB,EAAOxd,SAAWud,EAASvd,QAErB,MAAdnL,EAAQO,IAAckB,IACxBgZ,GAAWH,OAAOva,EAAQ0B,UAQhCoC,eAAgB,SAAwB9D,EAAQkD,GAC9C,IAAIjD,EAAUP,UAAU9E,OAAS,QAAsBsF,IAAjBR,UAAU,GAAmBA,UAAU,GAAK,GAClFI,EAAOiK,mBAAmB/J,GAAQ,WAChC,IAAIipB,EAAoBhpB,EAAQma,QAC5BA,OAAgC,IAAtB6O,GAAuCA,EACjDC,EAAmBjpB,EAAQG,MAC3BA,OAA6B,IAArB8oB,GAAsCA,EAC9CC,EAAgBlpB,EAAQO,GACxBA,OAAuB,IAAlB2oB,EAA2BnpB,EAAOS,UAAY0oB,EAEvD,GAAKjmB,EAAStI,QAIT4F,EAAL,CAEO,GAAIiE,EAAMC,QAAQlE,GAKvB,GAJK4Z,IACH5Z,EAAKV,EAAO0O,YAAYxO,EAAQQ,IAG9BiE,EAAMmK,YAAYpO,GACpBA,EAAKA,EAAGiB,WACH,CACL,IAAI2nB,EAAiB3kB,EAAM1B,MAAMvC,GAE7BqB,EADiB,YAAeunB,EAAgB,GAC3B,GAEzB,IAAKhpB,GAASN,EAAOqP,KAAKnP,EAAQ,CAChCQ,GAAIqB,IAEJ,OAGF,IAAIoK,EAAWnM,EAAOmM,SAASjM,EAAQ6B,GACvC6Y,GAAWpP,OAAOtL,EAAQ,CACxBQ,GAAIA,IAENA,EAAKyL,EAASb,aAEPhK,EAAKuG,OAAOnH,KACrBA,EAAKV,EAAOwC,MAAMtC,EAAQQ,IAG5B,GAAKJ,IAASN,EAAOqP,KAAKnP,EAAQ,CAChCQ,GAAIA,IADN,CAQA,IAAI6oB,EAAqBvpB,EAAOC,MAAMC,EAAQ,CAC5CQ,GAAIA,EACJE,MAAO,SAAezG,GACpB,OAAO6F,EAAO4D,SAAS1D,EAAQ/F,IAEjCqG,KAAM,UACNF,MAAOA,IAGT,GAAIipB,EAAoB,CACtB,IACIC,EADsB,YAAeD,EAAoB,GACvB,GAEtC,GAAIvpB,EAAOiF,MAAM/E,EAAQQ,EAAI8oB,GAE3B9oB,EADYV,EAAOyB,MAAMvB,EAAQspB,QAE5B,GAAIxpB,EAAOoF,QAAQlF,EAAQQ,EAAI8oB,GAAc,CAElD9oB,EADaV,EAAOsC,OAAOpC,EAAQspB,IAKvC,IAmDIC,EAnDAC,EAAa1pB,EAAOC,MAAMC,EAAQ,CACpCU,MAAO,SAAezG,GACpB,OAAO6F,EAAO0D,QAAQxD,EAAQ/F,IAEhCuG,GAAIA,EACJJ,MAAOA,IAIL4G,EADc,YAAewiB,EAAY,GACjB,GAExBC,EAAe3pB,EAAOoF,QAAQlF,EAAQQ,EAAIwG,GAC1C0iB,EAAa5pB,EAAOiF,MAAM/E,EAAQQ,EAAIwG,GACtC2iB,GAAcF,GAAgBA,GAAgBC,EAC9CE,GAAYF,EAEZG,EAAe1mB,EAAKH,MAAM,CAC5BM,SAAUJ,GACT,IAECuH,EADe,YAAeof,EAAc,GACnB,GAEzBC,EAAc3mB,EAAKmC,KAAK,CAC1BhC,SAAUJ,GACT,IAEC0H,EADc,YAAekf,EAAa,GACnB,GAEvBphB,EAAU,GAEVqhB,EAAU,SAAiBlgB,GAC7B,IAAImgB,EAAS,YAAengB,EAAO,GAC/B5P,EAAI+vB,EAAO,GACX/oB,EAAI+oB,EAAO,GAEf,QAAIL,GAAcvoB,EAAK6F,WAAWhG,EAAGwJ,IAAcxG,EAAQC,UAAUjK,KAAO+F,EAAOoE,OAAOnK,KAAO+F,EAAO0D,SAASzJ,OAI7G2vB,GAAYxoB,EAAK6F,WAAWhG,EAAG2J,IAAa3G,EAAQC,UAAUjK,KAAO+F,EAAOoE,OAAOnK,KAAO+F,EAAO0D,SAASzJ,KAO5GgwB,EAAc1wB,EAA2B4J,EAAKsD,MAAM,CACtDnD,SAAUJ,GACT,CACDmG,KAAM0gB,KAIR,IACE,IAAKE,EAAYlvB,MAAOwuB,EAAUU,EAAYhwB,KAAKe,MAAO,CACxD,IAAIoP,EAAQmf,EAAQtuB,MAEhBmP,EAAM,GAAGxP,OAAS,GAAKmvB,EAAQ3f,IACjC1B,EAAQnJ,KAAK6K,IAGjB,MAAO9O,IACP2uB,EAAY/uB,EAAEI,IACd,QACA2uB,EAAY7uB,IASd,IANA,IAAI8uB,EAAS,GACTC,EAAU,GACVC,EAAO,GACPC,GAAW,EACXjnB,GAAY,EAEPknB,EAAM,EAAGC,EAAY7hB,EAAS4hB,EAAMC,EAAU3vB,OAAQ0vB,IAAO,CACpE,IACIrnB,EADe,YAAesnB,EAAUD,GAAM,GAC1B,GAEpBrmB,EAAQC,UAAUjB,KAAUjD,EAAO0D,SAAST,IAC9ConB,GAAW,EACXjnB,GAAY,EACZ+mB,EAAQ5qB,KAAK0D,IACJonB,EACTH,EAAO3qB,KAAK0D,GAEZmnB,EAAK7qB,KAAK0D,GAId,IAAIunB,EAAkB1qB,EAAO2G,MAAMzG,EAAQ,CACzCQ,GAAIA,EACJE,MAAO,SAAezG,GACpB,OAAOiH,EAAKC,OAAOlH,IAAM6F,EAAO4D,SAAS1D,EAAQ/F,IAEnDqG,KAAM,UACNF,MAAOA,IAGLqqB,EADkB,YAAeD,EAAiB,GACpB,GAG9BE,EADe,YAAeD,EAAa,GACjB,GAE1BE,EAAgB7qB,EAAOoF,QAAQlF,EAAQQ,EAAIkqB,GAC3CE,EAAc9qB,EAAOiF,MAAM/E,EAAQQ,EAAIkqB,GACvCG,EAAY/qB,EAAOiL,QAAQ/K,EAAQ0pB,EAAatoB,EAAK1F,KAAKsL,GAAaA,GACvE4hB,EAAS9oB,EAAOiL,QAAQ/K,EAAQ4qB,EAAcxpB,EAAK1F,KAAKgvB,GAAcA,GAC1EhQ,GAAWI,WAAW9a,EAAQ,CAC5BQ,GAAIA,EACJE,MAAO,SAAezG,GACpB,OAAOmJ,EAAYtD,EAAO0D,QAAQxD,EAAQ/F,GAAKiH,EAAKC,OAAOlH,IAAM6F,EAAO4D,SAAS1D,EAAQ/F,IAE3FqG,KAAM8C,EAAY,SAAW,UAC7BhD,MAAOA,IAET,IAAIuoB,EAAW7oB,EAAOiL,QAAQ/K,GAAS2qB,GAAiBA,GAAiBC,EAAcxpB,EAAK1F,KAAKgvB,GAAcA,GA0B/G,GAzBAhQ,GAAWR,YAAYla,EAAQkqB,EAAQ,CACrC1pB,GAAImoB,EAASxd,QACbzK,MAAO,SAAezG,GACpB,OAAOiH,EAAKC,OAAOlH,IAAM6F,EAAO4D,SAAS1D,EAAQ/F,IAEnDqG,KAAM,UACNF,MAAOA,IAETsa,GAAWR,YAAYla,EAAQmqB,EAAS,CACtC3pB,GAAIqqB,EAAU1f,QACdzK,MAAO,SAAezG,GACpB,OAAO6F,EAAO0D,QAAQxD,EAAQ/F,IAEhCqG,KAAM,SACNF,MAAOA,IAETsa,GAAWR,YAAYla,EAAQoqB,EAAM,CACnC5pB,GAAIooB,EAAOzd,QACXzK,MAAO,SAAezG,GACpB,OAAOiH,EAAKC,OAAOlH,IAAM6F,EAAO4D,SAAS1D,EAAQ/F,IAEnDqG,KAAM,UACNF,MAAOA,KAGJH,EAAQO,GAAI,CACf,IAAII,EAGFA,EADEwpB,EAAKxvB,OAAS,EACTwG,EAAKuF,SAASiiB,EAAOzd,SACnBgf,EAAQvvB,OAAS,EACnBwG,EAAKuF,SAASkkB,EAAU1f,SAExB/J,EAAKuF,SAASgiB,EAASxd,SAGhC,IAAI2f,GAAOhrB,EAAO+B,IAAI7B,EAAQY,GAE9B8Z,GAAWH,OAAOva,EAAQ8qB,IAG5BnC,EAASvd,QACTyf,EAAUzf,QACVwd,EAAOxd,cAOXpH,WAAY,SAAoBhE,EAAQnC,GACtC,IAAIoC,EAAUP,UAAU9E,OAAS,QAAsBsF,IAAjBR,UAAU,GAAmBA,UAAU,GAAK,GAClFI,EAAOiK,mBAAmB/J,GAAQ,WAChC,IAAI+qB,EAAmB9qB,EAAQG,MAC3BA,OAA6B,IAArB2qB,GAAsCA,EAC9CC,EAAgB/qB,EAAQO,GACxBA,OAAuB,IAAlBwqB,EAA2BhrB,EAAOS,UAAYuqB,EAEvD,GAAKxqB,EAAL,CAQA,GAJIY,EAAKuG,OAAOnH,KACdA,EAAKV,EAAOgC,MAAM9B,EAAQQ,IAGxBiE,EAAMC,QAAQlE,GAChB,GAAIiE,EAAMmK,YAAYpO,GACpBA,EAAKA,EAAGiB,WACH,CACL,IAAII,EAAM4C,EAAM5C,IAAIrB,GAEpB,IAAKJ,GAASN,EAAOqP,KAAKnP,EAAQ,CAChCQ,GAAIqB,IAEJ,OAGF,IAAIoK,EAAWnM,EAAOmM,SAASjM,EAAQ6B,GACvC6Y,GAAWpP,OAAOtL,EAAQ,CACxBQ,GAAIA,EACJJ,MAAOA,IAETI,EAAKyL,EAASb,QACdsP,GAAW0M,aAAapnB,EAAQ,CAC9ByB,OAAQjB,EACRoB,MAAOpB,IAKb,GAAKJ,IAASN,EAAOqP,KAAKnP,EAAQ,CAChCQ,GAAIA,IADN,CAMA,IAAIyqB,EAAMzqB,EACNI,EAAOqqB,EAAIrqB,KACX9C,EAASmtB,EAAIntB,OACjBkC,EAAOR,MAAM,CACXiU,KAAM,cACN7S,KAAMA,EACN9C,OAAQA,EACRD,KAAMA,YA0Cd,SAASqtB,GAAUjsB,EAAQC,GACzB,IAAItC,EAAO1C,OAAO0C,KAAKqC,GAEvB,GAAI/E,OAAO6C,sBAAuB,CAChC,IAAIoC,EAAUjF,OAAO6C,sBAAsBkC,GACvCC,IAAgBC,EAAUA,EAAQC,QAAO,SAAUC,GACrD,OAAOnF,OAAOoF,yBAAyBL,EAAQI,GAAKjD,eAEtDQ,EAAK2C,KAAKC,MAAM5C,EAAMuC,GAGxB,OAAOvC,EAGT,SAASuuB,GAAgBzuB,GACvB,IAAK,IAAI7B,EAAI,EAAGA,EAAI6E,UAAU9E,OAAQC,IAAK,CACzC,IAAI2B,EAAyB,MAAhBkD,UAAU7E,GAAa6E,UAAU7E,GAAK,GAE/CA,EAAI,EACNqwB,GAAUhxB,OAAOsC,IAAS,GAAMmD,SAAQ,SAAUzD,GAChDF,EAAgBU,EAAQR,EAAKM,EAAON,OAE7BhC,OAAO0F,0BAChB1F,OAAO2F,iBAAiBnD,EAAQxC,OAAO0F,0BAA0BpD,IAEjE0uB,GAAUhxB,OAAOsC,IAASmD,SAAQ,SAAUzD,GAC1ChC,OAAOiC,eAAeO,EAAQR,EAAKhC,OAAOoF,yBAAyB9C,EAAQN,OAKjF,OAAOQ,EAOT,IAAI0uB,GAAe,WACjB,IAAIprB,EAAS,CACXsD,SAAU,GACVwB,WAAY,GACZrE,UAAW,KACX+D,MAAO,KACPd,SAAU,WACR,OAAO,GAETU,OAAQ,WACN,OAAO,GAETE,SAAU,aACV9E,MAAO,SAAeyU,GACpB,IACIoX,EADAC,EAAc/xB,EAA2BuG,EAAOuL,SAASrL,IAG7D,IACE,IAAKsrB,EAAYvwB,MAAOswB,EAAUC,EAAYrxB,KAAKe,MAAO,CACxD,IAAIkQ,EAAMmgB,EAAQpwB,MAClBgb,EAAQ9B,UAAUjJ,EAAK+I,IAEzB,MAAO3Y,GACPgwB,EAAYpwB,EAAEI,GACd,QACAgwB,EAAYlwB,IAGd,IACImwB,EADAC,EAAcjyB,EAA2BuG,EAAOqM,UAAUnM,IAG9D,IACE,IAAKwrB,EAAYzwB,MAAOwwB,EAAUC,EAAYvxB,KAAKe,MAAO,CACxD,IAAIsO,EAAOiiB,EAAQtwB,MACnBqb,EAASnC,UAAU7K,EAAM2K,IAE3B,MAAO3Y,GACPkwB,EAAYtwB,EAAEI,GACd,QACAkwB,EAAYpwB,IAGd,IACIqwB,EADAC,EAAcnyB,EAA2BuG,EAAOmO,UAAUjO,IAG9D,IACE,IAAK0rB,EAAY3wB,MAAO0wB,EAAUC,EAAYzxB,KAAKe,MAAO,CACxD,IAAI6O,EAAQ4hB,EAAQxwB,MACpBud,EAASrE,UAAUtK,EAAOoK,IAE5B,MAAO3Y,GACPowB,EAAYxwB,EAAEI,GACd,QACAowB,EAAYtwB,IAGd,IAkBIuwB,EAlBA7hB,EAAM,IAAI2B,IACVmgB,EAAa,GAEbpgB,EAAM,SAAa5K,GACrB,GAAIA,EAAM,CACR,IAAI1E,EAAM0E,EAAKkS,KAAK,KAEfhJ,EAAIgI,IAAI5V,KACX4N,EAAI0B,IAAItP,GACR0vB,EAAWrsB,KAAKqB,MAKlBirB,EAAgB3uB,EAAYmI,IAAIrF,IAAW,GAC3C8rB,EAAgBniB,GAAcsK,GAE9B8X,EAAcxyB,EAA2BsyB,GAG7C,IACE,IAAKE,EAAYhxB,MAAO4wB,EAAUI,EAAY9xB,KAAKe,MAAO,CACxD,IAAI4F,EAAO+qB,EAAQ1wB,MAEnBuQ,EADcpK,EAAK+S,UAAUvT,EAAMqT,KAGrC,MAAO3Y,GACPywB,EAAY7wB,EAAEI,GACd,QACAywB,EAAY3wB,IAGd,IACI4wB,EADAC,EAAc1yB,EAA2BuyB,GAG7C,IACE,IAAKG,EAAYlxB,MAAOixB,EAAUC,EAAYhyB,KAAKe,MAAO,CAExDwQ,EADYwgB,EAAQ/wB,QAGtB,MAAOK,GACP2wB,EAAY/wB,EAAEI,GACd,QACA2wB,EAAY7wB,IAGd8B,EAAY4M,IAAI9J,EAAQ4rB,GACxBlR,GAAWvG,UAAUnU,EAAQiU,GAC7BjU,EAAO8E,WAAWvF,KAAK0U,GACvBnU,EAAO0J,UAAUxJ,GAED,kBAAZiU,EAAGR,OACLzT,EAAOwE,MAAQ,MAGZpH,EAASiI,IAAIrF,KAChB5C,EAAS0M,IAAI9J,GAAQ,GACrBksB,QAAQC,UAAUC,MAAK,WACrBhvB,EAAS0M,IAAI9J,GAAQ,GACrBA,EAAOsE,WACPtE,EAAO8E,WAAa,QAI1BxD,QAAS,SAAiBpF,EAAKjB,GAC7B,IAAIwF,EAAYT,EAAOS,UAEvB,GAAIA,EACF,GAAIgE,EAAM8B,WAAW9F,GACnBia,GAAWuD,SAASje,EAAQ,YAAiB,GAAI9D,EAAKjB,GAAQ,CAC5DyF,MAAOQ,EAAKC,OACZmd,OAAO,QAEJ,CACL,IAAI9Z,EAAQ2mB,GAAgB,GAAIrrB,EAAO0E,MAAMxE,IAAW,GAAI,YAAiB,GAAI9D,EAAKjB,IAEtF+E,EAAOwE,MAAQA,EACfxE,EAAOsE,aAIb7B,eAAgB,SAAwBE,GACtC,IAAIlC,EAAYT,EAAOS,UAEnBA,GAAagE,EAAMmK,YAAYnO,IACjCia,GAAWpP,OAAOtL,EAAQ,CACxB2C,KAAMA,EACN9B,SAAS,KAIf+B,cAAe,SAAuBD,GACpC,IAAIlC,EAAYT,EAAOS,UAEnBA,GAAagE,EAAMmK,YAAYnO,IACjCia,GAAWpP,OAAOtL,EAAQ,CACxB2C,KAAMA,KAIZG,eAAgB,WACd,IAAIrC,EAAYT,EAAOS,UAEnBA,GAAagE,EAAM8B,WAAW9F,IAChCia,GAAWpP,OAAOtL,IAGtBqsB,YAAa,WACX,IAAI5rB,EAAYT,EAAOS,UAEvB,OAAIA,EACK0C,EAAKD,SAASlD,EAAQS,GAGxB,IAEToD,YAAa,WACX6W,GAAWI,WAAW9a,EAAQ,CAC5Bqf,QAAQ,KAGZvb,eAAgB,SAAwBZ,GACtCwX,GAAW5W,eAAe9D,EAAQkD,IAEpCa,WAAY,SAAoBd,GAC9ByX,GAAWR,YAAYla,EAAQiD,IAEjCe,WAAY,SAAoBnG,GAC9B,IAAI4C,EAAYT,EAAOS,UACnB+D,EAAQxE,EAAOwE,MAEnB,GAAI/D,EAAW,CAGb,GAAIgE,EAAMmK,YAAYnO,GAAY,CAChC,IAAI6rB,EAASxsB,EAAOC,MAAMC,EAAQ,CAChCU,MAAO,SAAezG,GACpB,OAAO6F,EAAO4D,SAAS1D,EAAQ/F,IAEjCqG,KAAM,YAGR,GAAIgsB,EAAQ,CACV,IACI5B,EADU,YAAe4B,EAAQ,GACZ,GAEzB,GAAIxsB,EAAOiF,MAAM/E,EAAQS,EAAUgB,OAAQipB,GAAa,CACtD,IAAIhpB,EAAQ5B,EAAOyB,MAAMvB,EAAQ0qB,GACjChQ,GAAW0M,aAAapnB,EAAQ,CAC9ByB,OAAQC,EACRE,MAAOF,MAMf,GAAI8C,EAAO,CACT,IAAIvB,EAAOkoB,GAAgB,CACzBttB,KAAMA,GACL2G,GAEHkW,GAAWR,YAAYla,EAAQiD,QAE/ByX,GAAW1W,WAAWhE,EAAQnC,GAGhCmC,EAAOwE,MAAQ,OAGnBH,cAAe,SAAuB+F,GACpC,IAAImiB,EAAU,YAAeniB,EAAO,GAChCnH,EAAOspB,EAAQ,GACf3rB,EAAO2rB,EAAQ,GAGnB,IAAIrrB,EAAKC,OAAO8B,GAKhB,GAAIgB,EAAQC,UAAUjB,IAAkC,IAAzBA,EAAKK,SAAS1I,OAA7C,CAIE8f,GAAWR,YAAYla,EAHX,CACVnC,KAAM,IAE8B,CACpC2C,GAAII,EAAKsJ,OAAO,GAChB9J,OAAO,SAWX,IALA,IAAIosB,GAAoB1sB,EAAOqE,SAASlB,KAAgBgB,EAAQC,UAAUjB,KAAUjD,EAAO0D,SAAST,IAAkC,IAAzBA,EAAKK,SAAS1I,QAAgBsG,EAAKC,OAAO8B,EAAKK,SAAS,KAAOtD,EAAO0D,SAAST,EAAKK,SAAS,MAGtMrJ,EAAI,EAECY,EAAI,EAAGA,EAAIoI,EAAKK,SAAS1I,OAAQC,IAAKZ,IAAK,CAClD,IAAIwyB,EAASxpB,EAAKK,SAASzI,GACvBkD,EAAOkF,EAAKK,SAASzI,EAAI,GACzB6xB,EAAS7xB,IAAMoI,EAAKK,SAAS1I,OAAS,EAM1C,IALqBsG,EAAKC,OAAOsrB,IAAWxoB,EAAQC,UAAUuoB,IAAWzsB,EAAO0D,SAAS+oB,MAKlED,EACrB9R,GAAWoB,YAAY9b,EAAQ,CAC7BQ,GAAII,EAAKsJ,OAAOjQ,GAChBmG,OAAO,IAETnG,SACK,GAAIgK,EAAQC,UAAUuoB,IAE3B,GAAIzsB,EAAO0D,SAAS+oB,GAClB,GAAY,MAAR1uB,GAAiBmD,EAAKC,OAAOpD,IAS1B,GAAI2uB,EAAQ,CAIjBhS,GAAWR,YAAYla,EAHP,CACdnC,KAAM,IAEkC,CACxC2C,GAAII,EAAKsJ,OAAOjQ,EAAI,GACpBmG,OAAO,IAETnG,SAjBsC,CAItCygB,GAAWR,YAAYla,EAHR,CACbnC,KAAM,IAEiC,CACvC2C,GAAII,EAAKsJ,OAAOjQ,GAChBmG,OAAO,IAETnG,UAcQ,MAAR8D,GAAgBmD,EAAKC,OAAOpD,KAC1BmD,EAAKG,OAAOorB,EAAQ1uB,EAAM,CAC5B6a,OAAO,KAEP8B,GAAWwB,WAAWlc,EAAQ,CAC5BQ,GAAII,EAAKsJ,OAAOjQ,GAChBmG,OAAO,IAETnG,KACuB,KAAd8D,EAAKF,MACd6c,GAAWoB,YAAY9b,EAAQ,CAC7BQ,GAAII,EAAKsJ,OAAOjQ,EAAI,GACpBmG,OAAO,IAETnG,KACSyyB,GAA0B,KAAhBD,EAAO5uB,OAC1B6c,GAAWoB,YAAY9b,EAAQ,CAC7BQ,GAAII,EAAKsJ,OAAOjQ,GAChBmG,OAAO,IAETnG,QAMVsK,WAAY,SAAoBrI,GAC9B,IAAIuE,EAAYT,EAAOS,UAEvB,GAAIA,EACF,GAAIgE,EAAM8B,WAAW9F,GACnBia,GAAW+F,WAAWzgB,EAAQ9D,EAAK,CACjCwE,MAAOQ,EAAKC,OACZmd,OAAO,QAEJ,CACL,IAAI9Z,EAAQ2mB,GAAgB,GAAIrrB,EAAO0E,MAAMxE,IAAW,WAEjDwE,EAAMtI,GACb8D,EAAOwE,MAAQA,EACfxE,EAAOsE,cAKf,OAAOtE,GAOL2J,GAAgB,SAAuBsK,GACzC,OAAQA,EAAGR,MACT,IAAK,cACL,IAAK,cACL,IAAK,WAED,IAAI7S,EAAOqT,EAAGrT,KACd,OAAOQ,EAAKL,OAAOH,GAGvB,IAAK,cAED,IAAIqC,EAAOgR,EAAGhR,KACVqd,EAASrM,EAAGrT,KACZG,EAASK,EAAKL,OAAOuf,GACrB3P,EAAczP,EAAKC,OAAO8B,GAAQ,GAAKpJ,MAAMY,KAAK0I,EAAKsD,MAAMxD,IAAO,SAAUsa,GAChF,IACItc,EADS,YAAesc,EAAO,GACpB,GAEf,OAAO+C,EAAOpW,OAAOjJ,MAEvB,MAAO,GAAGiJ,OAAO,YAAmBnJ,GAAS,YAAmB4P,IAGpE,IAAK,aAED,IAAI4S,EAAStP,EAAGrT,KACZ+O,EAAYvO,EAAKuO,UAAU4T,GAC3BoJ,EAAevrB,EAAKuF,SAAS4c,GACjC,MAAO,GAAGrZ,OAAO,YAAmByF,GAAY,CAACgd,IAGrD,IAAK,YAED,IAAIzI,EAASjQ,EAAGrT,KACZ4R,EAAUyB,EAAGzB,QAEjB,GAAIpR,EAAKC,OAAO6iB,EAAQ1R,GACtB,MAAO,GAGT,IAIIoa,EAJAC,EAAe,GACfC,EAAe,GAEfC,EAAcxzB,EAA2B6H,EAAKuO,UAAUuU,IAG5D,IACE,IAAK6I,EAAYhyB,MAAO6xB,EAAUG,EAAY9yB,KAAKe,MAAO,CACxD,IAAIyU,EAAWmd,EAAQ3xB,MACnBgG,EAAIG,EAAK+S,UAAU1E,EAAUwE,GACjC4Y,EAAattB,KAAK0B,IAEpB,MAAO3F,GACPyxB,EAAY7xB,EAAEI,GACd,QACAyxB,EAAY3xB,IAGd,IACI4xB,EADAC,EAAc1zB,EAA2B6H,EAAKuO,UAAU6C,IAG5D,IACE,IAAKya,EAAYlyB,MAAOiyB,EAAUC,EAAYhzB,KAAKe,MAAO,CACxD,IAAIkyB,EAAYF,EAAQ/xB,MAEpBkyB,EAAK/rB,EAAK+S,UAAU+Y,EAAWjZ,GAEnC6Y,EAAavtB,KAAK4tB,IAEpB,MAAO7xB,GACP2xB,EAAY/xB,EAAEI,GACd,QACA2xB,EAAY7xB,IAGd,MAAO,GAAG8O,OAAO2iB,EAAcC,GAGnC,IAAK,cAED,IAAIjI,EAAS5Q,EAAGrT,KAEZwsB,EAAahsB,EAAKuO,UAAUkV,GAEhC,OAAO,YAAmBuI,GAG9B,IAAK,aAED,IAAI7H,EAAStR,EAAGrT,KAEZysB,EAAUjsB,EAAKL,OAAOwkB,GAEtB+H,EAAWlsB,EAAK1F,KAAK6pB,GACzB,MAAO,GAAGrb,OAAO,YAAmBmjB,GAAU,CAACC,IAGnD,QAEI,MAAO","file":"d3048c20-f37dcf89c1a837641f5f.js","sourcesContent":["import _defineProperty2 from \"/Users/eriksummerfield/dev/e2thex.org/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"/Users/eriksummerfield/dev/e2thex.org/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _regeneratorRuntime from \"/Users/eriksummerfield/dev/e2thex.org/node_modules/@babel/runtime/regenerator\";\nimport \"regenerator-runtime/runtime\";\nimport _slicedToArray from \"/Users/eriksummerfield/dev/e2thex.org/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport isPlainObject from 'is-plain-object';\nimport { reverse } from 'esrever';\nimport { produce, createDraft, finishDraft, isDraft } from 'immer';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nvar DIRTY_PATHS = new WeakMap();\nvar FLUSHING = new WeakMap();\nvar NORMALIZING = new WeakMap();\nvar PATH_REFS = new WeakMap();\nvar POINT_REFS = new WeakMap();\nvar RANGE_REFS = new WeakMap();\n/**\r\n * Constants for string distance checking.\r\n */\n\nvar SPACE = /\\s/;\nvar PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/;\nvar CHAMELEON = /['\\u2018\\u2019]/;\nvar SURROGATE_START = 0xd800;\nvar SURROGATE_END = 0xdfff;\nvar ZERO_WIDTH_JOINER = 0x200d;\n/**\r\n * Get the distance to the end of the first character in a string of text.\r\n */\n\nvar getCharacterDistance = function getCharacterDistance(text) {\n  var offset = 0; // prev types:\n  // SURR: surrogate pair\n  // MOD: modifier (technically also surrogate pair)\n  // ZWJ: zero width joiner\n  // VAR: variation selector\n  // BMP: sequenceable character from basic multilingual plane\n\n  var prev = null;\n  var charCode = text.charCodeAt(0);\n\n  while (charCode) {\n    if (isSurrogate(charCode)) {\n      var modifier = isModifier(charCode, text, offset); // Early returns are the heart of this function, where we decide if previous and current\n      // codepoints should form a single character (in terms of how many of them should selection\n      // jump over).\n\n      if (prev === 'SURR' || prev === 'BMP') {\n        break;\n      }\n\n      offset += 2;\n      prev = modifier ? 'MOD' : 'SURR';\n      charCode = text.charCodeAt(offset); // Absolutely fine to `continue` without any checks because if `charCode` is NaN (which\n      // is the case when out of `text` range), next `while` loop won\"t execute and we\"re done.\n\n      continue;\n    }\n\n    if (charCode === ZERO_WIDTH_JOINER) {\n      offset += 1;\n      prev = 'ZWJ';\n      charCode = text.charCodeAt(offset);\n      continue;\n    }\n\n    if (isBMPEmoji(charCode)) {\n      if (prev && prev !== 'ZWJ' && prev !== 'VAR') {\n        break;\n      }\n\n      offset += 1;\n      prev = 'BMP';\n      charCode = text.charCodeAt(offset);\n      continue;\n    }\n\n    if (isVariationSelector(charCode)) {\n      if (prev && prev !== 'ZWJ') {\n        break;\n      }\n\n      offset += 1;\n      prev = 'VAR';\n      charCode = text.charCodeAt(offset);\n      continue;\n    } // Modifier 'groups up' with what ever character is before that (even whitespace), need to\n    // look ahead.\n\n\n    if (prev === 'MOD') {\n      offset += 1;\n      break;\n    } // If while loop ever gets here, we're done (e.g latin chars).\n\n\n    break;\n  }\n\n  return offset || 1;\n};\n/**\r\n * Get the distance to the end of the first word in a string of text.\r\n */\n\n\nvar getWordDistance = function getWordDistance(text) {\n  var length = 0;\n  var i = 0;\n  var started = false;\n  var char;\n\n  while (char = text.charAt(i)) {\n    var l = getCharacterDistance(char);\n    char = text.slice(i, i + l);\n    var rest = text.slice(i + l);\n\n    if (isWordCharacter(char, rest)) {\n      started = true;\n      length += l;\n    } else if (!started) {\n      length += l;\n    } else {\n      break;\n    }\n\n    i += l;\n  }\n\n  return length;\n};\n/**\r\n * Check if a character is a word character. The `remaining` argument is used\r\n * because sometimes you must read subsequent characters to truly determine it.\r\n */\n\n\nvar isWordCharacter = function isWordCharacter(char, remaining) {\n  if (SPACE.test(char)) {\n    return false;\n  } // Chameleons count as word characters as long as they're in a word, so\n  // recurse to see if the next one is a word character or not.\n\n\n  if (CHAMELEON.test(char)) {\n    var next = remaining.charAt(0);\n    var length = getCharacterDistance(next);\n    next = remaining.slice(0, length);\n    var rest = remaining.slice(length);\n\n    if (isWordCharacter(next, rest)) {\n      return true;\n    }\n  }\n\n  if (PUNCTUATION.test(char)) {\n    return false;\n  }\n\n  return true;\n};\n/**\r\n * Determines if `code` is a surrogate\r\n */\n\n\nvar isSurrogate = function isSurrogate(code) {\n  return SURROGATE_START <= code && code <= SURROGATE_END;\n};\n/**\r\n * Does `code` form Modifier with next one.\r\n *\r\n * https://emojipedia.org/modifiers/\r\n */\n\n\nvar isModifier = function isModifier(code, text, offset) {\n  if (code === 0xd83c) {\n    var next = text.charCodeAt(offset + 1);\n    return next <= 0xdfff && next >= 0xdffb;\n  }\n\n  return false;\n};\n/**\r\n * Is `code` a Variation Selector.\r\n *\r\n * https://codepoints.net/variation_selectors\r\n */\n\n\nvar isVariationSelector = function isVariationSelector(code) {\n  return code <= 0xfe0f && code >= 0xfe00;\n};\n/**\r\n * Is `code` one of the BMP codes used in emoji sequences.\r\n *\r\n * https://emojipedia.org/emoji-zwj-sequences/\r\n */\n\n\nvar isBMPEmoji = function isBMPEmoji(code) {\n  // This requires tiny bit of maintanance, better ideas?\n  // Fortunately it only happens if new Unicode Standard\n  // is released. Fails gracefully if upkeep lags behind,\n  // same way Slate previously behaved with all emojis.\n  return code === 0x2764 || // heart ()\n  code === 0x2642 || // male ()\n  code === 0x2640 || // female ()\n  code === 0x2620 || // scull ()\n  code === 0x2695 || // medical ()\n  code === 0x2708 || // plane ()\n  code === 0x25ef // large circle ()\n  ;\n};\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar Editor = {\n  /**\r\n   * Get the ancestor above a location in the document.\r\n   */\n  above: function above(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$voids = options.voids,\n        voids = _options$voids === void 0 ? false : _options$voids,\n        _options$mode = options.mode,\n        mode = _options$mode === void 0 ? 'lowest' : _options$mode,\n        _options$at = options.at,\n        at = _options$at === void 0 ? editor.selection : _options$at,\n        match = options.match;\n\n    if (!at) {\n      return;\n    }\n\n    var path = Editor.path(editor, at);\n    var reverse = mode === 'lowest';\n\n    var _iterator = _createForOfIteratorHelper(Editor.levels(editor, {\n      at: path,\n      voids: voids,\n      match: match,\n      reverse: reverse\n    })),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _step$value = _slicedToArray(_step.value, 2),\n            n = _step$value[0],\n            p = _step$value[1];\n\n        if (!Text.isText(n) && !Path.equals(path, p)) {\n          return [n, p];\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  },\n\n  /**\r\n   * Add a custom property to the leaf text nodes in the current selection.\r\n   *\r\n   * If the selection is currently collapsed, the marks will be added to the\r\n   * `editor.marks` property instead, and applied when text is inserted next.\r\n   */\n  addMark: function addMark(editor, key, value) {\n    editor.addMark(key, value);\n  },\n\n  /**\r\n   * Get the point after a location.\r\n   */\n  after: function after(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var anchor = Editor.point(editor, at, {\n      edge: 'end'\n    });\n    var focus = Editor.end(editor, []);\n    var range = {\n      anchor: anchor,\n      focus: focus\n    };\n    var _options$distance = options.distance,\n        distance = _options$distance === void 0 ? 1 : _options$distance;\n    var d = 0;\n    var target;\n\n    var _iterator2 = _createForOfIteratorHelper(Editor.positions(editor, _objectSpread({}, options, {\n      at: range\n    }))),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var p = _step2.value;\n\n        if (d > distance) {\n          break;\n        }\n\n        if (d !== 0) {\n          target = p;\n        }\n\n        d++;\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    return target;\n  },\n\n  /**\r\n   * Get the point before a location.\r\n   */\n  before: function before(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var anchor = Editor.start(editor, []);\n    var focus = Editor.point(editor, at, {\n      edge: 'start'\n    });\n    var range = {\n      anchor: anchor,\n      focus: focus\n    };\n    var _options$distance2 = options.distance,\n        distance = _options$distance2 === void 0 ? 1 : _options$distance2;\n    var d = 0;\n    var target;\n\n    var _iterator3 = _createForOfIteratorHelper(Editor.positions(editor, _objectSpread({}, options, {\n      at: range,\n      reverse: true\n    }))),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var p = _step3.value;\n\n        if (d > distance) {\n          break;\n        }\n\n        if (d !== 0) {\n          target = p;\n        }\n\n        d++;\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    return target;\n  },\n\n  /**\r\n   * Delete content in the editor backward from the current selection.\r\n   */\n  deleteBackward: function deleteBackward(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$unit = options.unit,\n        unit = _options$unit === void 0 ? 'character' : _options$unit;\n    editor.deleteBackward(unit);\n  },\n\n  /**\r\n   * Delete content in the editor forward from the current selection.\r\n   */\n  deleteForward: function deleteForward(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$unit2 = options.unit,\n        unit = _options$unit2 === void 0 ? 'character' : _options$unit2;\n    editor.deleteForward(unit);\n  },\n\n  /**\r\n   * Delete the content in the current selection.\r\n   */\n  deleteFragment: function deleteFragment(editor) {\n    editor.deleteFragment();\n  },\n\n  /**\r\n   * Get the start and end points of a location.\r\n   */\n  edges: function edges(editor, at) {\n    return [Editor.start(editor, at), Editor.end(editor, at)];\n  },\n\n  /**\r\n   * Get the end point of a location.\r\n   */\n  end: function end(editor, at) {\n    return Editor.point(editor, at, {\n      edge: 'end'\n    });\n  },\n\n  /**\r\n   * Get the first node at a location.\r\n   */\n  first: function first(editor, at) {\n    var path = Editor.path(editor, at, {\n      edge: 'start'\n    });\n    return Editor.node(editor, path);\n  },\n\n  /**\r\n   * Get the fragment at a location.\r\n   */\n  fragment: function fragment(editor, at) {\n    var range = Editor.range(editor, at);\n    var fragment = Node.fragment(editor, range);\n    return fragment;\n  },\n\n  /**\r\n   * Check if a node has block children.\r\n   */\n  hasBlocks: function hasBlocks(editor, element) {\n    return element.children.some(function (n) {\n      return Editor.isBlock(editor, n);\n    });\n  },\n\n  /**\r\n   * Check if a node has inline and text children.\r\n   */\n  hasInlines: function hasInlines(editor, element) {\n    return element.children.some(function (n) {\n      return Text.isText(n) || Editor.isInline(editor, n);\n    });\n  },\n\n  /**\r\n   * Check if a node has text children.\r\n   */\n  hasTexts: function hasTexts(editor, element) {\n    return element.children.every(function (n) {\n      return Text.isText(n);\n    });\n  },\n\n  /**\r\n   * Insert a block break at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertBreak: function insertBreak(editor) {\n    editor.insertBreak();\n  },\n\n  /**\r\n   * Insert a fragment at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertFragment: function insertFragment(editor, fragment) {\n    editor.insertFragment(fragment);\n  },\n\n  /**\r\n   * Insert a node at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertNode: function insertNode(editor, node) {\n    editor.insertNode(node);\n  },\n\n  /**\r\n   * Insert text at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertText: function insertText(editor, text) {\n    editor.insertText(text);\n  },\n\n  /**\r\n   * Check if a value is a block `Element` object.\r\n   */\n  isBlock: function isBlock(editor, value) {\n    return Element.isElement(value) && !editor.isInline(value);\n  },\n\n  /**\r\n   * Check if a value is an `Editor` object.\r\n   */\n  isEditor: function isEditor(value) {\n    return isPlainObject(value) && typeof value.addMark === 'function' && typeof value.apply === 'function' && typeof value.deleteBackward === 'function' && typeof value.deleteForward === 'function' && typeof value.deleteFragment === 'function' && typeof value.insertBreak === 'function' && typeof value.insertFragment === 'function' && typeof value.insertNode === 'function' && typeof value.insertText === 'function' && typeof value.isInline === 'function' && typeof value.isVoid === 'function' && typeof value.normalizeNode === 'function' && typeof value.onChange === 'function' && typeof value.removeMark === 'function' && (value.marks === null || isPlainObject(value.marks)) && (value.selection === null || Range.isRange(value.selection)) && Node.isNodeList(value.children) && Operation.isOperationList(value.operations);\n  },\n\n  /**\r\n   * Check if a point is the end point of a location.\r\n   */\n  isEnd: function isEnd(editor, point, at) {\n    var end = Editor.end(editor, at);\n    return Point.equals(point, end);\n  },\n\n  /**\r\n   * Check if a point is an edge of a location.\r\n   */\n  isEdge: function isEdge(editor, point, at) {\n    return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at);\n  },\n\n  /**\r\n   * Check if an element is empty, accounting for void nodes.\r\n   */\n  isEmpty: function isEmpty(editor, element) {\n    var children = element.children;\n\n    var _children = _slicedToArray(children, 1),\n        first = _children[0];\n\n    return children.length === 0 || children.length === 1 && Text.isText(first) && first.text === '' && !editor.isVoid(element);\n  },\n\n  /**\r\n   * Check if a value is an inline `Element` object.\r\n   */\n  isInline: function isInline(editor, value) {\n    return Element.isElement(value) && editor.isInline(value);\n  },\n\n  /**\r\n   * Check if the editor is currently normalizing after each operation.\r\n   */\n  isNormalizing: function isNormalizing(editor) {\n    var isNormalizing = NORMALIZING.get(editor);\n    return isNormalizing === undefined ? true : isNormalizing;\n  },\n\n  /**\r\n   * Check if a point is the start point of a location.\r\n   */\n  isStart: function isStart(editor, point, at) {\n    // PERF: If the offset isn't `0` we know it's not the start.\n    if (point.offset !== 0) {\n      return false;\n    }\n\n    var start = Editor.start(editor, at);\n    return Point.equals(point, start);\n  },\n\n  /**\r\n   * Check if a value is a void `Element` object.\r\n   */\n  isVoid: function isVoid(editor, value) {\n    return Element.isElement(value) && editor.isVoid(value);\n  },\n\n  /**\r\n   * Get the last node at a location.\r\n   */\n  last: function last(editor, at) {\n    var path = Editor.path(editor, at, {\n      edge: 'end'\n    });\n    return Editor.node(editor, path);\n  },\n\n  /**\r\n   * Get the leaf text node at a location.\r\n   */\n  leaf: function leaf(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var node = Node.leaf(editor, path);\n    return [node, path];\n  },\n\n  /**\r\n   * Iterate through all of the levels at a location.\r\n   */\n  levels: /*#__PURE__*/_regeneratorRuntime.mark(function levels(editor) {\n    var options,\n        _options$at2,\n        at,\n        _options$reverse,\n        reverse,\n        _options$voids2,\n        voids,\n        match,\n        levels,\n        path,\n        _iterator4,\n        _step4,\n        _step4$value,\n        n,\n        p,\n        _args = arguments;\n\n    return _regeneratorRuntime.wrap(function levels$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n            _options$at2 = options.at, at = _options$at2 === void 0 ? editor.selection : _options$at2, _options$reverse = options.reverse, reverse = _options$reverse === void 0 ? false : _options$reverse, _options$voids2 = options.voids, voids = _options$voids2 === void 0 ? false : _options$voids2;\n            match = options.match;\n\n            if (match == null) {\n              match = function match() {\n                return true;\n              };\n            }\n\n            if (at) {\n              _context.next = 6;\n              break;\n            }\n\n            return _context.abrupt(\"return\");\n\n          case 6:\n            levels = [];\n            path = Editor.path(editor, at);\n            _iterator4 = _createForOfIteratorHelper(Node.levels(editor, path));\n            _context.prev = 9;\n\n            _iterator4.s();\n\n          case 11:\n            if ((_step4 = _iterator4.n()).done) {\n              _context.next = 20;\n              break;\n            }\n\n            _step4$value = _slicedToArray(_step4.value, 2), n = _step4$value[0], p = _step4$value[1];\n\n            if (match(n)) {\n              _context.next = 15;\n              break;\n            }\n\n            return _context.abrupt(\"continue\", 18);\n\n          case 15:\n            levels.push([n, p]);\n\n            if (!(!voids && Editor.isVoid(editor, n))) {\n              _context.next = 18;\n              break;\n            }\n\n            return _context.abrupt(\"break\", 20);\n\n          case 18:\n            _context.next = 11;\n            break;\n\n          case 20:\n            _context.next = 25;\n            break;\n\n          case 22:\n            _context.prev = 22;\n            _context.t0 = _context[\"catch\"](9);\n\n            _iterator4.e(_context.t0);\n\n          case 25:\n            _context.prev = 25;\n\n            _iterator4.f();\n\n            return _context.finish(25);\n\n          case 28:\n            if (reverse) {\n              levels.reverse();\n            }\n\n            return _context.delegateYield(levels, \"t1\", 30);\n\n          case 30:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, levels, null, [[9, 22, 25, 28]]);\n  }),\n\n  /**\r\n   * Get the marks that would be added to text at the current selection.\r\n   */\n  marks: function marks(editor) {\n    var marks = editor.marks,\n        selection = editor.selection;\n\n    if (!selection) {\n      return null;\n    }\n\n    if (marks) {\n      return marks;\n    }\n\n    if (Range.isExpanded(selection)) {\n      var _Editor$nodes = Editor.nodes(editor, {\n        match: Text.isText\n      }),\n          _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1),\n          match = _Editor$nodes2[0];\n\n      if (match) {\n        var _match = _slicedToArray(match, 1),\n            _node = _match[0];\n\n        var _rest = _objectWithoutProperties(_node, [\"text\"]);\n\n        return _rest;\n      } else {\n        return {};\n      }\n    }\n\n    var anchor = selection.anchor;\n    var path = anchor.path;\n\n    var _Editor$leaf = Editor.leaf(editor, path),\n        _Editor$leaf2 = _slicedToArray(_Editor$leaf, 1),\n        node = _Editor$leaf2[0];\n\n    if (anchor.offset === 0) {\n      var prev = Editor.previous(editor, {\n        at: path,\n        match: Text.isText\n      });\n      var block = Editor.above(editor, {\n        match: function match(n) {\n          return Editor.isBlock(editor, n);\n        }\n      });\n\n      if (prev && block) {\n        var _prev2 = _slicedToArray(prev, 2),\n            prevNode = _prev2[0],\n            prevPath = _prev2[1];\n\n        var _block = _slicedToArray(block, 2),\n            blockPath = _block[1];\n\n        if (Path.isAncestor(blockPath, prevPath)) {\n          node = prevNode;\n        }\n      }\n    }\n\n    var rest = _objectWithoutProperties(node, [\"text\"]);\n\n    return rest;\n  },\n\n  /**\r\n   * Get the matching node in the branch of the document after a location.\r\n   */\n  next: function next(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$mode2 = options.mode,\n        mode = _options$mode2 === void 0 ? 'lowest' : _options$mode2,\n        _options$voids3 = options.voids,\n        voids = _options$voids3 === void 0 ? false : _options$voids3;\n    var match = options.match,\n        _options$at3 = options.at,\n        at = _options$at3 === void 0 ? editor.selection : _options$at3;\n\n    if (!at) {\n      return;\n    }\n\n    var _Editor$last = Editor.last(editor, at),\n        _Editor$last2 = _slicedToArray(_Editor$last, 2),\n        from = _Editor$last2[1];\n\n    var _Editor$last3 = Editor.last(editor, []),\n        _Editor$last4 = _slicedToArray(_Editor$last3, 2),\n        to = _Editor$last4[1];\n\n    var span = [from, to];\n\n    if (Path.isPath(at) && at.length === 0) {\n      throw new Error(\"Cannot get the next node from the root node!\");\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        var _Editor$parent = Editor.parent(editor, at),\n            _Editor$parent2 = _slicedToArray(_Editor$parent, 1),\n            parent = _Editor$parent2[0];\n\n        match = function match(n) {\n          return parent.children.includes(n);\n        };\n      } else {\n        match = function match() {\n          return true;\n        };\n      }\n    }\n\n    var _Editor$nodes3 = Editor.nodes(editor, {\n      at: span,\n      match: match,\n      mode: mode,\n      voids: voids\n    }),\n        _Editor$nodes4 = _slicedToArray(_Editor$nodes3, 2),\n        next = _Editor$nodes4[1];\n\n    return next;\n  },\n\n  /**\r\n   * Get the node at a location.\r\n   */\n  node: function node(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var node = Node.get(editor, path);\n    return [node, path];\n  },\n\n  /**\r\n   * Iterate through all of the nodes in the Editor.\r\n   */\n  nodes: /*#__PURE__*/_regeneratorRuntime.mark(function nodes(editor) {\n    var options,\n        _options$at4,\n        at,\n        _options$mode3,\n        mode,\n        _options$universal,\n        universal,\n        _options$reverse2,\n        reverse,\n        _options$voids4,\n        voids,\n        match,\n        from,\n        to,\n        first,\n        last,\n        nodeEntries,\n        matches,\n        hit,\n        _iterator5,\n        _step5,\n        _step5$value,\n        node,\n        path,\n        isLower,\n        emit,\n        _args2 = arguments;\n\n    return _regeneratorRuntime.wrap(function nodes$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n            _options$at4 = options.at, at = _options$at4 === void 0 ? editor.selection : _options$at4, _options$mode3 = options.mode, mode = _options$mode3 === void 0 ? 'all' : _options$mode3, _options$universal = options.universal, universal = _options$universal === void 0 ? false : _options$universal, _options$reverse2 = options.reverse, reverse = _options$reverse2 === void 0 ? false : _options$reverse2, _options$voids4 = options.voids, voids = _options$voids4 === void 0 ? false : _options$voids4;\n            match = options.match;\n\n            if (!match) {\n              match = function match() {\n                return true;\n              };\n            }\n\n            if (at) {\n              _context2.next = 6;\n              break;\n            }\n\n            return _context2.abrupt(\"return\");\n\n          case 6:\n            if (Span.isSpan(at)) {\n              from = at[0];\n              to = at[1];\n            } else {\n              first = Editor.path(editor, at, {\n                edge: 'start'\n              });\n              last = Editor.path(editor, at, {\n                edge: 'end'\n              });\n              from = reverse ? last : first;\n              to = reverse ? first : last;\n            }\n\n            nodeEntries = Node.nodes(editor, {\n              reverse: reverse,\n              from: from,\n              to: to,\n              pass: function pass(_ref) {\n                var _ref6 = _slicedToArray(_ref, 1),\n                    n = _ref6[0];\n\n                return voids ? false : Editor.isVoid(editor, n);\n              }\n            });\n            matches = [];\n            _iterator5 = _createForOfIteratorHelper(nodeEntries);\n            _context2.prev = 10;\n\n            _iterator5.s();\n\n          case 12:\n            if ((_step5 = _iterator5.n()).done) {\n              _context2.next = 37;\n              break;\n            }\n\n            _step5$value = _slicedToArray(_step5.value, 2), node = _step5$value[0], path = _step5$value[1];\n            isLower = hit && Path.compare(path, hit[1]) === 0; // In highest mode any node lower than the last hit is not a match.\n\n            if (!(mode === 'highest' && isLower)) {\n              _context2.next = 17;\n              break;\n            }\n\n            return _context2.abrupt(\"continue\", 35);\n\n          case 17:\n            if (match(node)) {\n              _context2.next = 23;\n              break;\n            }\n\n            if (!(universal && !isLower && Text.isText(node))) {\n              _context2.next = 22;\n              break;\n            }\n\n            return _context2.abrupt(\"return\");\n\n          case 22:\n            return _context2.abrupt(\"continue\", 35);\n\n          case 23:\n            if (!(mode === 'lowest' && isLower)) {\n              _context2.next = 26;\n              break;\n            }\n\n            hit = [node, path];\n            return _context2.abrupt(\"continue\", 35);\n\n          case 26:\n            // In lowest mode we emit the last hit, once it's guaranteed lowest.\n            emit = mode === 'lowest' ? hit : [node, path];\n\n            if (!emit) {\n              _context2.next = 34;\n              break;\n            }\n\n            if (!universal) {\n              _context2.next = 32;\n              break;\n            }\n\n            matches.push(emit);\n            _context2.next = 34;\n            break;\n\n          case 32:\n            _context2.next = 34;\n            return emit;\n\n          case 34:\n            hit = [node, path];\n\n          case 35:\n            _context2.next = 12;\n            break;\n\n          case 37:\n            _context2.next = 42;\n            break;\n\n          case 39:\n            _context2.prev = 39;\n            _context2.t0 = _context2[\"catch\"](10);\n\n            _iterator5.e(_context2.t0);\n\n          case 42:\n            _context2.prev = 42;\n\n            _iterator5.f();\n\n            return _context2.finish(42);\n\n          case 45:\n            if (!(mode === 'lowest' && hit)) {\n              _context2.next = 52;\n              break;\n            }\n\n            if (!universal) {\n              _context2.next = 50;\n              break;\n            }\n\n            matches.push(hit);\n            _context2.next = 52;\n            break;\n\n          case 50:\n            _context2.next = 52;\n            return hit;\n\n          case 52:\n            if (!universal) {\n              _context2.next = 54;\n              break;\n            }\n\n            return _context2.delegateYield(matches, \"t1\", 54);\n\n          case 54:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, nodes, null, [[10, 39, 42, 45]]);\n  }),\n\n  /**\r\n   * Normalize any dirty objects in the editor.\r\n   */\n  normalize: function normalize(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$force = options.force,\n        force = _options$force === void 0 ? false : _options$force;\n\n    var getDirtyPaths = function getDirtyPaths(editor) {\n      return DIRTY_PATHS.get(editor) || [];\n    };\n\n    if (!Editor.isNormalizing(editor)) {\n      return;\n    }\n\n    if (force) {\n      var allPaths = Array.from(Node.nodes(editor), function (_ref2) {\n        var _ref7 = _slicedToArray(_ref2, 2),\n            p = _ref7[1];\n\n        return p;\n      });\n      DIRTY_PATHS.set(editor, allPaths);\n    }\n\n    if (getDirtyPaths(editor).length === 0) {\n      return;\n    }\n\n    Editor.withoutNormalizing(editor, function () {\n      var max = getDirtyPaths(editor).length * 42; // HACK: better way?\n\n      var m = 0;\n\n      while (getDirtyPaths(editor).length !== 0) {\n        if (m > max) {\n          throw new Error(\"\\n            Could not completely normalize the editor after \".concat(max, \" iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\\n          \"));\n        }\n\n        var path = getDirtyPaths(editor).pop();\n        var entry = Editor.node(editor, path);\n        editor.normalizeNode(entry);\n        m++;\n      }\n    });\n  },\n\n  /**\r\n   * Get the parent node of a location.\r\n   */\n  parent: function parent(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var parentPath = Path.parent(path);\n    var entry = Editor.node(editor, parentPath);\n    return entry;\n  },\n\n  /**\r\n   * Get the path of a location.\r\n   */\n  path: function path(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var depth = options.depth,\n        edge = options.edge;\n\n    if (Path.isPath(at)) {\n      if (edge === 'start') {\n        var _Node$first = Node.first(editor, at),\n            _Node$first2 = _slicedToArray(_Node$first, 2),\n            firstPath = _Node$first2[1];\n\n        at = firstPath;\n      } else if (edge === 'end') {\n        var _Node$last = Node.last(editor, at),\n            _Node$last2 = _slicedToArray(_Node$last, 2),\n            lastPath = _Node$last2[1];\n\n        at = lastPath;\n      }\n    }\n\n    if (Range.isRange(at)) {\n      if (edge === 'start') {\n        at = Range.start(at);\n      } else if (edge === 'end') {\n        at = Range.end(at);\n      } else {\n        at = Path.common(at.anchor.path, at.focus.path);\n      }\n    }\n\n    if (Point.isPoint(at)) {\n      at = at.path;\n    }\n\n    if (depth != null) {\n      at = at.slice(0, depth);\n    }\n\n    return at;\n  },\n\n  /**\r\n   * Create a mutable ref for a `Path` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */\n  pathRef: function pathRef(editor, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$affinity = options.affinity,\n        affinity = _options$affinity === void 0 ? 'forward' : _options$affinity;\n    var ref = {\n      current: path,\n      affinity: affinity,\n      unref: function unref() {\n        var current = ref.current;\n        var pathRefs = Editor.pathRefs(editor);\n        pathRefs.delete(ref);\n        ref.current = null;\n        return current;\n      }\n    };\n    var refs = Editor.pathRefs(editor);\n    refs.add(ref);\n    return ref;\n  },\n\n  /**\r\n   * Get the set of currently tracked path refs of the editor.\r\n   */\n  pathRefs: function pathRefs(editor) {\n    var refs = PATH_REFS.get(editor);\n\n    if (!refs) {\n      refs = new Set();\n      PATH_REFS.set(editor, refs);\n    }\n\n    return refs;\n  },\n\n  /**\r\n   * Get the start or end point of a location.\r\n   */\n  point: function point(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$edge = options.edge,\n        edge = _options$edge === void 0 ? 'start' : _options$edge;\n\n    if (Path.isPath(at)) {\n      var path;\n\n      if (edge === 'end') {\n        var _Node$last3 = Node.last(editor, at),\n            _Node$last4 = _slicedToArray(_Node$last3, 2),\n            lastPath = _Node$last4[1];\n\n        path = lastPath;\n      } else {\n        var _Node$first3 = Node.first(editor, at),\n            _Node$first4 = _slicedToArray(_Node$first3, 2),\n            firstPath = _Node$first4[1];\n\n        path = firstPath;\n      }\n\n      var node = Node.get(editor, path);\n\n      if (!Text.isText(node)) {\n        throw new Error(\"Cannot get the \".concat(edge, \" point in the node at path [\").concat(at, \"] because it has no \").concat(edge, \" text node.\"));\n      }\n\n      return {\n        path: path,\n        offset: edge === 'end' ? node.text.length : 0\n      };\n    }\n\n    if (Range.isRange(at)) {\n      var _Range$edges = Range.edges(at),\n          _Range$edges2 = _slicedToArray(_Range$edges, 2),\n          start = _Range$edges2[0],\n          end = _Range$edges2[1];\n\n      return edge === 'start' ? start : end;\n    }\n\n    return at;\n  },\n\n  /**\r\n   * Create a mutable ref for a `Point` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */\n  pointRef: function pointRef(editor, point) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$affinity2 = options.affinity,\n        affinity = _options$affinity2 === void 0 ? 'forward' : _options$affinity2;\n    var ref = {\n      current: point,\n      affinity: affinity,\n      unref: function unref() {\n        var current = ref.current;\n        var pointRefs = Editor.pointRefs(editor);\n        pointRefs.delete(ref);\n        ref.current = null;\n        return current;\n      }\n    };\n    var refs = Editor.pointRefs(editor);\n    refs.add(ref);\n    return ref;\n  },\n\n  /**\r\n   * Get the set of currently tracked point refs of the editor.\r\n   */\n  pointRefs: function pointRefs(editor) {\n    var refs = POINT_REFS.get(editor);\n\n    if (!refs) {\n      refs = new Set();\n      POINT_REFS.set(editor, refs);\n    }\n\n    return refs;\n  },\n\n  /**\r\n   * Iterate through all of the positions in the document where a `Point` can be\r\n   * placed.\r\n   *\r\n   * By default it will move forward by individual offsets at a time,  but you\r\n   * can pass the `unit: 'character'` option to moved forward one character, word,\r\n   * or line at at time.\r\n   *\r\n   * Note: void nodes are treated as a single point, and iteration will not\r\n   * happen inside their content.\r\n   */\n  positions: /*#__PURE__*/_regeneratorRuntime.mark(function positions(editor) {\n    var options,\n        _options$at5,\n        at,\n        _options$unit3,\n        unit,\n        _options$reverse3,\n        reverse$1,\n        range,\n        _Range$edges3,\n        _Range$edges4,\n        start,\n        end,\n        first,\n        string,\n        available,\n        offset,\n        distance,\n        isNewBlock,\n        advance,\n        _iterator6,\n        _step6,\n        _step6$value,\n        node,\n        path,\n        e,\n        s,\n        text,\n        isFirst,\n        _args3 = arguments;\n\n    return _regeneratorRuntime.wrap(function positions$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            options = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};\n            _options$at5 = options.at, at = _options$at5 === void 0 ? editor.selection : _options$at5, _options$unit3 = options.unit, unit = _options$unit3 === void 0 ? 'offset' : _options$unit3, _options$reverse3 = options.reverse, reverse$1 = _options$reverse3 === void 0 ? false : _options$reverse3;\n\n            if (at) {\n              _context3.next = 4;\n              break;\n            }\n\n            return _context3.abrupt(\"return\");\n\n          case 4:\n            range = Editor.range(editor, at);\n            _Range$edges3 = Range.edges(range), _Range$edges4 = _slicedToArray(_Range$edges3, 2), start = _Range$edges4[0], end = _Range$edges4[1];\n            first = reverse$1 ? end : start;\n            string = '';\n            available = 0;\n            offset = 0;\n            distance = null;\n            isNewBlock = false;\n\n            advance = function advance() {\n              if (distance == null) {\n                if (unit === 'character') {\n                  distance = getCharacterDistance(string);\n                } else if (unit === 'word') {\n                  distance = getWordDistance(string);\n                } else if (unit === 'line' || unit === 'block') {\n                  distance = string.length;\n                } else {\n                  distance = 1;\n                }\n\n                string = string.slice(distance);\n              } // Add or substract the offset.\n\n\n              offset = reverse$1 ? offset - distance : offset + distance; // Subtract the distance traveled from the available text.\n\n              available = available - distance; // If the available had room to spare, reset the distance so that it will\n              // advance again next time. Otherwise, set it to the overflow amount.\n\n              distance = available >= 0 ? null : 0 - available;\n            };\n\n            _iterator6 = _createForOfIteratorHelper(Editor.nodes(editor, {\n              at: at,\n              reverse: reverse$1\n            }));\n            _context3.prev = 14;\n\n            _iterator6.s();\n\n          case 16:\n            if ((_step6 = _iterator6.n()).done) {\n              _context3.next = 51;\n              break;\n            }\n\n            _step6$value = _slicedToArray(_step6.value, 2), node = _step6$value[0], path = _step6$value[1];\n\n            if (!Element.isElement(node)) {\n              _context3.next = 26;\n              break;\n            }\n\n            if (!editor.isVoid(node)) {\n              _context3.next = 23;\n              break;\n            }\n\n            _context3.next = 22;\n            return Editor.start(editor, path);\n\n          case 22:\n            return _context3.abrupt(\"continue\", 49);\n\n          case 23:\n            if (!editor.isInline(node)) {\n              _context3.next = 25;\n              break;\n            }\n\n            return _context3.abrupt(\"continue\", 49);\n\n          case 25:\n            if (Editor.hasInlines(editor, node)) {\n              e = Path.isAncestor(path, end.path) ? end : Editor.end(editor, path);\n              s = Path.isAncestor(path, start.path) ? start : Editor.start(editor, path);\n              text = Editor.string(editor, {\n                anchor: s,\n                focus: e\n              });\n              string = reverse$1 ? reverse(text) : text;\n              isNewBlock = true;\n            }\n\n          case 26:\n            if (!Text.isText(node)) {\n              _context3.next = 49;\n              break;\n            }\n\n            isFirst = Path.equals(path, first.path);\n            available = node.text.length;\n            offset = reverse$1 ? available : 0;\n\n            if (isFirst) {\n              available = reverse$1 ? first.offset : available - first.offset;\n              offset = first.offset;\n            }\n\n            if (!(isFirst || isNewBlock || unit === 'offset')) {\n              _context3.next = 34;\n              break;\n            }\n\n            _context3.next = 34;\n            return {\n              path: path,\n              offset: offset\n            };\n\n          case 34:\n            if (!true) {\n              _context3.next = 48;\n              break;\n            }\n\n            if (!(string === '')) {\n              _context3.next = 39;\n              break;\n            }\n\n            return _context3.abrupt(\"break\", 48);\n\n          case 39:\n            advance();\n\n          case 40:\n            if (!(available >= 0)) {\n              _context3.next = 45;\n              break;\n            }\n\n            _context3.next = 43;\n            return {\n              path: path,\n              offset: offset\n            };\n\n          case 43:\n            _context3.next = 46;\n            break;\n\n          case 45:\n            return _context3.abrupt(\"break\", 48);\n\n          case 46:\n            _context3.next = 34;\n            break;\n\n          case 48:\n            isNewBlock = false;\n\n          case 49:\n            _context3.next = 16;\n            break;\n\n          case 51:\n            _context3.next = 56;\n            break;\n\n          case 53:\n            _context3.prev = 53;\n            _context3.t0 = _context3[\"catch\"](14);\n\n            _iterator6.e(_context3.t0);\n\n          case 56:\n            _context3.prev = 56;\n\n            _iterator6.f();\n\n            return _context3.finish(56);\n\n          case 59:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, positions, null, [[14, 53, 56, 59]]);\n  }),\n\n  /**\r\n   * Get the matching node in the branch of the document before a location.\r\n   */\n  previous: function previous(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$mode4 = options.mode,\n        mode = _options$mode4 === void 0 ? 'lowest' : _options$mode4,\n        _options$voids5 = options.voids,\n        voids = _options$voids5 === void 0 ? false : _options$voids5;\n    var match = options.match,\n        _options$at6 = options.at,\n        at = _options$at6 === void 0 ? editor.selection : _options$at6;\n\n    if (!at) {\n      return;\n    }\n\n    var _Editor$first = Editor.first(editor, at),\n        _Editor$first2 = _slicedToArray(_Editor$first, 2),\n        from = _Editor$first2[1];\n\n    var _Editor$first3 = Editor.first(editor, []),\n        _Editor$first4 = _slicedToArray(_Editor$first3, 2),\n        to = _Editor$first4[1];\n\n    var span = [from, to];\n\n    if (Path.isPath(at) && at.length === 0) {\n      throw new Error(\"Cannot get the previous node from the root node!\");\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        var _Editor$parent3 = Editor.parent(editor, at),\n            _Editor$parent4 = _slicedToArray(_Editor$parent3, 1),\n            parent = _Editor$parent4[0];\n\n        match = function match(n) {\n          return parent.children.includes(n);\n        };\n      } else {\n        match = function match() {\n          return true;\n        };\n      }\n    }\n\n    var _Editor$nodes5 = Editor.nodes(editor, {\n      reverse: true,\n      at: span,\n      match: match,\n      mode: mode,\n      voids: voids\n    }),\n        _Editor$nodes6 = _slicedToArray(_Editor$nodes5, 2),\n        previous = _Editor$nodes6[1];\n\n    return previous;\n  },\n\n  /**\r\n   * Get a range of a location.\r\n   */\n  range: function range(editor, at, to) {\n    if (Range.isRange(at) && !to) {\n      return at;\n    }\n\n    var start = Editor.start(editor, at);\n    var end = Editor.end(editor, to || at);\n    return {\n      anchor: start,\n      focus: end\n    };\n  },\n\n  /**\r\n   * Create a mutable ref for a `Range` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */\n  rangeRef: function rangeRef(editor, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$affinity3 = options.affinity,\n        affinity = _options$affinity3 === void 0 ? 'forward' : _options$affinity3;\n    var ref = {\n      current: range,\n      affinity: affinity,\n      unref: function unref() {\n        var current = ref.current;\n        var rangeRefs = Editor.rangeRefs(editor);\n        rangeRefs.delete(ref);\n        ref.current = null;\n        return current;\n      }\n    };\n    var refs = Editor.rangeRefs(editor);\n    refs.add(ref);\n    return ref;\n  },\n\n  /**\r\n   * Get the set of currently tracked range refs of the editor.\r\n   */\n  rangeRefs: function rangeRefs(editor) {\n    var refs = RANGE_REFS.get(editor);\n\n    if (!refs) {\n      refs = new Set();\n      RANGE_REFS.set(editor, refs);\n    }\n\n    return refs;\n  },\n\n  /**\r\n   * Remove a custom property from all of the leaf text nodes in the current\r\n   * selection.\r\n   *\r\n   * If the selection is currently collapsed, the removal will be stored on\r\n   * `editor.marks` and applied to the text inserted next.\r\n   */\n  removeMark: function removeMark(editor, key) {\n    editor.removeMark(key);\n  },\n\n  /**\r\n   * Get the start point of a location.\r\n   */\n  start: function start(editor, at) {\n    return Editor.point(editor, at, {\n      edge: 'start'\n    });\n  },\n\n  /**\r\n   * Get the text string content of a location.\r\n   *\r\n   * Note: the text of void nodes is presumed to be an empty string, regardless\r\n   * of what their actual content is.\r\n   */\n  string: function string(editor, at) {\n    var range = Editor.range(editor, at);\n\n    var _Range$edges5 = Range.edges(range),\n        _Range$edges6 = _slicedToArray(_Range$edges5, 2),\n        start = _Range$edges6[0],\n        end = _Range$edges6[1];\n\n    var text = '';\n\n    var _iterator7 = _createForOfIteratorHelper(Editor.nodes(editor, {\n      at: range,\n      match: Text.isText\n    })),\n        _step7;\n\n    try {\n      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n        var _step7$value = _slicedToArray(_step7.value, 2),\n            node = _step7$value[0],\n            path = _step7$value[1];\n\n        var t = node.text;\n\n        if (Path.equals(path, end.path)) {\n          t = t.slice(0, end.offset);\n        }\n\n        if (Path.equals(path, start.path)) {\n          t = t.slice(start.offset);\n        }\n\n        text += t;\n      }\n    } catch (err) {\n      _iterator7.e(err);\n    } finally {\n      _iterator7.f();\n    }\n\n    return text;\n  },\n\n  /**\r\n   * Convert a range into a non-hanging one.\r\n   */\n  unhangRange: function unhangRange(editor, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$voids6 = options.voids,\n        voids = _options$voids6 === void 0 ? false : _options$voids6;\n\n    var _Range$edges7 = Range.edges(range),\n        _Range$edges8 = _slicedToArray(_Range$edges7, 2),\n        start = _Range$edges8[0],\n        end = _Range$edges8[1]; // PERF: exit early if we can guarantee that the range isn't hanging.\n\n\n    if (start.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range)) {\n      return range;\n    }\n\n    var endBlock = Editor.above(editor, {\n      at: end,\n      match: function match(n) {\n        return Editor.isBlock(editor, n);\n      }\n    });\n    var blockPath = endBlock ? endBlock[1] : [];\n    var first = Editor.start(editor, []);\n    var before = {\n      anchor: first,\n      focus: end\n    };\n    var skip = true;\n\n    var _iterator8 = _createForOfIteratorHelper(Editor.nodes(editor, {\n      at: before,\n      match: Text.isText,\n      reverse: true,\n      voids: voids\n    })),\n        _step8;\n\n    try {\n      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n        var _step8$value = _slicedToArray(_step8.value, 2),\n            node = _step8$value[0],\n            path = _step8$value[1];\n\n        if (skip) {\n          skip = false;\n          continue;\n        }\n\n        if (node.text !== '' || Path.isBefore(path, blockPath)) {\n          end = {\n            path: path,\n            offset: node.text.length\n          };\n          break;\n        }\n      }\n    } catch (err) {\n      _iterator8.e(err);\n    } finally {\n      _iterator8.f();\n    }\n\n    return {\n      anchor: start,\n      focus: end\n    };\n  },\n\n  /**\r\n   * Match a void node in the current branch of the editor.\r\n   */\n  void: function _void(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return Editor.above(editor, _objectSpread({}, options, {\n      match: function match(n) {\n        return Editor.isVoid(editor, n);\n      }\n    }));\n  },\n\n  /**\r\n   * Call a function, deferring normalization until after it completes.\r\n   */\n  withoutNormalizing: function withoutNormalizing(editor, fn) {\n    var value = Editor.isNormalizing(editor);\n    NORMALIZING.set(editor, false);\n    fn();\n    NORMALIZING.set(editor, value);\n    Editor.normalize(editor);\n  }\n};\nvar Element = {\n  /**\r\n   * Check if a value implements the `Element` interface.\r\n   */\n  isElement: function isElement(value) {\n    return isPlainObject(value) && Node.isNodeList(value.children) && !Editor.isEditor(value);\n  },\n\n  /**\r\n   * Check if a value is an array of `Element` objects.\r\n   */\n  isElementList: function isElementList(value) {\n    return Array.isArray(value) && (value.length === 0 || Element.isElement(value[0]));\n  },\n\n  /**\r\n   * Check if an element matches set of properties.\r\n   *\r\n   * Note: this checks custom properties, and it does not ensure that any\r\n   * children are equivalent.\r\n   */\n  matches: function matches(element, props) {\n    for (var key in props) {\n      if (key === 'children') {\n        continue;\n      }\n\n      if (element[key] !== props[key]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n};\nvar Location = {\n  /**\r\n   * Check if a value implements the `Location` interface.\r\n   */\n  isLocation: function isLocation(value) {\n    return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value);\n  }\n};\nvar Span = {\n  /**\r\n   * Check if a value implements the `Span` interface.\r\n   */\n  isSpan: function isSpan(value) {\n    return Array.isArray(value) && value.length === 2 && value.every(Path.isPath);\n  }\n};\nvar Node = {\n  /**\r\n   * Get the node at a specific path, asserting that it's an ancestor node.\r\n   */\n  ancestor: function ancestor(root, path) {\n    var node = Node.get(root, path);\n\n    if (Text.isText(node)) {\n      throw new Error(\"Cannot get the ancestor node at path [\".concat(path, \"] because it refers to a text node instead: \").concat(node));\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Return a generator of all the ancestor nodes above a specific path.\r\n   *\r\n   * By default the order is bottom-up, from lowest to highest ancestor in\r\n   * the tree, but you can pass the `reverse: true` option to go top-down.\r\n   */\n  ancestors: /*#__PURE__*/_regeneratorRuntime.mark(function ancestors(root, path) {\n    var options,\n        _iterator9,\n        _step9,\n        p,\n        n,\n        entry,\n        _args4 = arguments;\n\n    return _regeneratorRuntime.wrap(function ancestors$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            options = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};\n            _iterator9 = _createForOfIteratorHelper(Path.ancestors(path, options));\n            _context4.prev = 2;\n\n            _iterator9.s();\n\n          case 4:\n            if ((_step9 = _iterator9.n()).done) {\n              _context4.next = 12;\n              break;\n            }\n\n            p = _step9.value;\n            n = Node.ancestor(root, p);\n            entry = [n, p];\n            _context4.next = 10;\n            return entry;\n\n          case 10:\n            _context4.next = 4;\n            break;\n\n          case 12:\n            _context4.next = 17;\n            break;\n\n          case 14:\n            _context4.prev = 14;\n            _context4.t0 = _context4[\"catch\"](2);\n\n            _iterator9.e(_context4.t0);\n\n          case 17:\n            _context4.prev = 17;\n\n            _iterator9.f();\n\n            return _context4.finish(17);\n\n          case 20:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, ancestors, null, [[2, 14, 17, 20]]);\n  }),\n\n  /**\r\n   * Get the child of a node at a specific index.\r\n   */\n  child: function child(root, index) {\n    if (Text.isText(root)) {\n      throw new Error(\"Cannot get the child of a text node: \".concat(JSON.stringify(root)));\n    }\n\n    var c = root.children[index];\n\n    if (c == null) {\n      throw new Error(\"Cannot get child at index `\".concat(index, \"` in node: \").concat(JSON.stringify(root)));\n    }\n\n    return c;\n  },\n\n  /**\r\n   * Iterate over the children of a node at a specific path.\r\n   */\n  children: /*#__PURE__*/_regeneratorRuntime.mark(function children(root, path) {\n    var options,\n        _options$reverse4,\n        reverse,\n        ancestor,\n        children,\n        index,\n        child,\n        childPath,\n        _args5 = arguments;\n\n    return _regeneratorRuntime.wrap(function children$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            options = _args5.length > 2 && _args5[2] !== undefined ? _args5[2] : {};\n            _options$reverse4 = options.reverse, reverse = _options$reverse4 === void 0 ? false : _options$reverse4;\n            ancestor = Node.ancestor(root, path);\n            children = ancestor.children;\n            index = reverse ? children.length - 1 : 0;\n\n          case 5:\n            if (!(reverse ? index >= 0 : index < children.length)) {\n              _context5.next = 13;\n              break;\n            }\n\n            child = Node.child(ancestor, index);\n            childPath = path.concat(index);\n            _context5.next = 10;\n            return [child, childPath];\n\n          case 10:\n            index = reverse ? index - 1 : index + 1;\n            _context5.next = 5;\n            break;\n\n          case 13:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, children);\n  }),\n\n  /**\r\n   * Get an entry for the common ancesetor node of two paths.\r\n   */\n  common: function common(root, path, another) {\n    var p = Path.common(path, another);\n    var n = Node.get(root, p);\n    return [n, p];\n  },\n\n  /**\r\n   * Get the node at a specific path, asserting that it's a descendant node.\r\n   */\n  descendant: function descendant(root, path) {\n    var node = Node.get(root, path);\n\n    if (Editor.isEditor(node)) {\n      throw new Error(\"Cannot get the descendant node at path [\".concat(path, \"] because it refers to the root editor node instead: \").concat(node));\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Return a generator of all the descendant node entries inside a root node.\r\n   */\n  descendants: /*#__PURE__*/_regeneratorRuntime.mark(function descendants(root) {\n    var options,\n        _iterator10,\n        _step10,\n        _step10$value,\n        node,\n        path,\n        _args6 = arguments;\n\n    return _regeneratorRuntime.wrap(function descendants$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            options = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {};\n            _iterator10 = _createForOfIteratorHelper(Node.nodes(root, options));\n            _context6.prev = 2;\n\n            _iterator10.s();\n\n          case 4:\n            if ((_step10 = _iterator10.n()).done) {\n              _context6.next = 11;\n              break;\n            }\n\n            _step10$value = _slicedToArray(_step10.value, 2), node = _step10$value[0], path = _step10$value[1];\n\n            if (!(path.length !== 0)) {\n              _context6.next = 9;\n              break;\n            }\n\n            _context6.next = 9;\n            return [node, path];\n\n          case 9:\n            _context6.next = 4;\n            break;\n\n          case 11:\n            _context6.next = 16;\n            break;\n\n          case 13:\n            _context6.prev = 13;\n            _context6.t0 = _context6[\"catch\"](2);\n\n            _iterator10.e(_context6.t0);\n\n          case 16:\n            _context6.prev = 16;\n\n            _iterator10.f();\n\n            return _context6.finish(16);\n\n          case 19:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, descendants, null, [[2, 13, 16, 19]]);\n  }),\n\n  /**\r\n   * Return a generator of all the element nodes inside a root node. Each iteration\r\n   * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the\r\n   * root node is an element it will be included in the iteration as well.\r\n   */\n  elements: /*#__PURE__*/_regeneratorRuntime.mark(function elements(root) {\n    var options,\n        _iterator11,\n        _step11,\n        _step11$value,\n        node,\n        path,\n        _args7 = arguments;\n\n    return _regeneratorRuntime.wrap(function elements$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            options = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : {};\n            _iterator11 = _createForOfIteratorHelper(Node.nodes(root, options));\n            _context7.prev = 2;\n\n            _iterator11.s();\n\n          case 4:\n            if ((_step11 = _iterator11.n()).done) {\n              _context7.next = 11;\n              break;\n            }\n\n            _step11$value = _slicedToArray(_step11.value, 2), node = _step11$value[0], path = _step11$value[1];\n\n            if (!Element.isElement(node)) {\n              _context7.next = 9;\n              break;\n            }\n\n            _context7.next = 9;\n            return [node, path];\n\n          case 9:\n            _context7.next = 4;\n            break;\n\n          case 11:\n            _context7.next = 16;\n            break;\n\n          case 13:\n            _context7.prev = 13;\n            _context7.t0 = _context7[\"catch\"](2);\n\n            _iterator11.e(_context7.t0);\n\n          case 16:\n            _context7.prev = 16;\n\n            _iterator11.f();\n\n            return _context7.finish(16);\n\n          case 19:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, elements, null, [[2, 13, 16, 19]]);\n  }),\n\n  /**\r\n   * Get the first node entry in a root node from a path.\r\n   */\n  first: function first(root, path) {\n    var p = path.slice();\n    var n = Node.get(root, p);\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break;\n      } else {\n        n = n.children[0];\n        p.push(0);\n      }\n    }\n\n    return [n, p];\n  },\n\n  /**\r\n   * Get the sliced fragment represented by a range inside a root node.\r\n   */\n  fragment: function fragment(root, range) {\n    if (Text.isText(root)) {\n      throw new Error(\"Cannot get a fragment starting from a root text node: \".concat(JSON.stringify(root)));\n    }\n\n    var newRoot = produce(root, function (r) {\n      var _Range$edges9 = Range.edges(range),\n          _Range$edges10 = _slicedToArray(_Range$edges9, 2),\n          start = _Range$edges10[0],\n          end = _Range$edges10[1];\n\n      var nodeEntries = Node.nodes(r, {\n        reverse: true,\n        pass: function pass(_ref) {\n          var _ref8 = _slicedToArray(_ref, 2),\n              path = _ref8[1];\n\n          return !Range.includes(range, path);\n        }\n      });\n\n      var _iterator12 = _createForOfIteratorHelper(nodeEntries),\n          _step12;\n\n      try {\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          var _step12$value = _slicedToArray(_step12.value, 2),\n              path = _step12$value[1];\n\n          if (!Range.includes(range, path)) {\n            var parent = Node.parent(r, path);\n            var index = path[path.length - 1];\n            parent.children.splice(index, 1);\n          }\n\n          if (Path.equals(path, end.path)) {\n            var leaf = Node.leaf(r, path);\n            leaf.text = leaf.text.slice(0, end.offset);\n          }\n\n          if (Path.equals(path, start.path)) {\n            var _leaf = Node.leaf(r, path);\n\n            _leaf.text = _leaf.text.slice(start.offset);\n          }\n        }\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n\n      delete r.selection;\n    });\n    return newRoot.children;\n  },\n\n  /**\r\n   * Get the descendant node referred to by a specific path. If the path is an\r\n   * empty array, it refers to the root node itself.\r\n   */\n  get: function get(root, path) {\n    var node = root;\n\n    for (var i = 0; i < path.length; i++) {\n      var p = path[i];\n\n      if (Text.isText(node) || !node.children[p]) {\n        throw new Error(\"Cannot find a descendant at path [\".concat(path, \"] in node: \").concat(JSON.stringify(root)));\n      }\n\n      node = node.children[p];\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Check if a descendant node exists at a specific path.\r\n   */\n  has: function has(root, path) {\n    var node = root;\n\n    for (var i = 0; i < path.length; i++) {\n      var p = path[i];\n\n      if (Text.isText(node) || !node.children[p]) {\n        return false;\n      }\n\n      node = node.children[p];\n    }\n\n    return true;\n  },\n\n  /**\r\n   * Check if a value implements the `Node` interface.\r\n   */\n  isNode: function isNode(value) {\n    return Text.isText(value) || Element.isElement(value) || Editor.isEditor(value);\n  },\n\n  /**\r\n   * Check if a value is a list of `Node` objects.\r\n   */\n  isNodeList: function isNodeList(value) {\n    return Array.isArray(value) && (value.length === 0 || Node.isNode(value[0]));\n  },\n\n  /**\r\n   * Get the last node entry in a root node from a path.\r\n   */\n  last: function last(root, path) {\n    var p = path.slice();\n    var n = Node.get(root, p);\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break;\n      } else {\n        var i = n.children.length - 1;\n        n = n.children[i];\n        p.push(i);\n      }\n    }\n\n    return [n, p];\n  },\n\n  /**\r\n   * Get the node at a specific path, ensuring it's a leaf text node.\r\n   */\n  leaf: function leaf(root, path) {\n    var node = Node.get(root, path);\n\n    if (!Text.isText(node)) {\n      throw new Error(\"Cannot get the leaf node at path [\".concat(path, \"] because it refers to a non-leaf node: \").concat(node));\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Return a generator of the in a branch of the tree, from a specific path.\r\n   *\r\n   * By default the order is top-down, from lowest to highest node in the tree,\r\n   * but you can pass the `reverse: true` option to go bottom-up.\r\n   */\n  levels: /*#__PURE__*/_regeneratorRuntime.mark(function levels(root, path) {\n    var options,\n        _iterator13,\n        _step13,\n        p,\n        n,\n        _args8 = arguments;\n\n    return _regeneratorRuntime.wrap(function levels$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            options = _args8.length > 2 && _args8[2] !== undefined ? _args8[2] : {};\n            _iterator13 = _createForOfIteratorHelper(Path.levels(path, options));\n            _context8.prev = 2;\n\n            _iterator13.s();\n\n          case 4:\n            if ((_step13 = _iterator13.n()).done) {\n              _context8.next = 11;\n              break;\n            }\n\n            p = _step13.value;\n            n = Node.get(root, p);\n            _context8.next = 9;\n            return [n, p];\n\n          case 9:\n            _context8.next = 4;\n            break;\n\n          case 11:\n            _context8.next = 16;\n            break;\n\n          case 13:\n            _context8.prev = 13;\n            _context8.t0 = _context8[\"catch\"](2);\n\n            _iterator13.e(_context8.t0);\n\n          case 16:\n            _context8.prev = 16;\n\n            _iterator13.f();\n\n            return _context8.finish(16);\n\n          case 19:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, levels, null, [[2, 13, 16, 19]]);\n  }),\n\n  /**\r\n   * Check if a node matches a set of props.\r\n   */\n  matches: function matches(node, props) {\n    return Element.isElement(node) && Element.matches(node, props) || Text.isText(node) && Text.matches(node, props);\n  },\n\n  /**\r\n   * Return a generator of all the node entries of a root node. Each entry is\r\n   * returned as a `[Node, Path]` tuple, with the path referring to the node's\r\n   * position inside the root node.\r\n   */\n  nodes: /*#__PURE__*/_regeneratorRuntime.mark(function nodes(root) {\n    var options,\n        pass,\n        _options$reverse5,\n        reverse,\n        _options$from,\n        from,\n        to,\n        visited,\n        p,\n        n,\n        nextIndex,\n        newPath,\n        _newPath,\n        _args9 = arguments;\n\n    return _regeneratorRuntime.wrap(function nodes$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            options = _args9.length > 1 && _args9[1] !== undefined ? _args9[1] : {};\n            pass = options.pass, _options$reverse5 = options.reverse, reverse = _options$reverse5 === void 0 ? false : _options$reverse5;\n            _options$from = options.from, from = _options$from === void 0 ? [] : _options$from, to = options.to;\n            visited = new Set();\n            p = [];\n            n = root;\n\n          case 6:\n            if (!true) {\n              _context9.next = 37;\n              break;\n            }\n\n            if (!(to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to)))) {\n              _context9.next = 9;\n              break;\n            }\n\n            return _context9.abrupt(\"break\", 37);\n\n          case 9:\n            if (visited.has(n)) {\n              _context9.next = 12;\n              break;\n            }\n\n            _context9.next = 12;\n            return [n, p];\n\n          case 12:\n            if (!(!visited.has(n) && !Text.isText(n) && n.children.length !== 0 && (pass == null || pass([n, p]) === false))) {\n              _context9.next = 19;\n              break;\n            }\n\n            visited.add(n);\n            nextIndex = reverse ? n.children.length - 1 : 0;\n\n            if (Path.isAncestor(p, from)) {\n              nextIndex = from[p.length];\n            }\n\n            p = p.concat(nextIndex);\n            n = Node.get(root, p);\n            return _context9.abrupt(\"continue\", 6);\n\n          case 19:\n            if (!(p.length === 0)) {\n              _context9.next = 21;\n              break;\n            }\n\n            return _context9.abrupt(\"break\", 37);\n\n          case 21:\n            if (reverse) {\n              _context9.next = 27;\n              break;\n            }\n\n            newPath = Path.next(p);\n\n            if (!Node.has(root, newPath)) {\n              _context9.next = 27;\n              break;\n            }\n\n            p = newPath;\n            n = Node.get(root, p);\n            return _context9.abrupt(\"continue\", 6);\n\n          case 27:\n            if (!(reverse && p[p.length - 1] !== 0)) {\n              _context9.next = 32;\n              break;\n            }\n\n            _newPath = Path.previous(p);\n            p = _newPath;\n            n = Node.get(root, p);\n            return _context9.abrupt(\"continue\", 6);\n\n          case 32:\n            // Otherwise we're going upward...\n            p = Path.parent(p);\n            n = Node.get(root, p);\n            visited.add(n);\n            _context9.next = 6;\n            break;\n\n          case 37:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, nodes);\n  }),\n\n  /**\r\n   * Get the parent of a node at a specific path.\r\n   */\n  parent: function parent(root, path) {\n    var parentPath = Path.parent(path);\n    var p = Node.get(root, parentPath);\n\n    if (Text.isText(p)) {\n      throw new Error(\"Cannot get the parent of path [\".concat(path, \"] because it does not exist in the root.\"));\n    }\n\n    return p;\n  },\n\n  /**\r\n   * Get the concatenated text string of a node's content.\r\n   *\r\n   * Note that this will not include spaces or line breaks between block nodes.\r\n   * It is not a user-facing string, but a string for performing offset-related\r\n   * computations for a node.\r\n   */\n  string: function string(node) {\n    if (Text.isText(node)) {\n      return node.text;\n    } else {\n      return node.children.map(Node.string).join('');\n    }\n  },\n\n  /**\r\n   * Return a generator of all leaf text nodes in a root node.\r\n   */\n  texts: /*#__PURE__*/_regeneratorRuntime.mark(function texts(root) {\n    var options,\n        _iterator14,\n        _step14,\n        _step14$value,\n        node,\n        path,\n        _args10 = arguments;\n\n    return _regeneratorRuntime.wrap(function texts$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            options = _args10.length > 1 && _args10[1] !== undefined ? _args10[1] : {};\n            _iterator14 = _createForOfIteratorHelper(Node.nodes(root, options));\n            _context10.prev = 2;\n\n            _iterator14.s();\n\n          case 4:\n            if ((_step14 = _iterator14.n()).done) {\n              _context10.next = 11;\n              break;\n            }\n\n            _step14$value = _slicedToArray(_step14.value, 2), node = _step14$value[0], path = _step14$value[1];\n\n            if (!Text.isText(node)) {\n              _context10.next = 9;\n              break;\n            }\n\n            _context10.next = 9;\n            return [node, path];\n\n          case 9:\n            _context10.next = 4;\n            break;\n\n          case 11:\n            _context10.next = 16;\n            break;\n\n          case 13:\n            _context10.prev = 13;\n            _context10.t0 = _context10[\"catch\"](2);\n\n            _iterator14.e(_context10.t0);\n\n          case 16:\n            _context10.prev = 16;\n\n            _iterator14.f();\n\n            return _context10.finish(16);\n\n          case 19:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n    }, texts, null, [[2, 13, 16, 19]]);\n  })\n};\n\nfunction ownKeys$1(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$1(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$1(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$1(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar Operation = {\n  /**\r\n   * Check of a value is a `NodeOperation` object.\r\n   */\n  isNodeOperation: function isNodeOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_node');\n  },\n\n  /**\r\n   * Check of a value is an `Operation` object.\r\n   */\n  isOperation: function isOperation(value) {\n    if (!isPlainObject(value)) {\n      return false;\n    }\n\n    switch (value.type) {\n      case 'insert_node':\n        return Path.isPath(value.path) && Node.isNode(value.node);\n\n      case 'insert_text':\n        return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);\n\n      case 'merge_node':\n        return typeof value.position === 'number' && Path.isPath(value.path) && isPlainObject(value.properties);\n\n      case 'move_node':\n        return Path.isPath(value.path) && Path.isPath(value.newPath);\n\n      case 'remove_node':\n        return Path.isPath(value.path) && Node.isNode(value.node);\n\n      case 'remove_text':\n        return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);\n\n      case 'set_node':\n        return Path.isPath(value.path) && isPlainObject(value.properties) && isPlainObject(value.newProperties);\n\n      case 'set_selection':\n        return value.properties === null && Range.isRange(value.newProperties) || value.newProperties === null && Range.isRange(value.properties) || isPlainObject(value.properties) && isPlainObject(value.newProperties);\n\n      case 'split_node':\n        return Path.isPath(value.path) && typeof value.position === 'number' && isPlainObject(value.properties);\n\n      default:\n        return false;\n    }\n  },\n\n  /**\r\n   * Check if a value is a list of `Operation` objects.\r\n   */\n  isOperationList: function isOperationList(value) {\n    return Array.isArray(value) && (value.length === 0 || Operation.isOperation(value[0]));\n  },\n\n  /**\r\n   * Check of a value is a `SelectionOperation` object.\r\n   */\n  isSelectionOperation: function isSelectionOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_selection');\n  },\n\n  /**\r\n   * Check of a value is a `TextOperation` object.\r\n   */\n  isTextOperation: function isTextOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_text');\n  },\n\n  /**\r\n   * Invert an operation, returning a new operation that will exactly undo the\r\n   * original when applied.\r\n   */\n  inverse: function inverse(op) {\n    switch (op.type) {\n      case 'insert_node':\n        {\n          return _objectSpread$1({}, op, {\n            type: 'remove_node'\n          });\n        }\n\n      case 'insert_text':\n        {\n          return _objectSpread$1({}, op, {\n            type: 'remove_text'\n          });\n        }\n\n      case 'merge_node':\n        {\n          return _objectSpread$1({}, op, {\n            type: 'split_node',\n            path: Path.previous(op.path)\n          });\n        }\n\n      case 'move_node':\n        {\n          var newPath = op.newPath,\n              path = op.path; // PERF: in this case the move operation is a no-op anyways.\n\n          if (Path.equals(newPath, path)) {\n            return op;\n          } // If the move happens completely within a single parent the path and\n          // newPath are stable with respect to each other.\n\n\n          if (Path.isSibling(path, newPath)) {\n            return _objectSpread$1({}, op, {\n              path: newPath,\n              newPath: path\n            });\n          } // If the move does not happen within a single parent it is possible\n          // for the move to impact the true path to the location where the node\n          // was removed from and where it was inserted. We have to adjust for this\n          // and find the original path. We can accomplish this (only in non-sibling)\n          // moves by looking at the impact of the move operation on the node\n          // after the original move path.\n\n\n          var inversePath = Path.transform(path, op);\n          var inverseNewPath = Path.transform(Path.next(path), op);\n          return _objectSpread$1({}, op, {\n            path: inversePath,\n            newPath: inverseNewPath\n          });\n        }\n\n      case 'remove_node':\n        {\n          return _objectSpread$1({}, op, {\n            type: 'insert_node'\n          });\n        }\n\n      case 'remove_text':\n        {\n          return _objectSpread$1({}, op, {\n            type: 'insert_text'\n          });\n        }\n\n      case 'set_node':\n        {\n          var properties = op.properties,\n              newProperties = op.newProperties;\n          return _objectSpread$1({}, op, {\n            properties: newProperties,\n            newProperties: properties\n          });\n        }\n\n      case 'set_selection':\n        {\n          var _properties = op.properties,\n              _newProperties = op.newProperties;\n\n          if (_properties == null) {\n            return _objectSpread$1({}, op, {\n              properties: _newProperties,\n              newProperties: null\n            });\n          } else if (_newProperties == null) {\n            return _objectSpread$1({}, op, {\n              properties: null,\n              newProperties: _properties\n            });\n          } else {\n            return _objectSpread$1({}, op, {\n              properties: _newProperties,\n              newProperties: _properties\n            });\n          }\n        }\n\n      case 'split_node':\n        {\n          return _objectSpread$1({}, op, {\n            type: 'merge_node',\n            path: Path.next(op.path)\n          });\n        }\n    }\n  }\n};\nvar Path = {\n  /**\r\n   * Get a list of ancestor paths for a given path.\r\n   *\r\n   * The paths are sorted from deepest to shallowest ancestor. However, if the\r\n   * `reverse: true` option is passed, they are reversed.\r\n   */\n  ancestors: function ancestors(path) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$reverse6 = options.reverse,\n        reverse = _options$reverse6 === void 0 ? false : _options$reverse6;\n    var paths = Path.levels(path, options);\n\n    if (reverse) {\n      paths = paths.slice(1);\n    } else {\n      paths = paths.slice(0, -1);\n    }\n\n    return paths;\n  },\n\n  /**\r\n   * Get the common ancestor path of two paths.\r\n   */\n  common: function common(path, another) {\n    var common = [];\n\n    for (var i = 0; i < path.length && i < another.length; i++) {\n      var av = path[i];\n      var bv = another[i];\n\n      if (av !== bv) {\n        break;\n      }\n\n      common.push(av);\n    }\n\n    return common;\n  },\n\n  /**\r\n   * Compare a path to another, returning an integer indicating whether the path\r\n   * was before, at, or after the other.\r\n   *\r\n   * Note: Two paths of unequal length can still receive a `0` result if one is\r\n   * directly above or below the other. If you want exact matching, use\r\n   * [[Path.equals]] instead.\r\n   */\n  compare: function compare(path, another) {\n    var min = Math.min(path.length, another.length);\n\n    for (var i = 0; i < min; i++) {\n      if (path[i] < another[i]) return -1;\n      if (path[i] > another[i]) return 1;\n    }\n\n    return 0;\n  },\n\n  /**\r\n   * Check if a path ends after one of the indexes in another.\r\n   */\n  endsAfter: function endsAfter(path, another) {\n    var i = path.length - 1;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    var av = path[i];\n    var bv = another[i];\n    return Path.equals(as, bs) && av > bv;\n  },\n\n  /**\r\n   * Check if a path ends at one of the indexes in another.\r\n   */\n  endsAt: function endsAt(path, another) {\n    var i = path.length;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    return Path.equals(as, bs);\n  },\n\n  /**\r\n   * Check if a path ends before one of the indexes in another.\r\n   */\n  endsBefore: function endsBefore(path, another) {\n    var i = path.length - 1;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    var av = path[i];\n    var bv = another[i];\n    return Path.equals(as, bs) && av < bv;\n  },\n\n  /**\r\n   * Check if a path is exactly equal to another.\r\n   */\n  equals: function equals(path, another) {\n    return path.length === another.length && path.every(function (n, i) {\n      return n === another[i];\n    });\n  },\n\n  /**\r\n   * Check if a path is after another.\r\n   */\n  isAfter: function isAfter(path, another) {\n    return Path.compare(path, another) === 1;\n  },\n\n  /**\r\n   * Check if a path is an ancestor of another.\r\n   */\n  isAncestor: function isAncestor(path, another) {\n    return path.length < another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is before another.\r\n   */\n  isBefore: function isBefore(path, another) {\n    return Path.compare(path, another) === -1;\n  },\n\n  /**\r\n   * Check if a path is a child of another.\r\n   */\n  isChild: function isChild(path, another) {\n    return path.length === another.length + 1 && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is equal to or an ancestor of another.\r\n   */\n  isCommon: function isCommon(path, another) {\n    return path.length <= another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is a descendant of another.\r\n   */\n  isDescendant: function isDescendant(path, another) {\n    return path.length > another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is the parent of another.\r\n   */\n  isParent: function isParent(path, another) {\n    return path.length + 1 === another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check is a value implements the `Path` interface.\r\n   */\n  isPath: function isPath(value) {\n    return Array.isArray(value) && (value.length === 0 || typeof value[0] === 'number');\n  },\n\n  /**\r\n   * Check if a path is a sibling of another.\r\n   */\n  isSibling: function isSibling(path, another) {\n    if (path.length !== another.length) {\n      return false;\n    }\n\n    var as = path.slice(0, -1);\n    var bs = another.slice(0, -1);\n    var al = path[path.length - 1];\n    var bl = another[another.length - 1];\n    return al !== bl && Path.equals(as, bs);\n  },\n\n  /**\r\n   * Get a list of paths at every level down to a path. Note: this is the same\r\n   * as `Path.ancestors`, but including the path itself.\r\n   *\r\n   * The paths are sorted from shallowest to deepest. However, if the `reverse:\r\n   * true` option is passed, they are reversed.\r\n   */\n  levels: function levels(path) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$reverse7 = options.reverse,\n        reverse = _options$reverse7 === void 0 ? false : _options$reverse7;\n    var list = [];\n\n    for (var i = 0; i <= path.length; i++) {\n      list.push(path.slice(0, i));\n    }\n\n    if (reverse) {\n      list.reverse();\n    }\n\n    return list;\n  },\n\n  /**\r\n   * Given a path, get the path to the next sibling node.\r\n   */\n  next: function next(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the next path of a root path [\".concat(path, \"], because it has no next index.\"));\n    }\n\n    var last = path[path.length - 1];\n    return path.slice(0, -1).concat(last + 1);\n  },\n\n  /**\r\n   * Given a path, return a new path referring to the parent node above it.\r\n   */\n  parent: function parent(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the parent path of the root path [\".concat(path, \"].\"));\n    }\n\n    return path.slice(0, -1);\n  },\n\n  /**\r\n   * Given a path, get the path to the previous sibling node.\r\n   */\n  previous: function previous(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the previous path of a root path [\".concat(path, \"], because it has no previous index.\"));\n    }\n\n    var last = path[path.length - 1];\n\n    if (last <= 0) {\n      throw new Error(\"Cannot get the previous path of a first child path [\".concat(path, \"] because it would result in a negative index.\"));\n    }\n\n    return path.slice(0, -1).concat(last - 1);\n  },\n\n  /**\r\n   * Get a path relative to an ancestor.\r\n   */\n  relative: function relative(path, ancestor) {\n    if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {\n      throw new Error(\"Cannot get the relative path of [\".concat(path, \"] inside ancestor [\").concat(ancestor, \"], because it is not above or equal to the path.\"));\n    }\n\n    return path.slice(ancestor.length);\n  },\n\n  /**\r\n   * Transform a path by an operation.\r\n   */\n  transform: function transform(path, operation) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return produce(path, function (p) {\n      var _options$affinity4 = options.affinity,\n          affinity = _options$affinity4 === void 0 ? 'forward' : _options$affinity4; // PERF: Exit early if the operation is guaranteed not to have an effect.\n\n      if (path.length === 0) {\n        return;\n      }\n\n      switch (operation.type) {\n        case 'insert_node':\n          {\n            var op = operation.path;\n\n            if (Path.equals(op, p) || Path.endsBefore(op, p) || Path.isAncestor(op, p)) {\n              p[op.length - 1] += 1;\n            }\n\n            break;\n          }\n\n        case 'remove_node':\n          {\n            var _op = operation.path;\n\n            if (Path.equals(_op, p) || Path.isAncestor(_op, p)) {\n              return null;\n            } else if (Path.endsBefore(_op, p)) {\n              p[_op.length - 1] -= 1;\n            }\n\n            break;\n          }\n\n        case 'merge_node':\n          {\n            var _op2 = operation.path,\n                position = operation.position;\n\n            if (Path.equals(_op2, p) || Path.endsBefore(_op2, p)) {\n              p[_op2.length - 1] -= 1;\n            } else if (Path.isAncestor(_op2, p)) {\n              p[_op2.length - 1] -= 1;\n              p[_op2.length] += position;\n            }\n\n            break;\n          }\n\n        case 'split_node':\n          {\n            var _op3 = operation.path,\n                _position = operation.position;\n\n            if (Path.equals(_op3, p)) {\n              if (affinity === 'forward') {\n                p[p.length - 1] += 1;\n              } else if (affinity === 'backward') ;else {\n                return null;\n              }\n            } else if (Path.endsBefore(_op3, p)) {\n              p[_op3.length - 1] += 1;\n            } else if (Path.isAncestor(_op3, p) && path[_op3.length] >= _position) {\n              p[_op3.length - 1] += 1;\n              p[_op3.length] -= _position;\n            }\n\n            break;\n          }\n\n        case 'move_node':\n          {\n            var _op4 = operation.path,\n                onp = operation.newPath; // If the old and new path are the same, it's a no-op.\n\n            if (Path.equals(_op4, onp)) {\n              return;\n            }\n\n            if (Path.isAncestor(_op4, p) || Path.equals(_op4, p)) {\n              var copy = onp.slice();\n\n              if (Path.endsBefore(_op4, onp) && _op4.length < onp.length) {\n                copy[_op4.length - 1] -= 1;\n              }\n\n              return copy.concat(p.slice(_op4.length));\n            } else if (Path.isSibling(_op4, onp) && (Path.isAncestor(onp, p) || Path.equals(onp, p))) {\n              if (Path.endsBefore(_op4, p)) {\n                p[_op4.length - 1] -= 1;\n              } else {\n                p[_op4.length - 1] += 1;\n              }\n            } else if (Path.endsBefore(onp, p) || Path.equals(onp, p) || Path.isAncestor(onp, p)) {\n              if (Path.endsBefore(_op4, p)) {\n                p[_op4.length - 1] -= 1;\n              }\n\n              p[onp.length - 1] += 1;\n            } else if (Path.endsBefore(_op4, p)) {\n              if (Path.equals(onp, p)) {\n                p[onp.length - 1] += 1;\n              }\n\n              p[_op4.length - 1] -= 1;\n            }\n\n            break;\n          }\n      }\n    });\n  }\n};\nvar PathRef = {\n  /**\r\n   * Transform the path ref's current value by an operation.\r\n   */\n  transform: function transform(ref, op) {\n    var current = ref.current,\n        affinity = ref.affinity;\n\n    if (current == null) {\n      return;\n    }\n\n    var path = Path.transform(current, op, {\n      affinity: affinity\n    });\n    ref.current = path;\n\n    if (path == null) {\n      ref.unref();\n    }\n  }\n};\n\nfunction ownKeys$2(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$2(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$2(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar Point = {\n  /**\r\n   * Compare a point to another, returning an integer indicating whether the\r\n   * point was before, at, or after the other.\r\n   */\n  compare: function compare(point, another) {\n    var result = Path.compare(point.path, another.path);\n\n    if (result === 0) {\n      if (point.offset < another.offset) return -1;\n      if (point.offset > another.offset) return 1;\n      return 0;\n    }\n\n    return result;\n  },\n\n  /**\r\n   * Check if a point is after another.\r\n   */\n  isAfter: function isAfter(point, another) {\n    return Point.compare(point, another) === 1;\n  },\n\n  /**\r\n   * Check if a point is before another.\r\n   */\n  isBefore: function isBefore(point, another) {\n    return Point.compare(point, another) === -1;\n  },\n\n  /**\r\n   * Check if a point is exactly equal to another.\r\n   */\n  equals: function equals(point, another) {\n    // PERF: ensure the offsets are equal first since they are cheaper to check.\n    return point.offset === another.offset && Path.equals(point.path, another.path);\n  },\n\n  /**\r\n   * Check if a value implements the `Point` interface.\r\n   */\n  isPoint: function isPoint(value) {\n    return isPlainObject(value) && typeof value.offset === 'number' && Path.isPath(value.path);\n  },\n\n  /**\r\n   * Transform a point by an operation.\r\n   */\n  transform: function transform(point, op) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return produce(point, function (p) {\n      var _options$affinity5 = options.affinity,\n          affinity = _options$affinity5 === void 0 ? 'forward' : _options$affinity5;\n      var path = p.path,\n          offset = p.offset;\n\n      switch (op.type) {\n        case 'insert_node':\n        case 'move_node':\n          {\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n\n        case 'insert_text':\n          {\n            if (Path.equals(op.path, path) && op.offset <= offset) {\n              p.offset += op.text.length;\n            }\n\n            break;\n          }\n\n        case 'merge_node':\n          {\n            if (Path.equals(op.path, path)) {\n              p.offset += op.position;\n            }\n\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n\n        case 'remove_text':\n          {\n            if (Path.equals(op.path, path) && op.offset <= offset) {\n              p.offset -= Math.min(offset - op.offset, op.text.length);\n            }\n\n            break;\n          }\n\n        case 'remove_node':\n          {\n            if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {\n              return null;\n            }\n\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n\n        case 'split_node':\n          {\n            if (Path.equals(op.path, path)) {\n              if (op.position === offset && affinity == null) {\n                return null;\n              } else if (op.position < offset || op.position === offset && affinity === 'forward') {\n                p.offset -= op.position;\n                p.path = Path.transform(path, op, _objectSpread$2({}, options, {\n                  affinity: 'forward'\n                }));\n              }\n            } else {\n              p.path = Path.transform(path, op, options);\n            }\n\n            break;\n          }\n      }\n    });\n  }\n};\nvar PointRef = {\n  /**\r\n   * Transform the point ref's current value by an operation.\r\n   */\n  transform: function transform(ref, op) {\n    var current = ref.current,\n        affinity = ref.affinity;\n\n    if (current == null) {\n      return;\n    }\n\n    var point = Point.transform(current, op, {\n      affinity: affinity\n    });\n    ref.current = point;\n\n    if (point == null) {\n      ref.unref();\n    }\n  }\n};\n\nfunction ownKeys$3(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$3(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$3(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$3(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar Range = {\n  /**\r\n   * Get the start and end points of a range, in the order in which they appear\r\n   * in the document.\r\n   */\n  edges: function edges(range) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$reverse8 = options.reverse,\n        reverse = _options$reverse8 === void 0 ? false : _options$reverse8;\n    var anchor = range.anchor,\n        focus = range.focus;\n    return Range.isBackward(range) === reverse ? [anchor, focus] : [focus, anchor];\n  },\n\n  /**\r\n   * Get the end point of a range.\r\n   */\n  end: function end(range) {\n    var _Range$edges11 = Range.edges(range),\n        _Range$edges12 = _slicedToArray(_Range$edges11, 2),\n        end = _Range$edges12[1];\n\n    return end;\n  },\n\n  /**\r\n   * Check if a range is exactly equal to another.\r\n   */\n  equals: function equals(range, another) {\n    return Point.equals(range.anchor, another.anchor) && Point.equals(range.focus, another.focus);\n  },\n\n  /**\r\n   * Check if a range includes a path, a point or part of another range.\r\n   */\n  includes: function includes(range, target) {\n    if (Range.isRange(target)) {\n      if (Range.includes(range, target.anchor) || Range.includes(range, target.focus)) {\n        return true;\n      }\n\n      var _Range$edges13 = Range.edges(range),\n          _Range$edges14 = _slicedToArray(_Range$edges13, 2),\n          rs = _Range$edges14[0],\n          re = _Range$edges14[1];\n\n      var _Range$edges15 = Range.edges(target),\n          _Range$edges16 = _slicedToArray(_Range$edges15, 2),\n          ts = _Range$edges16[0],\n          te = _Range$edges16[1];\n\n      return Point.isBefore(rs, ts) && Point.isAfter(re, te);\n    }\n\n    var _Range$edges17 = Range.edges(range),\n        _Range$edges18 = _slicedToArray(_Range$edges17, 2),\n        start = _Range$edges18[0],\n        end = _Range$edges18[1];\n\n    var isAfterStart = false;\n    var isBeforeEnd = false;\n\n    if (Point.isPoint(target)) {\n      isAfterStart = Point.compare(target, start) >= 0;\n      isBeforeEnd = Point.compare(target, end) <= 0;\n    } else {\n      isAfterStart = Path.compare(target, start.path) >= 0;\n      isBeforeEnd = Path.compare(target, end.path) <= 0;\n    }\n\n    return isAfterStart && isBeforeEnd;\n  },\n\n  /**\r\n   * Get the intersection of a range with another.\r\n   */\n  intersection: function intersection(range, another) {\n    var rest = _objectWithoutProperties(range, [\"anchor\", \"focus\"]);\n\n    var _Range$edges19 = Range.edges(range),\n        _Range$edges20 = _slicedToArray(_Range$edges19, 2),\n        s1 = _Range$edges20[0],\n        e1 = _Range$edges20[1];\n\n    var _Range$edges21 = Range.edges(another),\n        _Range$edges22 = _slicedToArray(_Range$edges21, 2),\n        s2 = _Range$edges22[0],\n        e2 = _Range$edges22[1];\n\n    var start = Point.isBefore(s1, s2) ? s2 : s1;\n    var end = Point.isBefore(e1, e2) ? e1 : e2;\n\n    if (Point.isBefore(end, start)) {\n      return null;\n    } else {\n      return _objectSpread$3({\n        anchor: start,\n        focus: end\n      }, rest);\n    }\n  },\n\n  /**\r\n   * Check if a range is backward, meaning that its anchor point appears in the\r\n   * document _after_ its focus point.\r\n   */\n  isBackward: function isBackward(range) {\n    var anchor = range.anchor,\n        focus = range.focus;\n    return Point.isAfter(anchor, focus);\n  },\n\n  /**\r\n   * Check if a range is collapsed, meaning that both its anchor and focus\r\n   * points refer to the exact same position in the document.\r\n   */\n  isCollapsed: function isCollapsed(range) {\n    var anchor = range.anchor,\n        focus = range.focus;\n    return Point.equals(anchor, focus);\n  },\n\n  /**\r\n   * Check if a range is expanded.\r\n   *\r\n   * This is the opposite of [[Range.isCollapsed]] and is provided for legibility.\r\n   */\n  isExpanded: function isExpanded(range) {\n    return !Range.isCollapsed(range);\n  },\n\n  /**\r\n   * Check if a range is forward.\r\n   *\r\n   * This is the opposite of [[Range.isBackward]] and is provided for legibility.\r\n   */\n  isForward: function isForward(range) {\n    return !Range.isBackward(range);\n  },\n\n  /**\r\n   * Check if a value implements the [[Range]] interface.\r\n   */\n  isRange: function isRange(value) {\n    return isPlainObject(value) && Point.isPoint(value.anchor) && Point.isPoint(value.focus);\n  },\n\n  /**\r\n   * Iterate through all of the point entries in a range.\r\n   */\n  points: /*#__PURE__*/_regeneratorRuntime.mark(function points(range) {\n    return _regeneratorRuntime.wrap(function points$(_context11) {\n      while (1) {\n        switch (_context11.prev = _context11.next) {\n          case 0:\n            _context11.next = 2;\n            return [range.anchor, 'anchor'];\n\n          case 2:\n            _context11.next = 4;\n            return [range.focus, 'focus'];\n\n          case 4:\n          case \"end\":\n            return _context11.stop();\n        }\n      }\n    }, points);\n  }),\n\n  /**\r\n   * Get the start point of a range.\r\n   */\n  start: function start(range) {\n    var _Range$edges23 = Range.edges(range),\n        _Range$edges24 = _slicedToArray(_Range$edges23, 1),\n        start = _Range$edges24[0];\n\n    return start;\n  },\n\n  /**\r\n   * Transform a range by an operation.\r\n   */\n  transform: function transform(range, op) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$affinity6 = options.affinity,\n        affinity = _options$affinity6 === void 0 ? 'inward' : _options$affinity6;\n    var affinityAnchor;\n    var affinityFocus;\n\n    if (affinity === 'inward') {\n      if (Range.isForward(range)) {\n        affinityAnchor = 'forward';\n        affinityFocus = 'backward';\n      } else {\n        affinityAnchor = 'backward';\n        affinityFocus = 'forward';\n      }\n    } else if (affinity === 'outward') {\n      if (Range.isForward(range)) {\n        affinityAnchor = 'backward';\n        affinityFocus = 'forward';\n      } else {\n        affinityAnchor = 'forward';\n        affinityFocus = 'backward';\n      }\n    } else {\n      affinityAnchor = affinity;\n      affinityFocus = affinity;\n    }\n\n    return produce(range, function (r) {\n      var anchor = Point.transform(r.anchor, op, {\n        affinity: affinityAnchor\n      });\n      var focus = Point.transform(r.focus, op, {\n        affinity: affinityFocus\n      });\n\n      if (!anchor || !focus) {\n        return null;\n      }\n\n      r.anchor = anchor;\n      r.focus = focus;\n    });\n  }\n};\nvar RangeRef = {\n  /**\r\n   * Transform the range ref's current value by an operation.\r\n   */\n  transform: function transform(ref, op) {\n    var current = ref.current,\n        affinity = ref.affinity;\n\n    if (current == null) {\n      return;\n    }\n\n    var path = Range.transform(current, op, {\n      affinity: affinity\n    });\n    ref.current = path;\n\n    if (path == null) {\n      ref.unref();\n    }\n  }\n};\n\nfunction ownKeys$4(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$4(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$4(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$4(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar Text = {\n  /**\r\n   * Check if two text nodes are equal.\r\n   */\n  equals: function equals(text, another) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$loose = options.loose,\n        loose = _options$loose === void 0 ? false : _options$loose;\n\n    for (var key in text) {\n      if (loose && key === 'text') {\n        continue;\n      }\n\n      if (text[key] !== another[key]) {\n        return false;\n      }\n    }\n\n    for (var _key in another) {\n      if (loose && _key === 'text') {\n        continue;\n      }\n\n      if (text[_key] !== another[_key]) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  /**\r\n   * Check if a value implements the `Text` interface.\r\n   */\n  isText: function isText(value) {\n    return isPlainObject(value) && typeof value.text === 'string';\n  },\n\n  /**\r\n   * Check if a value is a list of `Text` objects.\r\n   */\n  isTextList: function isTextList(value) {\n    return Array.isArray(value) && (value.length === 0 || Text.isText(value[0]));\n  },\n\n  /**\r\n   * Check if an text matches set of properties.\r\n   *\r\n   * Note: this is for matching custom properties, and it does not ensure that\r\n   * the `text` property are two nodes equal.\r\n   */\n  matches: function matches(text, props) {\n    for (var key in props) {\n      if (key === 'text') {\n        continue;\n      }\n\n      if (text[key] !== props[key]) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  /**\r\n   * Get the leaves for a text node given decorations.\r\n   */\n  decorations: function decorations(node, _decorations) {\n    var leaves = [_objectSpread$4({}, node)];\n\n    var _iterator15 = _createForOfIteratorHelper(_decorations),\n        _step15;\n\n    try {\n      for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n        var dec = _step15.value;\n\n        var rest = _objectWithoutProperties(dec, [\"anchor\", \"focus\"]);\n\n        var _Range$edges25 = Range.edges(dec),\n            _Range$edges26 = _slicedToArray(_Range$edges25, 2),\n            start = _Range$edges26[0],\n            end = _Range$edges26[1];\n\n        var next = [];\n        var o = 0;\n\n        var _iterator16 = _createForOfIteratorHelper(leaves),\n            _step16;\n\n        try {\n          for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n            var leaf = _step16.value;\n            var length = leaf.text.length;\n            var offset = o;\n            o += length; // If the range encompases the entire leaf, add the range.\n\n            if (start.offset <= offset && end.offset >= offset + length) {\n              Object.assign(leaf, rest);\n              next.push(leaf);\n              continue;\n            } // If the range starts after the leaf, or ends before it, continue.\n\n\n            if (start.offset > offset + length || end.offset < offset || end.offset === offset && offset !== 0) {\n              next.push(leaf);\n              continue;\n            } // Otherwise we need to split the leaf, at the start, end, or both,\n            // and add the range to the middle intersecting section. Do the end\n            // split first since we don't need to update the offset that way.\n\n\n            var middle = leaf;\n            var before = void 0;\n            var after = void 0;\n\n            if (end.offset < offset + length) {\n              var off = end.offset - offset;\n              after = _objectSpread$4({}, middle, {\n                text: middle.text.slice(off)\n              });\n              middle = _objectSpread$4({}, middle, {\n                text: middle.text.slice(0, off)\n              });\n            }\n\n            if (start.offset > offset) {\n              var _off = start.offset - offset;\n\n              before = _objectSpread$4({}, middle, {\n                text: middle.text.slice(0, _off)\n              });\n              middle = _objectSpread$4({}, middle, {\n                text: middle.text.slice(_off)\n              });\n            }\n\n            Object.assign(middle, rest);\n\n            if (before) {\n              next.push(before);\n            }\n\n            next.push(middle);\n\n            if (after) {\n              next.push(after);\n            }\n          }\n        } catch (err) {\n          _iterator16.e(err);\n        } finally {\n          _iterator16.f();\n        }\n\n        leaves = next;\n      }\n    } catch (err) {\n      _iterator15.e(err);\n    } finally {\n      _iterator15.f();\n    }\n\n    return leaves;\n  }\n};\n\nfunction ownKeys$5(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$5(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$5(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$5(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar GeneralTransforms = {\n  /**\r\n   * Transform the editor by an operation.\r\n   */\n  transform: function transform(editor, op) {\n    editor.children = createDraft(editor.children);\n    var selection = editor.selection && createDraft(editor.selection);\n\n    switch (op.type) {\n      case 'insert_node':\n        {\n          var path = op.path,\n              node = op.node;\n          var parent = Node.parent(editor, path);\n          var index = path[path.length - 1];\n          parent.children.splice(index, 0, node);\n\n          if (selection) {\n            var _iterator17 = _createForOfIteratorHelper(Range.points(selection)),\n                _step17;\n\n            try {\n              for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n                var _step17$value = _slicedToArray(_step17.value, 2),\n                    point = _step17$value[0],\n                    key = _step17$value[1];\n\n                selection[key] = Point.transform(point, op);\n              }\n            } catch (err) {\n              _iterator17.e(err);\n            } finally {\n              _iterator17.f();\n            }\n          }\n\n          break;\n        }\n\n      case 'insert_text':\n        {\n          var _path = op.path,\n              offset = op.offset,\n              text = op.text;\n\n          var _node = Node.leaf(editor, _path);\n\n          var before = _node.text.slice(0, offset);\n\n          var after = _node.text.slice(offset);\n\n          _node.text = before + text + after;\n\n          if (selection) {\n            var _iterator18 = _createForOfIteratorHelper(Range.points(selection)),\n                _step18;\n\n            try {\n              for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n                var _step18$value = _slicedToArray(_step18.value, 2),\n                    _point = _step18$value[0],\n                    _key = _step18$value[1];\n\n                selection[_key] = Point.transform(_point, op);\n              }\n            } catch (err) {\n              _iterator18.e(err);\n            } finally {\n              _iterator18.f();\n            }\n          }\n\n          break;\n        }\n\n      case 'merge_node':\n        {\n          var _path2 = op.path;\n\n          var _node2 = Node.get(editor, _path2);\n\n          var prevPath = Path.previous(_path2);\n          var prev = Node.get(editor, prevPath);\n\n          var _parent = Node.parent(editor, _path2);\n\n          var _index = _path2[_path2.length - 1];\n\n          if (Text.isText(_node2) && Text.isText(prev)) {\n            prev.text += _node2.text;\n          } else if (!Text.isText(_node2) && !Text.isText(prev)) {\n            var _prev$children;\n\n            (_prev$children = prev.children).push.apply(_prev$children, _toConsumableArray(_node2.children));\n          } else {\n            throw new Error(\"Cannot apply a \\\"merge_node\\\" operation at path [\".concat(_path2, \"] to nodes of different interaces: \").concat(_node2, \" \").concat(prev));\n          }\n\n          _parent.children.splice(_index, 1);\n\n          if (selection) {\n            var _iterator19 = _createForOfIteratorHelper(Range.points(selection)),\n                _step19;\n\n            try {\n              for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n                var _step19$value = _slicedToArray(_step19.value, 2),\n                    _point2 = _step19$value[0],\n                    _key2 = _step19$value[1];\n\n                selection[_key2] = Point.transform(_point2, op);\n              }\n            } catch (err) {\n              _iterator19.e(err);\n            } finally {\n              _iterator19.f();\n            }\n          }\n\n          break;\n        }\n\n      case 'move_node':\n        {\n          var _path3 = op.path,\n              newPath = op.newPath;\n\n          if (Path.isAncestor(_path3, newPath)) {\n            throw new Error(\"Cannot move a path [\".concat(_path3, \"] to new path [\").concat(newPath, \"] because the destination is inside itself.\"));\n          }\n\n          var _node3 = Node.get(editor, _path3);\n\n          var _parent2 = Node.parent(editor, _path3);\n\n          var _index2 = _path3[_path3.length - 1]; // This is tricky, but since the `path` and `newPath` both refer to\n          // the same snapshot in time, there's a mismatch. After either\n          // removing the original position, the second step's path can be out\n          // of date. So instead of using the `op.newPath` directly, we\n          // transform `op.path` to ascertain what the `newPath` would be after\n          // the operation was applied.\n\n          _parent2.children.splice(_index2, 1);\n\n          var truePath = Path.transform(_path3, op);\n          var newParent = Node.get(editor, Path.parent(truePath));\n          var newIndex = truePath[truePath.length - 1];\n          newParent.children.splice(newIndex, 0, _node3);\n\n          if (selection) {\n            var _iterator20 = _createForOfIteratorHelper(Range.points(selection)),\n                _step20;\n\n            try {\n              for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n                var _step20$value = _slicedToArray(_step20.value, 2),\n                    _point3 = _step20$value[0],\n                    _key3 = _step20$value[1];\n\n                selection[_key3] = Point.transform(_point3, op);\n              }\n            } catch (err) {\n              _iterator20.e(err);\n            } finally {\n              _iterator20.f();\n            }\n          }\n\n          break;\n        }\n\n      case 'remove_node':\n        {\n          var _path4 = op.path;\n          var _index3 = _path4[_path4.length - 1];\n\n          var _parent3 = Node.parent(editor, _path4);\n\n          _parent3.children.splice(_index3, 1); // Transform all of the points in the value, but if the point was in the\n          // node that was removed we need to update the range or remove it.\n\n\n          if (selection) {\n            var _iterator21 = _createForOfIteratorHelper(Range.points(selection)),\n                _step21;\n\n            try {\n              for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n                var _step21$value = _slicedToArray(_step21.value, 2),\n                    _point4 = _step21$value[0],\n                    _key4 = _step21$value[1];\n\n                var result = Point.transform(_point4, op);\n\n                if (selection != null && result != null) {\n                  selection[_key4] = result;\n                } else {\n                  var _prev = void 0;\n\n                  var next = void 0;\n\n                  var _iterator22 = _createForOfIteratorHelper(Node.texts(editor)),\n                      _step22;\n\n                  try {\n                    for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n                      var _step22$value = _slicedToArray(_step22.value, 2),\n                          n = _step22$value[0],\n                          p = _step22$value[1];\n\n                      if (Path.compare(p, _path4) === -1) {\n                        _prev = [n, p];\n                      } else {\n                        next = [n, p];\n                        break;\n                      }\n                    }\n                  } catch (err) {\n                    _iterator22.e(err);\n                  } finally {\n                    _iterator22.f();\n                  }\n\n                  if (_prev) {\n                    _point4.path = _prev[1];\n                    _point4.offset = _prev[0].text.length;\n                  } else if (next) {\n                    _point4.path = next[1];\n                    _point4.offset = 0;\n                  } else {\n                    selection = null;\n                  }\n                }\n              }\n            } catch (err) {\n              _iterator21.e(err);\n            } finally {\n              _iterator21.f();\n            }\n          }\n\n          break;\n        }\n\n      case 'remove_text':\n        {\n          var _path5 = op.path,\n              _offset = op.offset,\n              _text = op.text;\n\n          var _node4 = Node.leaf(editor, _path5);\n\n          var _before = _node4.text.slice(0, _offset);\n\n          var _after = _node4.text.slice(_offset + _text.length);\n\n          _node4.text = _before + _after;\n\n          if (selection) {\n            var _iterator23 = _createForOfIteratorHelper(Range.points(selection)),\n                _step23;\n\n            try {\n              for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n                var _step23$value = _slicedToArray(_step23.value, 2),\n                    _point5 = _step23$value[0],\n                    _key5 = _step23$value[1];\n\n                selection[_key5] = Point.transform(_point5, op);\n              }\n            } catch (err) {\n              _iterator23.e(err);\n            } finally {\n              _iterator23.f();\n            }\n          }\n\n          break;\n        }\n\n      case 'set_node':\n        {\n          var _path6 = op.path,\n              newProperties = op.newProperties;\n\n          if (_path6.length === 0) {\n            throw new Error(\"Cannot set properties on the root node!\");\n          }\n\n          var _node5 = Node.get(editor, _path6);\n\n          for (var _key6 in newProperties) {\n            if (_key6 === 'children' || _key6 === 'text') {\n              throw new Error(\"Cannot set the \\\"\".concat(_key6, \"\\\" property of nodes!\"));\n            }\n\n            var value = newProperties[_key6];\n\n            if (value == null) {\n              delete _node5[_key6];\n            } else {\n              _node5[_key6] = value;\n            }\n          }\n\n          break;\n        }\n\n      case 'set_selection':\n        {\n          var _newProperties = op.newProperties;\n\n          if (_newProperties == null) {\n            selection = _newProperties;\n          } else if (selection == null) {\n            if (!Range.isRange(_newProperties)) {\n              throw new Error(\"Cannot apply an incomplete \\\"set_selection\\\" operation properties \".concat(JSON.stringify(_newProperties), \" when there is no current selection.\"));\n            }\n\n            selection = _newProperties;\n          } else {\n            Object.assign(selection, _newProperties);\n          }\n\n          break;\n        }\n\n      case 'split_node':\n        {\n          var _path7 = op.path,\n              position = op.position,\n              properties = op.properties;\n\n          if (_path7.length === 0) {\n            throw new Error(\"Cannot apply a \\\"split_node\\\" operation at path [\".concat(_path7, \"] because the root node cannot be split.\"));\n          }\n\n          var _node6 = Node.get(editor, _path7);\n\n          var _parent4 = Node.parent(editor, _path7);\n\n          var _index4 = _path7[_path7.length - 1];\n          var newNode;\n\n          if (Text.isText(_node6)) {\n            var _before2 = _node6.text.slice(0, position);\n\n            var _after2 = _node6.text.slice(position);\n\n            _node6.text = _before2;\n            newNode = _objectSpread$5({}, _node6, {}, properties, {\n              text: _after2\n            });\n          } else {\n            var _before3 = _node6.children.slice(0, position);\n\n            var _after3 = _node6.children.slice(position);\n\n            _node6.children = _before3;\n            newNode = _objectSpread$5({}, _node6, {}, properties, {\n              children: _after3\n            });\n          }\n\n          _parent4.children.splice(_index4 + 1, 0, newNode);\n\n          if (selection) {\n            var _iterator24 = _createForOfIteratorHelper(Range.points(selection)),\n                _step24;\n\n            try {\n              for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n                var _step24$value = _slicedToArray(_step24.value, 2),\n                    _point6 = _step24$value[0],\n                    _key7 = _step24$value[1];\n\n                selection[_key7] = Point.transform(_point6, op);\n              }\n            } catch (err) {\n              _iterator24.e(err);\n            } finally {\n              _iterator24.f();\n            }\n          }\n\n          break;\n        }\n    }\n\n    editor.children = finishDraft(editor.children);\n\n    if (selection) {\n      editor.selection = isDraft(selection) ? finishDraft(selection) : selection;\n    } else {\n      editor.selection = null;\n    }\n  }\n};\n\nfunction ownKeys$6(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$6(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$6(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$6(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar NodeTransforms = {\n  /**\r\n   * Insert nodes at a specific location in the Editor.\r\n   */\n  insertNodes: function insertNodes(editor, nodes) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$hanging = options.hanging,\n          hanging = _options$hanging === void 0 ? false : _options$hanging,\n          _options$voids7 = options.voids,\n          voids = _options$voids7 === void 0 ? false : _options$voids7,\n          _options$mode5 = options.mode,\n          mode = _options$mode5 === void 0 ? 'lowest' : _options$mode5;\n      var at = options.at,\n          match = options.match,\n          select = options.select;\n\n      if (Node.isNode(nodes)) {\n        nodes = [nodes];\n      }\n\n      if (nodes.length === 0) {\n        return;\n      }\n\n      var _nodes = nodes,\n          _nodes2 = _slicedToArray(_nodes, 1),\n          node = _nodes2[0]; // By default, use the selection as the target location. But if there is\n      // no selection, insert at the end of the document since that is such a\n      // common use case when inserting from a non-selected state.\n\n\n      if (!at) {\n        if (editor.selection) {\n          at = editor.selection;\n        } else if (editor.children.length > 0) {\n          at = Editor.end(editor, []);\n        } else {\n          at = [0];\n        }\n\n        select = true;\n      }\n\n      if (select == null) {\n        select = false;\n      }\n\n      if (Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at);\n        }\n\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var _Range$edges27 = Range.edges(at),\n              _Range$edges28 = _slicedToArray(_Range$edges27, 2),\n              end = _Range$edges28[1];\n\n          var pointRef = Editor.pointRef(editor, end);\n          Transforms.delete(editor, {\n            at: at\n          });\n          at = pointRef.unref();\n        }\n      }\n\n      if (Point.isPoint(at)) {\n        if (match == null) {\n          if (Text.isText(node)) {\n            match = function match(n) {\n              return Text.isText(n);\n            };\n          } else if (editor.isInline(node)) {\n            match = function match(n) {\n              return Text.isText(n) || Editor.isInline(editor, n);\n            };\n          } else {\n            match = function match(n) {\n              return Editor.isBlock(editor, n);\n            };\n          }\n        }\n\n        var _Editor$nodes7 = Editor.nodes(editor, {\n          at: at.path,\n          match: match,\n          mode: mode,\n          voids: voids\n        }),\n            _Editor$nodes8 = _slicedToArray(_Editor$nodes7, 1),\n            entry = _Editor$nodes8[0];\n\n        if (entry) {\n          var _entry = _slicedToArray(entry, 2),\n              _matchPath = _entry[1];\n\n          var pathRef = Editor.pathRef(editor, _matchPath);\n          var isAtEnd = Editor.isEnd(editor, at, _matchPath);\n          Transforms.splitNodes(editor, {\n            at: at,\n            match: match,\n            mode: mode,\n            voids: voids\n          });\n          var path = pathRef.unref();\n          at = isAtEnd ? Path.next(path) : path;\n        } else {\n          return;\n        }\n      }\n\n      var parentPath = Path.parent(at);\n      var index = at[at.length - 1];\n\n      if (!voids && Editor.void(editor, {\n        at: parentPath\n      })) {\n        return;\n      }\n\n      var _iterator25 = _createForOfIteratorHelper(nodes),\n          _step25;\n\n      try {\n        for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n          var _node = _step25.value;\n\n          var _path = parentPath.concat(index);\n\n          index++;\n          editor.apply({\n            type: 'insert_node',\n            path: _path,\n            node: _node\n          });\n        }\n      } catch (err) {\n        _iterator25.e(err);\n      } finally {\n        _iterator25.f();\n      }\n\n      if (select) {\n        var point = Editor.end(editor, at);\n\n        if (point) {\n          Transforms.select(editor, point);\n        }\n      }\n    });\n  },\n\n  /**\r\n   * Lift nodes at a specific location upwards in the document tree, splitting\r\n   * their parent in two if necessary.\r\n   */\n  liftNodes: function liftNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$at7 = options.at,\n          at = _options$at7 === void 0 ? editor.selection : _options$at7,\n          _options$mode6 = options.mode,\n          mode = _options$mode6 === void 0 ? 'lowest' : _options$mode6,\n          _options$voids8 = options.voids,\n          voids = _options$voids8 === void 0 ? false : _options$voids8;\n      var match = options.match;\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : function (n) {\n          return Editor.isBlock(editor, n);\n        };\n      }\n\n      if (!at) {\n        return;\n      }\n\n      var matches = Editor.nodes(editor, {\n        at: at,\n        match: match,\n        mode: mode,\n        voids: voids\n      });\n      var pathRefs = Array.from(matches, function (_ref) {\n        var _ref9 = _slicedToArray(_ref, 2),\n            p = _ref9[1];\n\n        return Editor.pathRef(editor, p);\n      });\n\n      for (var _i = 0, _pathRefs = pathRefs; _i < _pathRefs.length; _i++) {\n        var pathRef = _pathRefs[_i];\n        var path = pathRef.unref();\n\n        if (path.length < 2) {\n          throw new Error(\"Cannot lift node at a path [\".concat(path, \"] because it has a depth of less than `2`.\"));\n        }\n\n        var parentNodeEntry = Editor.node(editor, Path.parent(path));\n\n        var _parentNodeEntry = _slicedToArray(parentNodeEntry, 2),\n            parent = _parentNodeEntry[0],\n            parentPath = _parentNodeEntry[1];\n\n        var index = path[path.length - 1];\n        var length = parent.children.length;\n\n        if (length === 1) {\n          var toPath = Path.next(parentPath);\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: toPath,\n            voids: voids\n          });\n          Transforms.removeNodes(editor, {\n            at: parentPath,\n            voids: voids\n          });\n        } else if (index === 0) {\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: parentPath,\n            voids: voids\n          });\n        } else if (index === length - 1) {\n          var _toPath = Path.next(parentPath);\n\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: _toPath,\n            voids: voids\n          });\n        } else {\n          var splitPath = Path.next(path);\n\n          var _toPath2 = Path.next(parentPath);\n\n          Transforms.splitNodes(editor, {\n            at: splitPath,\n            voids: voids\n          });\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: _toPath2,\n            voids: voids\n          });\n        }\n      }\n    });\n  },\n\n  /**\r\n   * Merge a node at a location with the previous node of the same depth,\r\n   * removing any empty containing nodes after the merge if necessary.\r\n   */\n  mergeNodes: function mergeNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var match = options.match,\n          _options$at8 = options.at,\n          at = _options$at8 === void 0 ? editor.selection : _options$at8;\n      var _options$hanging2 = options.hanging,\n          hanging = _options$hanging2 === void 0 ? false : _options$hanging2,\n          _options$voids9 = options.voids,\n          voids = _options$voids9 === void 0 ? false : _options$voids9,\n          _options$mode7 = options.mode,\n          mode = _options$mode7 === void 0 ? 'lowest' : _options$mode7;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          var _Editor$parent5 = Editor.parent(editor, at),\n              _Editor$parent6 = _slicedToArray(_Editor$parent5, 1),\n              parent = _Editor$parent6[0];\n\n          match = function match(n) {\n            return parent.children.includes(n);\n          };\n        } else {\n          match = function match(n) {\n            return Editor.isBlock(editor, n);\n          };\n        }\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at);\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var _Range$edges29 = Range.edges(at),\n              _Range$edges30 = _slicedToArray(_Range$edges29, 2),\n              end = _Range$edges30[1];\n\n          var pointRef = Editor.pointRef(editor, end);\n          Transforms.delete(editor, {\n            at: at\n          });\n          at = pointRef.unref();\n\n          if (options.at == null) {\n            Transforms.select(editor, at);\n          }\n        }\n      }\n\n      var _Editor$nodes9 = Editor.nodes(editor, {\n        at: at,\n        match: match,\n        voids: voids,\n        mode: mode\n      }),\n          _Editor$nodes10 = _slicedToArray(_Editor$nodes9, 1),\n          current = _Editor$nodes10[0];\n\n      var prev = Editor.previous(editor, {\n        at: at,\n        match: match,\n        voids: voids,\n        mode: mode\n      });\n\n      if (!current || !prev) {\n        return;\n      }\n\n      var _current = _slicedToArray(current, 2),\n          node = _current[0],\n          path = _current[1];\n\n      var _prev3 = _slicedToArray(prev, 2),\n          prevNode = _prev3[0],\n          prevPath = _prev3[1];\n\n      if (path.length === 0 || prevPath.length === 0) {\n        return;\n      }\n\n      var newPath = Path.next(prevPath);\n      var commonPath = Path.common(path, prevPath);\n      var isPreviousSibling = Path.isSibling(path, prevPath);\n      var levels = Array.from(Editor.levels(editor, {\n        at: path\n      }), function (_ref2) {\n        var _ref10 = _slicedToArray(_ref2, 1),\n            n = _ref10[0];\n\n        return n;\n      }).slice(commonPath.length).slice(0, -1); // Determine if the merge will leave an ancestor of the path empty as a\n      // result, in which case we'll want to remove it after merging.\n\n      var emptyAncestor = Editor.above(editor, {\n        at: path,\n        mode: 'highest',\n        match: function match(n) {\n          return levels.includes(n) && Element.isElement(n) && n.children.length === 1;\n        }\n      });\n      var emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1]);\n      var properties;\n      var position; // Ensure that the nodes are equivalent, and figure out what the position\n      // and extra properties of the merge will be.\n\n      if (Text.isText(node) && Text.isText(prevNode)) {\n        var rest = _objectWithoutProperties(node, [\"text\"]);\n\n        position = prevNode.text.length;\n        properties = rest;\n      } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n        var rest = _objectWithoutProperties(node, [\"children\"]);\n\n        position = prevNode.children.length;\n        properties = rest;\n      } else {\n        throw new Error(\"Cannot merge the node at path [\".concat(path, \"] with the previous sibling because it is not the same kind: \").concat(JSON.stringify(node), \" \").concat(JSON.stringify(prevNode)));\n      } // If the node isn't already the next sibling of the previous node, move\n      // it so that it is before merging.\n\n\n      if (!isPreviousSibling) {\n        Transforms.moveNodes(editor, {\n          at: path,\n          to: newPath,\n          voids: voids\n        });\n      } // If there was going to be an empty ancestor of the node that was merged,\n      // we remove it from the tree.\n\n\n      if (emptyRef) {\n        Transforms.removeNodes(editor, {\n          at: emptyRef.current,\n          voids: voids\n        });\n      } // If the target node that we're merging with is empty, remove it instead\n      // of merging the two. This is a common rich text editor behavior to\n      // prevent losing formatting when deleting entire nodes when you have a\n      // hanging selection.\n\n\n      if (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode) || Text.isText(prevNode) && prevNode.text === '') {\n        Transforms.removeNodes(editor, {\n          at: prevPath,\n          voids: voids\n        });\n      } else {\n        editor.apply({\n          type: 'merge_node',\n          path: newPath,\n          position: position,\n          properties: properties\n        });\n      }\n\n      if (emptyRef) {\n        emptyRef.unref();\n      }\n    });\n  },\n\n  /**\r\n   * Move the nodes at a location to a new location.\r\n   */\n  moveNodes: function moveNodes(editor, options) {\n    Editor.withoutNormalizing(editor, function () {\n      var to = options.to,\n          _options$at9 = options.at,\n          at = _options$at9 === void 0 ? editor.selection : _options$at9,\n          _options$mode8 = options.mode,\n          mode = _options$mode8 === void 0 ? 'lowest' : _options$mode8,\n          _options$voids10 = options.voids,\n          voids = _options$voids10 === void 0 ? false : _options$voids10;\n      var match = options.match;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : function (n) {\n          return Editor.isBlock(editor, n);\n        };\n      }\n\n      var toRef = Editor.pathRef(editor, to);\n      var targets = Editor.nodes(editor, {\n        at: at,\n        match: match,\n        mode: mode,\n        voids: voids\n      });\n      var pathRefs = Array.from(targets, function (_ref3) {\n        var _ref11 = _slicedToArray(_ref3, 2),\n            p = _ref11[1];\n\n        return Editor.pathRef(editor, p);\n      });\n\n      for (var _i2 = 0, _pathRefs2 = pathRefs; _i2 < _pathRefs2.length; _i2++) {\n        var pathRef = _pathRefs2[_i2];\n        var path = pathRef.unref();\n        var newPath = toRef.current;\n\n        if (path.length !== 0) {\n          editor.apply({\n            type: 'move_node',\n            path: path,\n            newPath: newPath\n          });\n        }\n      }\n\n      toRef.unref();\n    });\n  },\n\n  /**\r\n   * Remove the nodes at a specific location in the document.\r\n   */\n  removeNodes: function removeNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$hanging3 = options.hanging,\n          hanging = _options$hanging3 === void 0 ? false : _options$hanging3,\n          _options$voids11 = options.voids,\n          voids = _options$voids11 === void 0 ? false : _options$voids11,\n          _options$mode9 = options.mode,\n          mode = _options$mode9 === void 0 ? 'lowest' : _options$mode9;\n      var _options$at10 = options.at,\n          at = _options$at10 === void 0 ? editor.selection : _options$at10,\n          match = options.match;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : function (n) {\n          return Editor.isBlock(editor, n);\n        };\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at);\n      }\n\n      var depths = Editor.nodes(editor, {\n        at: at,\n        match: match,\n        mode: mode,\n        voids: voids\n      });\n      var pathRefs = Array.from(depths, function (_ref4) {\n        var _ref12 = _slicedToArray(_ref4, 2),\n            p = _ref12[1];\n\n        return Editor.pathRef(editor, p);\n      });\n\n      for (var _i3 = 0, _pathRefs3 = pathRefs; _i3 < _pathRefs3.length; _i3++) {\n        var pathRef = _pathRefs3[_i3];\n        var path = pathRef.unref();\n\n        if (path) {\n          var _Editor$node = Editor.node(editor, path),\n              _Editor$node2 = _slicedToArray(_Editor$node, 1),\n              node = _Editor$node2[0];\n\n          editor.apply({\n            type: 'remove_node',\n            path: path,\n            node: node\n          });\n        }\n      }\n    });\n  },\n\n  /**\r\n   * Set new properties on the nodes at a location.\r\n   */\n  setNodes: function setNodes(editor, props) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var match = options.match,\n          _options$at11 = options.at,\n          at = _options$at11 === void 0 ? editor.selection : _options$at11;\n      var _options$hanging4 = options.hanging,\n          hanging = _options$hanging4 === void 0 ? false : _options$hanging4,\n          _options$mode10 = options.mode,\n          mode = _options$mode10 === void 0 ? 'lowest' : _options$mode10,\n          _options$split = options.split,\n          split = _options$split === void 0 ? false : _options$split,\n          _options$voids12 = options.voids,\n          voids = _options$voids12 === void 0 ? false : _options$voids12;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : function (n) {\n          return Editor.isBlock(editor, n);\n        };\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at);\n      }\n\n      if (split && Range.isRange(at)) {\n        var rangeRef = Editor.rangeRef(editor, at, {\n          affinity: 'inward'\n        });\n\n        var _Range$edges31 = Range.edges(at),\n            _Range$edges32 = _slicedToArray(_Range$edges31, 2),\n            start = _Range$edges32[0],\n            end = _Range$edges32[1];\n\n        var splitMode = mode === 'lowest' ? 'lowest' : 'highest';\n        Transforms.splitNodes(editor, {\n          at: end,\n          match: match,\n          mode: splitMode,\n          voids: voids\n        });\n        Transforms.splitNodes(editor, {\n          at: start,\n          match: match,\n          mode: splitMode,\n          voids: voids\n        });\n        at = rangeRef.unref();\n\n        if (options.at == null) {\n          Transforms.select(editor, at);\n        }\n      }\n\n      var _iterator26 = _createForOfIteratorHelper(Editor.nodes(editor, {\n        at: at,\n        match: match,\n        mode: mode,\n        voids: voids\n      })),\n          _step26;\n\n      try {\n        for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n          var _step26$value = _slicedToArray(_step26.value, 2),\n              node = _step26$value[0],\n              path = _step26$value[1];\n\n          var properties = {};\n          var newProperties = {}; // You can't set properties on the editor node.\n\n          if (path.length === 0) {\n            continue;\n          }\n\n          for (var k in props) {\n            if (k === 'children' || k === 'text') {\n              continue;\n            }\n\n            if (props[k] !== node[k]) {\n              properties[k] = node[k];\n              newProperties[k] = props[k];\n            }\n          }\n\n          if (Object.keys(newProperties).length !== 0) {\n            editor.apply({\n              type: 'set_node',\n              path: path,\n              properties: properties,\n              newProperties: newProperties\n            });\n          }\n        }\n      } catch (err) {\n        _iterator26.e(err);\n      } finally {\n        _iterator26.f();\n      }\n    });\n  },\n\n  /**\r\n   * Split the nodes at a specific location.\r\n   */\n  splitNodes: function splitNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$mode11 = options.mode,\n          mode = _options$mode11 === void 0 ? 'lowest' : _options$mode11,\n          _options$voids13 = options.voids,\n          voids = _options$voids13 === void 0 ? false : _options$voids13;\n      var match = options.match,\n          _options$at12 = options.at,\n          at = _options$at12 === void 0 ? editor.selection : _options$at12,\n          _options$height = options.height,\n          height = _options$height === void 0 ? 0 : _options$height,\n          _options$always = options.always,\n          always = _options$always === void 0 ? false : _options$always;\n\n      if (match == null) {\n        match = function match(n) {\n          return Editor.isBlock(editor, n);\n        };\n      }\n\n      if (Range.isRange(at)) {\n        at = deleteRange(editor, at);\n      } // If the target is a path, the default height-skipping and position\n      // counters need to account for us potentially splitting at a non-leaf.\n\n\n      if (Path.isPath(at)) {\n        var path = at;\n        var point = Editor.point(editor, path);\n\n        var _Editor$parent7 = Editor.parent(editor, path),\n            _Editor$parent8 = _slicedToArray(_Editor$parent7, 1),\n            parent = _Editor$parent8[0];\n\n        match = function match(n) {\n          return n === parent;\n        };\n\n        height = point.path.length - path.length + 1;\n        at = point;\n        always = true;\n      }\n\n      if (!at) {\n        return;\n      }\n\n      var beforeRef = Editor.pointRef(editor, at, {\n        affinity: 'backward'\n      });\n\n      var _Editor$nodes11 = Editor.nodes(editor, {\n        at: at,\n        match: match,\n        mode: mode,\n        voids: voids\n      }),\n          _Editor$nodes12 = _slicedToArray(_Editor$nodes11, 1),\n          highest = _Editor$nodes12[0];\n\n      if (!highest) {\n        return;\n      }\n\n      var voidMatch = Editor.void(editor, {\n        at: at,\n        mode: 'highest'\n      });\n      var nudge = 0;\n\n      if (!voids && voidMatch) {\n        var _voidMatch = _slicedToArray(voidMatch, 2),\n            voidNode = _voidMatch[0],\n            voidPath = _voidMatch[1];\n\n        if (Element.isElement(voidNode) && editor.isInline(voidNode)) {\n          var after = Editor.after(editor, voidPath);\n\n          if (!after) {\n            var text = {\n              text: ''\n            };\n            var afterPath = Path.next(voidPath);\n            Transforms.insertNodes(editor, text, {\n              at: afterPath,\n              voids: voids\n            });\n            after = Editor.point(editor, afterPath);\n          }\n\n          at = after;\n          always = true;\n        }\n\n        var siblingHeight = at.path.length - voidPath.length;\n        height = siblingHeight + 1;\n        always = true;\n      }\n\n      var afterRef = Editor.pointRef(editor, at);\n      var depth = at.path.length - height;\n\n      var _highest = _slicedToArray(highest, 2),\n          highestPath = _highest[1];\n\n      var lowestPath = at.path.slice(0, depth);\n      var position = height === 0 ? at.offset : at.path[depth] + nudge;\n\n      var _iterator27 = _createForOfIteratorHelper(Editor.levels(editor, {\n        at: lowestPath,\n        reverse: true,\n        voids: voids\n      })),\n          _step27;\n\n      try {\n        for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n          var _step27$value = _slicedToArray(_step27.value, 2),\n              node = _step27$value[0],\n              _path2 = _step27$value[1];\n\n          var split = false;\n\n          if (_path2.length < highestPath.length || _path2.length === 0 || !voids && Editor.isVoid(editor, node)) {\n            break;\n          }\n\n          var _point = beforeRef.current;\n          var isEnd = Editor.isEnd(editor, _point, _path2);\n\n          if (always || !beforeRef || !Editor.isEdge(editor, _point, _path2)) {\n            split = true;\n\n            var properties = _objectWithoutProperties(node, [\"text\", \"children\"]);\n\n            editor.apply({\n              type: 'split_node',\n              path: _path2,\n              position: position,\n              properties: properties\n            });\n          }\n\n          position = _path2[_path2.length - 1] + (split || isEnd ? 1 : 0);\n        }\n      } catch (err) {\n        _iterator27.e(err);\n      } finally {\n        _iterator27.f();\n      }\n\n      if (options.at == null) {\n        var _point2 = afterRef.current || Editor.end(editor, []);\n\n        Transforms.select(editor, _point2);\n      }\n\n      beforeRef.unref();\n      afterRef.unref();\n    });\n  },\n\n  /**\r\n   * Unset properties on the nodes at a location.\r\n   */\n  unsetNodes: function unsetNodes(editor, props) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (!Array.isArray(props)) {\n      props = [props];\n    }\n\n    var obj = {};\n\n    var _iterator28 = _createForOfIteratorHelper(props),\n        _step28;\n\n    try {\n      for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {\n        var key = _step28.value;\n        obj[key] = null;\n      }\n    } catch (err) {\n      _iterator28.e(err);\n    } finally {\n      _iterator28.f();\n    }\n\n    Transforms.setNodes(editor, obj, options);\n  },\n\n  /**\r\n   * Unwrap the nodes at a location from a parent node, splitting the parent if\r\n   * necessary to ensure that only the content in the range is unwrapped.\r\n   */\n  unwrapNodes: function unwrapNodes(editor, options) {\n    Editor.withoutNormalizing(editor, function () {\n      var _options$mode12 = options.mode,\n          mode = _options$mode12 === void 0 ? 'lowest' : _options$mode12,\n          _options$split2 = options.split,\n          split = _options$split2 === void 0 ? false : _options$split2,\n          _options$voids14 = options.voids,\n          voids = _options$voids14 === void 0 ? false : _options$voids14;\n      var _options$at13 = options.at,\n          at = _options$at13 === void 0 ? editor.selection : _options$at13,\n          match = options.match;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : function (n) {\n          return Editor.isBlock(editor, n);\n        };\n      }\n\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at);\n      }\n\n      var rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null;\n      var matches = Editor.nodes(editor, {\n        at: at,\n        match: match,\n        mode: mode,\n        voids: voids\n      });\n      var pathRefs = Array.from(matches, function (_ref5) {\n        var _ref13 = _slicedToArray(_ref5, 2),\n            p = _ref13[1];\n\n        return Editor.pathRef(editor, p);\n      });\n\n      var _loop = function _loop(pathRef) {\n        var path = pathRef.unref();\n\n        var _Editor$node3 = Editor.node(editor, path),\n            _Editor$node4 = _slicedToArray(_Editor$node3, 1),\n            node = _Editor$node4[0];\n\n        var range = Editor.range(editor, path);\n\n        if (split && rangeRef) {\n          range = Range.intersection(rangeRef.current, range);\n        }\n\n        Transforms.liftNodes(editor, {\n          at: range,\n          match: function match(n) {\n            return node.children.includes(n);\n          },\n          voids: voids\n        });\n      };\n\n      for (var _i4 = 0, _pathRefs4 = pathRefs; _i4 < _pathRefs4.length; _i4++) {\n        var pathRef = _pathRefs4[_i4];\n\n        _loop(pathRef);\n      }\n\n      if (rangeRef) {\n        rangeRef.unref();\n      }\n    });\n  },\n\n  /**\r\n   * Wrap the nodes at a location in a new container node, splitting the edges\r\n   * of the range first to ensure that only the content in the range is wrapped.\r\n   */\n  wrapNodes: function wrapNodes(editor, element) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$mode13 = options.mode,\n          mode = _options$mode13 === void 0 ? 'lowest' : _options$mode13,\n          _options$split3 = options.split,\n          split = _options$split3 === void 0 ? false : _options$split3,\n          _options$voids15 = options.voids,\n          voids = _options$voids15 === void 0 ? false : _options$voids15;\n      var match = options.match,\n          _options$at14 = options.at,\n          at = _options$at14 === void 0 ? editor.selection : _options$at14;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          match = matchPath(editor, at);\n        } else if (editor.isInline(element)) {\n          match = function match(n) {\n            return Editor.isInline(editor, n) || Text.isText(n);\n          };\n        } else {\n          match = function match(n) {\n            return Editor.isBlock(editor, n);\n          };\n        }\n      }\n\n      if (split && Range.isRange(at)) {\n        var _Range$edges33 = Range.edges(at),\n            _Range$edges34 = _slicedToArray(_Range$edges33, 2),\n            start = _Range$edges34[0],\n            end = _Range$edges34[1];\n\n        var rangeRef = Editor.rangeRef(editor, at, {\n          affinity: 'inward'\n        });\n        Transforms.splitNodes(editor, {\n          at: end,\n          match: match,\n          voids: voids\n        });\n        Transforms.splitNodes(editor, {\n          at: start,\n          match: match,\n          voids: voids\n        });\n        at = rangeRef.unref();\n\n        if (options.at == null) {\n          Transforms.select(editor, at);\n        }\n      }\n\n      var roots = Array.from(Editor.nodes(editor, {\n        at: at,\n        match: editor.isInline(element) ? function (n) {\n          return Editor.isBlock(editor, n);\n        } : function (n) {\n          return Editor.isEditor(n);\n        },\n        mode: 'lowest',\n        voids: voids\n      }));\n\n      for (var _i5 = 0, _roots = roots; _i5 < _roots.length; _i5++) {\n        var _roots$_i = _slicedToArray(_roots[_i5], 2),\n            rootPath = _roots$_i[1];\n\n        var a = Range.isRange(at) ? Range.intersection(at, Editor.range(editor, rootPath)) : at;\n\n        if (!a) {\n          continue;\n        }\n\n        var matches = Array.from(Editor.nodes(editor, {\n          at: a,\n          match: match,\n          mode: mode,\n          voids: voids\n        }));\n\n        if (matches.length > 0) {\n          (function () {\n            var _matches = _slicedToArray(matches, 1),\n                first = _matches[0];\n\n            var last = matches[matches.length - 1];\n\n            var _first = _slicedToArray(first, 2),\n                firstPath = _first[1];\n\n            var _last = _slicedToArray(last, 2),\n                lastPath = _last[1];\n\n            var commonPath = Path.equals(firstPath, lastPath) ? Path.parent(firstPath) : Path.common(firstPath, lastPath);\n            var range = Editor.range(editor, firstPath, lastPath);\n            var commonNodeEntry = Editor.node(editor, commonPath);\n\n            var _commonNodeEntry = _slicedToArray(commonNodeEntry, 1),\n                commonNode = _commonNodeEntry[0];\n\n            var depth = commonPath.length + 1;\n            var wrapperPath = Path.next(lastPath.slice(0, depth));\n\n            var wrapper = _objectSpread$6({}, element, {\n              children: []\n            });\n\n            Transforms.insertNodes(editor, wrapper, {\n              at: wrapperPath,\n              voids: voids\n            });\n            Transforms.moveNodes(editor, {\n              at: range,\n              match: function match(n) {\n                return commonNode.children.includes(n);\n              },\n              to: wrapperPath.concat(0),\n              voids: voids\n            });\n          })();\n        }\n      }\n    });\n  }\n};\n/**\r\n * Convert a range into a point by deleting it's content.\r\n */\n\nvar deleteRange = function deleteRange(editor, range) {\n  if (Range.isCollapsed(range)) {\n    return range.anchor;\n  } else {\n    var _Range$edges35 = Range.edges(range),\n        _Range$edges36 = _slicedToArray(_Range$edges35, 2),\n        end = _Range$edges36[1];\n\n    var pointRef = Editor.pointRef(editor, end);\n    Transforms.delete(editor, {\n      at: range\n    });\n    return pointRef.unref();\n  }\n};\n\nvar matchPath = function matchPath(editor, path) {\n  var _Editor$node5 = Editor.node(editor, path),\n      _Editor$node6 = _slicedToArray(_Editor$node5, 1),\n      node = _Editor$node6[0];\n\n  return function (n) {\n    return n === node;\n  };\n};\n\nfunction ownKeys$7(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$7(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$7(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$7(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar SelectionTransforms = {\n  /**\r\n   * Collapse the selection.\r\n   */\n  collapse: function collapse(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$edge2 = options.edge,\n        edge = _options$edge2 === void 0 ? 'anchor' : _options$edge2;\n    var selection = editor.selection;\n\n    if (!selection) {\n      return;\n    } else if (edge === 'anchor') {\n      Transforms.select(editor, selection.anchor);\n    } else if (edge === 'focus') {\n      Transforms.select(editor, selection.focus);\n    } else if (edge === 'start') {\n      var _Range$edges37 = Range.edges(selection),\n          _Range$edges38 = _slicedToArray(_Range$edges37, 1),\n          start = _Range$edges38[0];\n\n      Transforms.select(editor, start);\n    } else if (edge === 'end') {\n      var _Range$edges39 = Range.edges(selection),\n          _Range$edges40 = _slicedToArray(_Range$edges39, 2),\n          end = _Range$edges40[1];\n\n      Transforms.select(editor, end);\n    }\n  },\n\n  /**\r\n   * Unset the selection.\r\n   */\n  deselect: function deselect(editor) {\n    var selection = editor.selection;\n\n    if (selection) {\n      editor.apply({\n        type: 'set_selection',\n        properties: selection,\n        newProperties: null\n      });\n    }\n  },\n\n  /**\r\n   * Move the selection's point forward or backward.\r\n   */\n  move: function move(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var selection = editor.selection;\n    var _options$distance3 = options.distance,\n        distance = _options$distance3 === void 0 ? 1 : _options$distance3,\n        _options$unit4 = options.unit,\n        unit = _options$unit4 === void 0 ? 'character' : _options$unit4,\n        _options$reverse9 = options.reverse,\n        reverse = _options$reverse9 === void 0 ? false : _options$reverse9;\n    var _options$edge3 = options.edge,\n        edge = _options$edge3 === void 0 ? null : _options$edge3;\n\n    if (!selection) {\n      return;\n    }\n\n    if (edge === 'start') {\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor';\n    }\n\n    if (edge === 'end') {\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus';\n    }\n\n    var anchor = selection.anchor,\n        focus = selection.focus;\n    var opts = {\n      distance: distance,\n      unit: unit\n    };\n    var props = {};\n\n    if (edge == null || edge === 'anchor') {\n      var point = reverse ? Editor.before(editor, anchor, opts) : Editor.after(editor, anchor, opts);\n\n      if (point) {\n        props.anchor = point;\n      }\n    }\n\n    if (edge == null || edge === 'focus') {\n      var _point = reverse ? Editor.before(editor, focus, opts) : Editor.after(editor, focus, opts);\n\n      if (_point) {\n        props.focus = _point;\n      }\n    }\n\n    Transforms.setSelection(editor, props);\n  },\n\n  /**\r\n   * Set the selection to a new value.\r\n   */\n  select: function select(editor, target) {\n    var selection = editor.selection;\n    target = Editor.range(editor, target);\n\n    if (selection) {\n      Transforms.setSelection(editor, target);\n      return;\n    }\n\n    if (!Range.isRange(target)) {\n      throw new Error(\"When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: \".concat(JSON.stringify(target)));\n    }\n\n    editor.apply({\n      type: 'set_selection',\n      properties: selection,\n      newProperties: target\n    });\n  },\n\n  /**\r\n   * Set new properties on one of the selection's points.\r\n   */\n  setPoint: function setPoint(editor, props, options) {\n    var selection = editor.selection;\n    var _options$edge4 = options.edge,\n        edge = _options$edge4 === void 0 ? 'both' : _options$edge4;\n\n    if (!selection) {\n      return;\n    }\n\n    if (edge === 'start') {\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor';\n    }\n\n    if (edge === 'end') {\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus';\n    }\n\n    var anchor = selection.anchor,\n        focus = selection.focus;\n    var point = edge === 'anchor' ? anchor : focus;\n    Transforms.setSelection(editor, _defineProperty2({}, edge === 'anchor' ? 'anchor' : 'focus', _objectSpread$7({}, point, {}, props)));\n  },\n\n  /**\r\n   * Set new properties on the selection.\r\n   */\n  setSelection: function setSelection(editor, props) {\n    var selection = editor.selection;\n    var oldProps = {};\n    var newProps = {};\n\n    if (!selection) {\n      return;\n    }\n\n    for (var k in props) {\n      if (k === 'anchor' && props.anchor != null && !Point.equals(props.anchor, selection.anchor) || k === 'focus' && props.focus != null && !Point.equals(props.focus, selection.focus) || k !== 'anchor' && k !== 'focus' && props[k] !== selection[k]) {\n        oldProps[k] = selection[k];\n        newProps[k] = props[k];\n      }\n    }\n\n    if (Object.keys(oldProps).length > 0) {\n      editor.apply({\n        type: 'set_selection',\n        properties: oldProps,\n        newProperties: newProps\n      });\n    }\n  }\n};\nvar TextTransforms = {\n  /**\r\n   * Delete content in the editor.\r\n   */\n  delete: function _delete(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$reverse10 = options.reverse,\n          reverse = _options$reverse10 === void 0 ? false : _options$reverse10,\n          _options$unit5 = options.unit,\n          unit = _options$unit5 === void 0 ? 'character' : _options$unit5,\n          _options$distance4 = options.distance,\n          distance = _options$distance4 === void 0 ? 1 : _options$distance4,\n          _options$voids16 = options.voids,\n          voids = _options$voids16 === void 0 ? false : _options$voids16;\n      var _options$at15 = options.at,\n          at = _options$at15 === void 0 ? editor.selection : _options$at15,\n          _options$hanging5 = options.hanging,\n          hanging = _options$hanging5 === void 0 ? false : _options$hanging5;\n\n      if (!at) {\n        return;\n      }\n\n      if (Range.isRange(at) && Range.isCollapsed(at)) {\n        at = at.anchor;\n      }\n\n      if (Point.isPoint(at)) {\n        var furthestVoid = Editor.void(editor, {\n          at: at,\n          mode: 'highest'\n        });\n\n        if (!voids && furthestVoid) {\n          var _furthestVoid = _slicedToArray(furthestVoid, 2),\n              voidPath = _furthestVoid[1];\n\n          at = voidPath;\n        } else {\n          var opts = {\n            unit: unit,\n            distance: distance\n          };\n          var target = reverse ? Editor.before(editor, at, opts) || Editor.start(editor, []) : Editor.after(editor, at, opts) || Editor.end(editor, []);\n          at = {\n            anchor: at,\n            focus: target\n          };\n          hanging = true;\n        }\n      }\n\n      if (Path.isPath(at)) {\n        Transforms.removeNodes(editor, {\n          at: at,\n          voids: voids\n        });\n        return;\n      }\n\n      if (Range.isCollapsed(at)) {\n        return;\n      }\n\n      if (!hanging) {\n        at = Editor.unhangRange(editor, at, {\n          voids: voids\n        });\n      }\n\n      var _Range$edges41 = Range.edges(at),\n          _Range$edges42 = _slicedToArray(_Range$edges41, 2),\n          start = _Range$edges42[0],\n          end = _Range$edges42[1];\n\n      var startBlock = Editor.above(editor, {\n        match: function match(n) {\n          return Editor.isBlock(editor, n);\n        },\n        at: start,\n        voids: voids\n      });\n      var endBlock = Editor.above(editor, {\n        match: function match(n) {\n          return Editor.isBlock(editor, n);\n        },\n        at: end,\n        voids: voids\n      });\n      var isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);\n      var isSingleText = Path.equals(start.path, end.path);\n      var startVoid = voids ? null : Editor.void(editor, {\n        at: start,\n        mode: 'highest'\n      });\n      var endVoid = voids ? null : Editor.void(editor, {\n        at: end,\n        mode: 'highest'\n      }); // If the start or end points are inside an inline void, nudge them out.\n\n      if (startVoid) {\n        var before = Editor.before(editor, start);\n\n        if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {\n          start = before;\n        }\n      }\n\n      if (endVoid) {\n        var after = Editor.after(editor, end);\n\n        if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n          end = after;\n        }\n      } // Get the highest nodes that are completely inside the range, as well as\n      // the start and end nodes.\n\n\n      var matches = [];\n      var lastPath;\n\n      var _iterator29 = _createForOfIteratorHelper(Editor.nodes(editor, {\n        at: at,\n        voids: voids\n      })),\n          _step29;\n\n      try {\n        for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {\n          var entry = _step29.value;\n\n          var _entry2 = _slicedToArray(entry, 2),\n              node = _entry2[0],\n              path = _entry2[1];\n\n          if (lastPath && Path.compare(path, lastPath) === 0) {\n            continue;\n          }\n\n          if (!voids && Editor.isVoid(editor, node) || !Path.isCommon(path, start.path) && !Path.isCommon(path, end.path)) {\n            matches.push(entry);\n            lastPath = path;\n          }\n        }\n      } catch (err) {\n        _iterator29.e(err);\n      } finally {\n        _iterator29.f();\n      }\n\n      var pathRefs = Array.from(matches, function (_ref) {\n        var _ref14 = _slicedToArray(_ref, 2),\n            p = _ref14[1];\n\n        return Editor.pathRef(editor, p);\n      });\n      var startRef = Editor.pointRef(editor, start);\n      var endRef = Editor.pointRef(editor, end);\n\n      if (!isSingleText && !startVoid) {\n        var _point = startRef.current;\n\n        var _Editor$leaf3 = Editor.leaf(editor, _point),\n            _Editor$leaf4 = _slicedToArray(_Editor$leaf3, 1),\n            _node = _Editor$leaf4[0];\n\n        var _path = _point.path;\n        var _start = start,\n            offset = _start.offset;\n\n        var text = _node.text.slice(offset);\n\n        editor.apply({\n          type: 'remove_text',\n          path: _path,\n          offset: offset,\n          text: text\n        });\n      }\n\n      for (var _i6 = 0, _pathRefs5 = pathRefs; _i6 < _pathRefs5.length; _i6++) {\n        var pathRef = _pathRefs5[_i6];\n\n        var _path2 = pathRef.unref();\n\n        Transforms.removeNodes(editor, {\n          at: _path2,\n          voids: voids\n        });\n      }\n\n      if (!endVoid) {\n        var _point2 = endRef.current;\n\n        var _Editor$leaf5 = Editor.leaf(editor, _point2),\n            _Editor$leaf6 = _slicedToArray(_Editor$leaf5, 1),\n            _node2 = _Editor$leaf6[0];\n\n        var _path3 = _point2.path;\n\n        var _offset = isSingleText ? start.offset : 0;\n\n        var _text = _node2.text.slice(_offset, end.offset);\n\n        editor.apply({\n          type: 'remove_text',\n          path: _path3,\n          offset: _offset,\n          text: _text\n        });\n      }\n\n      if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {\n        Transforms.mergeNodes(editor, {\n          at: endRef.current,\n          hanging: true,\n          voids: voids\n        });\n      }\n\n      var point = endRef.unref() || startRef.unref();\n\n      if (options.at == null && point) {\n        Transforms.select(editor, point);\n      }\n    });\n  },\n\n  /**\r\n   * Insert a fragment at a specific location in the editor.\r\n   */\n  insertFragment: function insertFragment(editor, fragment) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$hanging6 = options.hanging,\n          hanging = _options$hanging6 === void 0 ? false : _options$hanging6,\n          _options$voids17 = options.voids,\n          voids = _options$voids17 === void 0 ? false : _options$voids17;\n      var _options$at16 = options.at,\n          at = _options$at16 === void 0 ? editor.selection : _options$at16;\n\n      if (!fragment.length) {\n        return;\n      }\n\n      if (!at) {\n        return;\n      } else if (Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at);\n        }\n\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var _Range$edges43 = Range.edges(at),\n              _Range$edges44 = _slicedToArray(_Range$edges43, 2),\n              end = _Range$edges44[1];\n\n          if (!voids && Editor.void(editor, {\n            at: end\n          })) {\n            return;\n          }\n\n          var pointRef = Editor.pointRef(editor, end);\n          Transforms.delete(editor, {\n            at: at\n          });\n          at = pointRef.unref();\n        }\n      } else if (Path.isPath(at)) {\n        at = Editor.start(editor, at);\n      }\n\n      if (!voids && Editor.void(editor, {\n        at: at\n      })) {\n        return;\n      } // If the insert point is at the edge of an inline node, move it outside\n      // instead since it will need to be split otherwise.\n\n\n      var inlineElementMatch = Editor.above(editor, {\n        at: at,\n        match: function match(n) {\n          return Editor.isInline(editor, n);\n        },\n        mode: 'highest',\n        voids: voids\n      });\n\n      if (inlineElementMatch) {\n        var _inlineElementMatch = _slicedToArray(inlineElementMatch, 2),\n            _inlinePath = _inlineElementMatch[1];\n\n        if (Editor.isEnd(editor, at, _inlinePath)) {\n          var after = Editor.after(editor, _inlinePath);\n          at = after;\n        } else if (Editor.isStart(editor, at, _inlinePath)) {\n          var before = Editor.before(editor, _inlinePath);\n          at = before;\n        }\n      }\n\n      var blockMatch = Editor.above(editor, {\n        match: function match(n) {\n          return Editor.isBlock(editor, n);\n        },\n        at: at,\n        voids: voids\n      });\n\n      var _blockMatch = _slicedToArray(blockMatch, 2),\n          blockPath = _blockMatch[1];\n\n      var isBlockStart = Editor.isStart(editor, at, blockPath);\n      var isBlockEnd = Editor.isEnd(editor, at, blockPath);\n      var mergeStart = !isBlockStart || isBlockStart && isBlockEnd;\n      var mergeEnd = !isBlockEnd;\n\n      var _Node$first5 = Node.first({\n        children: fragment\n      }, []),\n          _Node$first6 = _slicedToArray(_Node$first5, 2),\n          firstPath = _Node$first6[1];\n\n      var _Node$last5 = Node.last({\n        children: fragment\n      }, []),\n          _Node$last6 = _slicedToArray(_Node$last5, 2),\n          lastPath = _Node$last6[1];\n\n      var matches = [];\n\n      var matcher = function matcher(_ref2) {\n        var _ref15 = _slicedToArray(_ref2, 2),\n            n = _ref15[0],\n            p = _ref15[1];\n\n        if (mergeStart && Path.isAncestor(p, firstPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n          return false;\n        }\n\n        if (mergeEnd && Path.isAncestor(p, lastPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n          return false;\n        }\n\n        return true;\n      };\n\n      var _iterator30 = _createForOfIteratorHelper(Node.nodes({\n        children: fragment\n      }, {\n        pass: matcher\n      })),\n          _step30;\n\n      try {\n        for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {\n          var entry = _step30.value;\n\n          if (entry[1].length > 0 && matcher(entry)) {\n            matches.push(entry);\n          }\n        }\n      } catch (err) {\n        _iterator30.e(err);\n      } finally {\n        _iterator30.f();\n      }\n\n      var starts = [];\n      var middles = [];\n      var ends = [];\n      var starting = true;\n      var hasBlocks = false;\n\n      for (var _i7 = 0, _matches2 = matches; _i7 < _matches2.length; _i7++) {\n        var _matches2$_i = _slicedToArray(_matches2[_i7], 1),\n            node = _matches2$_i[0];\n\n        if (Element.isElement(node) && !editor.isInline(node)) {\n          starting = false;\n          hasBlocks = true;\n          middles.push(node);\n        } else if (starting) {\n          starts.push(node);\n        } else {\n          ends.push(node);\n        }\n      }\n\n      var _Editor$nodes13 = Editor.nodes(editor, {\n        at: at,\n        match: function match(n) {\n          return Text.isText(n) || Editor.isInline(editor, n);\n        },\n        mode: 'highest',\n        voids: voids\n      }),\n          _Editor$nodes14 = _slicedToArray(_Editor$nodes13, 1),\n          inlineMatch = _Editor$nodes14[0];\n\n      var _inlineMatch = _slicedToArray(inlineMatch, 2),\n          inlinePath = _inlineMatch[1];\n\n      var isInlineStart = Editor.isStart(editor, at, inlinePath);\n      var isInlineEnd = Editor.isEnd(editor, at, inlinePath);\n      var middleRef = Editor.pathRef(editor, isBlockEnd ? Path.next(blockPath) : blockPath);\n      var endRef = Editor.pathRef(editor, isInlineEnd ? Path.next(inlinePath) : inlinePath);\n      Transforms.splitNodes(editor, {\n        at: at,\n        match: function match(n) {\n          return hasBlocks ? Editor.isBlock(editor, n) : Text.isText(n) || Editor.isInline(editor, n);\n        },\n        mode: hasBlocks ? 'lowest' : 'highest',\n        voids: voids\n      });\n      var startRef = Editor.pathRef(editor, !isInlineStart || isInlineStart && isInlineEnd ? Path.next(inlinePath) : inlinePath);\n      Transforms.insertNodes(editor, starts, {\n        at: startRef.current,\n        match: function match(n) {\n          return Text.isText(n) || Editor.isInline(editor, n);\n        },\n        mode: 'highest',\n        voids: voids\n      });\n      Transforms.insertNodes(editor, middles, {\n        at: middleRef.current,\n        match: function match(n) {\n          return Editor.isBlock(editor, n);\n        },\n        mode: 'lowest',\n        voids: voids\n      });\n      Transforms.insertNodes(editor, ends, {\n        at: endRef.current,\n        match: function match(n) {\n          return Text.isText(n) || Editor.isInline(editor, n);\n        },\n        mode: 'highest',\n        voids: voids\n      });\n\n      if (!options.at) {\n        var path;\n\n        if (ends.length > 0) {\n          path = Path.previous(endRef.current);\n        } else if (middles.length > 0) {\n          path = Path.previous(middleRef.current);\n        } else {\n          path = Path.previous(startRef.current);\n        }\n\n        var _end = Editor.end(editor, path);\n\n        Transforms.select(editor, _end);\n      }\n\n      startRef.unref();\n      middleRef.unref();\n      endRef.unref();\n    });\n  },\n\n  /**\r\n   * Insert a string of text in the Editor.\r\n   */\n  insertText: function insertText(editor, text) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$voids18 = options.voids,\n          voids = _options$voids18 === void 0 ? false : _options$voids18;\n      var _options$at17 = options.at,\n          at = _options$at17 === void 0 ? editor.selection : _options$at17;\n\n      if (!at) {\n        return;\n      }\n\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at);\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var end = Range.end(at);\n\n          if (!voids && Editor.void(editor, {\n            at: end\n          })) {\n            return;\n          }\n\n          var pointRef = Editor.pointRef(editor, end);\n          Transforms.delete(editor, {\n            at: at,\n            voids: voids\n          });\n          at = pointRef.unref();\n          Transforms.setSelection(editor, {\n            anchor: at,\n            focus: at\n          });\n        }\n      }\n\n      if (!voids && Editor.void(editor, {\n        at: at\n      })) {\n        return;\n      }\n\n      var _at = at,\n          path = _at.path,\n          offset = _at.offset;\n      editor.apply({\n        type: 'insert_text',\n        path: path,\n        offset: offset,\n        text: text\n      });\n    });\n  }\n};\n\nfunction ownKeys$8(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$8(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$8(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$8(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar Transforms = _objectSpread$8({}, GeneralTransforms, {}, NodeTransforms, {}, SelectionTransforms, {}, TextTransforms);\n\nfunction ownKeys$9(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$9(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$9(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$9(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n/**\r\n * Create a new Slate `Editor` object.\r\n */\n\n\nvar createEditor = function createEditor() {\n  var editor = {\n    children: [],\n    operations: [],\n    selection: null,\n    marks: null,\n    isInline: function isInline() {\n      return false;\n    },\n    isVoid: function isVoid() {\n      return false;\n    },\n    onChange: function onChange() {},\n    apply: function apply(op) {\n      var _iterator31 = _createForOfIteratorHelper(Editor.pathRefs(editor)),\n          _step31;\n\n      try {\n        for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {\n          var ref = _step31.value;\n          PathRef.transform(ref, op);\n        }\n      } catch (err) {\n        _iterator31.e(err);\n      } finally {\n        _iterator31.f();\n      }\n\n      var _iterator32 = _createForOfIteratorHelper(Editor.pointRefs(editor)),\n          _step32;\n\n      try {\n        for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {\n          var _ref = _step32.value;\n          PointRef.transform(_ref, op);\n        }\n      } catch (err) {\n        _iterator32.e(err);\n      } finally {\n        _iterator32.f();\n      }\n\n      var _iterator33 = _createForOfIteratorHelper(Editor.rangeRefs(editor)),\n          _step33;\n\n      try {\n        for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {\n          var _ref2 = _step33.value;\n          RangeRef.transform(_ref2, op);\n        }\n      } catch (err) {\n        _iterator33.e(err);\n      } finally {\n        _iterator33.f();\n      }\n\n      var set = new Set();\n      var dirtyPaths = [];\n\n      var add = function add(path) {\n        if (path) {\n          var key = path.join(',');\n\n          if (!set.has(key)) {\n            set.add(key);\n            dirtyPaths.push(path);\n          }\n        }\n      };\n\n      var oldDirtyPaths = DIRTY_PATHS.get(editor) || [];\n      var newDirtyPaths = getDirtyPaths(op);\n\n      var _iterator34 = _createForOfIteratorHelper(oldDirtyPaths),\n          _step34;\n\n      try {\n        for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {\n          var path = _step34.value;\n          var newPath = Path.transform(path, op);\n          add(newPath);\n        }\n      } catch (err) {\n        _iterator34.e(err);\n      } finally {\n        _iterator34.f();\n      }\n\n      var _iterator35 = _createForOfIteratorHelper(newDirtyPaths),\n          _step35;\n\n      try {\n        for (_iterator35.s(); !(_step35 = _iterator35.n()).done;) {\n          var _path = _step35.value;\n          add(_path);\n        }\n      } catch (err) {\n        _iterator35.e(err);\n      } finally {\n        _iterator35.f();\n      }\n\n      DIRTY_PATHS.set(editor, dirtyPaths);\n      Transforms.transform(editor, op);\n      editor.operations.push(op);\n      Editor.normalize(editor); // Clear any formats applied to the cursor if the selection changes.\n\n      if (op.type === 'set_selection') {\n        editor.marks = null;\n      }\n\n      if (!FLUSHING.get(editor)) {\n        FLUSHING.set(editor, true);\n        Promise.resolve().then(function () {\n          FLUSHING.set(editor, false);\n          editor.onChange();\n          editor.operations = [];\n        });\n      }\n    },\n    addMark: function addMark(key, value) {\n      var selection = editor.selection;\n\n      if (selection) {\n        if (Range.isExpanded(selection)) {\n          Transforms.setNodes(editor, _defineProperty2({}, key, value), {\n            match: Text.isText,\n            split: true\n          });\n        } else {\n          var marks = _objectSpread$9({}, Editor.marks(editor) || {}, _defineProperty2({}, key, value));\n\n          editor.marks = marks;\n          editor.onChange();\n        }\n      }\n    },\n    deleteBackward: function deleteBackward(unit) {\n      var selection = editor.selection;\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms.delete(editor, {\n          unit: unit,\n          reverse: true\n        });\n      }\n    },\n    deleteForward: function deleteForward(unit) {\n      var selection = editor.selection;\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms.delete(editor, {\n          unit: unit\n        });\n      }\n    },\n    deleteFragment: function deleteFragment() {\n      var selection = editor.selection;\n\n      if (selection && Range.isExpanded(selection)) {\n        Transforms.delete(editor);\n      }\n    },\n    getFragment: function getFragment() {\n      var selection = editor.selection;\n\n      if (selection) {\n        return Node.fragment(editor, selection);\n      }\n\n      return [];\n    },\n    insertBreak: function insertBreak() {\n      Transforms.splitNodes(editor, {\n        always: true\n      });\n    },\n    insertFragment: function insertFragment(fragment) {\n      Transforms.insertFragment(editor, fragment);\n    },\n    insertNode: function insertNode(node) {\n      Transforms.insertNodes(editor, node);\n    },\n    insertText: function insertText(text) {\n      var selection = editor.selection,\n          marks = editor.marks;\n\n      if (selection) {\n        // If the cursor is at the end of an inline, move it outside of\n        // the inline before inserting\n        if (Range.isCollapsed(selection)) {\n          var inline = Editor.above(editor, {\n            match: function match(n) {\n              return Editor.isInline(editor, n);\n            },\n            mode: 'highest'\n          });\n\n          if (inline) {\n            var _inline = _slicedToArray(inline, 2),\n                inlinePath = _inline[1];\n\n            if (Editor.isEnd(editor, selection.anchor, inlinePath)) {\n              var point = Editor.after(editor, inlinePath);\n              Transforms.setSelection(editor, {\n                anchor: point,\n                focus: point\n              });\n            }\n          }\n        }\n\n        if (marks) {\n          var node = _objectSpread$9({\n            text: text\n          }, marks);\n\n          Transforms.insertNodes(editor, node);\n        } else {\n          Transforms.insertText(editor, text);\n        }\n\n        editor.marks = null;\n      }\n    },\n    normalizeNode: function normalizeNode(entry) {\n      var _entry3 = _slicedToArray(entry, 2),\n          node = _entry3[0],\n          path = _entry3[1]; // There are no core normalizations for text nodes.\n\n\n      if (Text.isText(node)) {\n        return;\n      } // Ensure that block and inline nodes have at least one text child.\n\n\n      if (Element.isElement(node) && node.children.length === 0) {\n        var child = {\n          text: ''\n        };\n        Transforms.insertNodes(editor, child, {\n          at: path.concat(0),\n          voids: true\n        });\n        return;\n      } // Determine whether the node should have block or inline children.\n\n\n      var shouldHaveInlines = Editor.isEditor(node) ? false : Element.isElement(node) && (editor.isInline(node) || node.children.length === 0 || Text.isText(node.children[0]) || editor.isInline(node.children[0])); // Since we'll be applying operations while iterating, keep track of an\n      // index that accounts for any added/removed nodes.\n\n      var n = 0;\n\n      for (var i = 0; i < node.children.length; i++, n++) {\n        var _child = node.children[i];\n        var prev = node.children[i - 1];\n        var isLast = i === node.children.length - 1;\n        var isInlineOrText = Text.isText(_child) || Element.isElement(_child) && editor.isInline(_child); // Only allow block nodes in the top-level children and parent blocks\n        // that only contain block nodes. Similarly, only allow inline nodes in\n        // other inline nodes, or parent blocks that only contain inlines and\n        // text.\n\n        if (isInlineOrText !== shouldHaveInlines) {\n          Transforms.removeNodes(editor, {\n            at: path.concat(n),\n            voids: true\n          });\n          n--;\n        } else if (Element.isElement(_child)) {\n          // Ensure that inline nodes are surrounded by text nodes.\n          if (editor.isInline(_child)) {\n            if (prev == null || !Text.isText(prev)) {\n              var newChild = {\n                text: ''\n              };\n              Transforms.insertNodes(editor, newChild, {\n                at: path.concat(n),\n                voids: true\n              });\n              n++;\n            } else if (isLast) {\n              var _newChild = {\n                text: ''\n              };\n              Transforms.insertNodes(editor, _newChild, {\n                at: path.concat(n + 1),\n                voids: true\n              });\n              n++;\n            }\n          }\n        } else {\n          // Merge adjacent text nodes that are empty or match.\n          if (prev != null && Text.isText(prev)) {\n            if (Text.equals(_child, prev, {\n              loose: true\n            })) {\n              Transforms.mergeNodes(editor, {\n                at: path.concat(n),\n                voids: true\n              });\n              n--;\n            } else if (prev.text === '') {\n              Transforms.removeNodes(editor, {\n                at: path.concat(n - 1),\n                voids: true\n              });\n              n--;\n            } else if (isLast && _child.text === '') {\n              Transforms.removeNodes(editor, {\n                at: path.concat(n),\n                voids: true\n              });\n              n--;\n            }\n          }\n        }\n      }\n    },\n    removeMark: function removeMark(key) {\n      var selection = editor.selection;\n\n      if (selection) {\n        if (Range.isExpanded(selection)) {\n          Transforms.unsetNodes(editor, key, {\n            match: Text.isText,\n            split: true\n          });\n        } else {\n          var marks = _objectSpread$9({}, Editor.marks(editor) || {});\n\n          delete marks[key];\n          editor.marks = marks;\n          editor.onChange();\n        }\n      }\n    }\n  };\n  return editor;\n};\n/**\r\n * Get the \"dirty\" paths generated from an operation.\r\n */\n\n\nvar getDirtyPaths = function getDirtyPaths(op) {\n  switch (op.type) {\n    case 'insert_text':\n    case 'remove_text':\n    case 'set_node':\n      {\n        var path = op.path;\n        return Path.levels(path);\n      }\n\n    case 'insert_node':\n      {\n        var node = op.node,\n            _path2 = op.path;\n        var levels = Path.levels(_path2);\n        var descendants = Text.isText(node) ? [] : Array.from(Node.nodes(node), function (_ref3) {\n          var _ref16 = _slicedToArray(_ref3, 2),\n              p = _ref16[1];\n\n          return _path2.concat(p);\n        });\n        return [].concat(_toConsumableArray(levels), _toConsumableArray(descendants));\n      }\n\n    case 'merge_node':\n      {\n        var _path3 = op.path;\n        var ancestors = Path.ancestors(_path3);\n        var previousPath = Path.previous(_path3);\n        return [].concat(_toConsumableArray(ancestors), [previousPath]);\n      }\n\n    case 'move_node':\n      {\n        var _path4 = op.path,\n            newPath = op.newPath;\n\n        if (Path.equals(_path4, newPath)) {\n          return [];\n        }\n\n        var oldAncestors = [];\n        var newAncestors = [];\n\n        var _iterator36 = _createForOfIteratorHelper(Path.ancestors(_path4)),\n            _step36;\n\n        try {\n          for (_iterator36.s(); !(_step36 = _iterator36.n()).done;) {\n            var ancestor = _step36.value;\n            var p = Path.transform(ancestor, op);\n            oldAncestors.push(p);\n          }\n        } catch (err) {\n          _iterator36.e(err);\n        } finally {\n          _iterator36.f();\n        }\n\n        var _iterator37 = _createForOfIteratorHelper(Path.ancestors(newPath)),\n            _step37;\n\n        try {\n          for (_iterator37.s(); !(_step37 = _iterator37.n()).done;) {\n            var _ancestor = _step37.value;\n\n            var _p = Path.transform(_ancestor, op);\n\n            newAncestors.push(_p);\n          }\n        } catch (err) {\n          _iterator37.e(err);\n        } finally {\n          _iterator37.f();\n        }\n\n        return [].concat(oldAncestors, newAncestors);\n      }\n\n    case 'remove_node':\n      {\n        var _path5 = op.path;\n\n        var _ancestors = Path.ancestors(_path5);\n\n        return _toConsumableArray(_ancestors);\n      }\n\n    case 'split_node':\n      {\n        var _path6 = op.path;\n\n        var _levels = Path.levels(_path6);\n\n        var nextPath = Path.next(_path6);\n        return [].concat(_toConsumableArray(_levels), [nextPath]);\n      }\n\n    default:\n      {\n        return [];\n      }\n  }\n};\n\nexport { Editor, Element, Location, Node, Operation, Path, PathRef, Point, PointRef, Range, RangeRef, Span, Text, Transforms, createEditor };"],"sourceRoot":""}